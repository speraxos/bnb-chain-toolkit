# Pimlico

> Pimlico is the world's most popular account abstraction infrastructure platform

## Docs

- [Migration from Stackup](/stackup-migration): This guide is intended for users migrating from Stackup to Pimlico
- [Create API Key](/guides/create-api-key): To use Pimlico's services, you'll need an API key. We recommend using our CLI for the quickest setup, but you can also use the dashboard.
- [Getting Started with Pimlico](/guides/getting-started): Welcome to Pimlico, the world's most advanced ERC-4337 account abstraction infrastructure platform. This guide will help you understand Pimlico's ecosystem and get you started with building applications using our tools and services.
- [Pricing](/guides/pricing): Below is a comparison of the different pricing plans available for Pimlico. With Pimlico, you're able to launch without any upfront costs, and only pay for what you use with our pay-as-you-go plan, even for production applications with significant volume. We can also offer enterprise plans for users wishing to have a custom plan tailored to their needs. If you have any questions, please don't hesitate to [contact us through telegram](https://t.me/pimlicoHQ) or [through email](mailto:support@pimlico.io)
- [Supported Chains](/guides/supported-chains): All API calls must use the JSON-RPC format and be sent to the following URL:
- [Pimlico supports the following chains:](/guides/supported-chains): [https://api.pimlico.io/v2/8453/rpc?apikey=your\_api\_key\_here](https://api.pimlico.io/v2/8453/rpc?apikey=your_api_key_here)
- [Boosted Paymaster](/guides/boosted-paymaster/use-boosted-paymaster): The Boosted paymaster is an offchain paymaster that offers faster execution times and cheaper gas fees due to requiring fewer RPC calls and requiring no paymaster data.
- [Account Abstraction](/guides/conceptual/account-abstraction): Account abstraction is a feature that allows users to customize their Ethereum accounts with smart contract logic. It simplifies the account system by reducing Ethereum's two types of accounts (Externally Owned Accounts and Contract Accounts) to one type - Contract Accounts. The resulting contract accounts can initiate transactions, pay transaction fees, and have more flexibility and security than regular accounts.
- [ERC-4337](/guides/conceptual/erc4337): ERC-4337 is the leading proposal to achieve account abstraction on EVM chains. The standard works by creating a new type of transaction, called user operartion, that special relayers called bundlers can submit through a so-called EntryPoint contract that is able to prompt smart accounts compatible with the ERC-4337 interface to check whether the smart account considers the user operation to be valid, and then execute said user operation.
- [ERC-7579](/guides/conceptual/erc7579): ERC-7579 is a proposal that aims to standardize modular smart accounts in a minimal way to allow for continued innovation while making module interoperability between different account implementations far more achievable.
- [Conceptual Guides](/guides/conceptual): High-level explanations of core Account Abstraction and Pimlico concepts. Most useful when you want to understand how Pimlico works under the hood.
- [EIP-7702 Quickstart — Send a user operation from an EOA](/guides/eip7702/demo): This guide showcases a simple demo that uses ERC-4337 and EIP-7702 to send a sponsored user operation from a EOA. We will use SimpleSmartAccount as our smart account implementation of choice, other ERC-7702 compatible smart accounts will work as well.
- [ERC-4337 vs EIP-7702](/guides/eip7702/erc4337-vs-eip7702): This page outlines the key differences and design motivations behind ERC-4337 and EIP-7702 — two distinct approaches to improving smart accounts (also known as "account abstraction") on Ethereum.
- [Batch / sponsor transactions for an external wallets](/guides/eip7702/external): This guide showcases a simple demo that sends a batch of transactions that are sponsored to an external EIP-7702 enabled wallet.
- [EIP-7702 FAQs](/guides/eip7702/faqs): EIP-7702 is a proposal that allows EOAs to become smart accounts. It is going live in the Pectra hard fork on Ethereum Mainnet on May 7, but it is already live on some other chains like BSC Mainnet and Odyssey Testnet.
- [EIP-7702](/guides/eip7702): EIP-7702 is a proposal set for inclusion in the upcoming 2025 Pectra hardfork. The proposal introduces a new transaction type that allows EOA's to assign a "delegation designator" to their account. The delegation designator points to a smart contract and when a transaction is sent to the EOA, it executes the code at the designated address.
- [Update your existing app to sponsor gas fees for smart account users](/guides/how-to/dapp-gas-sponsorship): If you are looking to sponsor gas fees for your users without embedding a wallet in your app, you can use this guide to update your existing app to sponsor gas fees for smart accounts.
- [Migration Guide](/guides/how-to/migration-guide): This migration guide is assuming you have already migrated to ^0.1.0 and are now migrating to 0.2.0.
- [How to send multiple user operations in parallel](/guides/how-to/parallel-transactions): permissionless.js library lets you to send multiple transactions in parallel. This can be useful if you want to batch multiple calls in a single user operation or if you want to send user operations concurrently.
- [Tutorials](/guides/tutorials): Learning-oriented lessons that take you through a series of steps to complete a project. Most useful when you want to get started with Pimlico.
- [Tutorial 1 — Send your first gasless transaction](/guides/tutorials/tutorial-1): In this tutorial, you will submit your first fully-gasless transaction from a smart account.
- [Tutorial 2 — Submit a user operation with an ERC-20 Paymaster](/guides/tutorials/tutorial-2): You can visit our [ERC-20 Paymaster overview page](/references/paymaster/erc20-paymaster) to learn more about the design and architecture of our ERC-20 Paymaster, and the deployed smart contract addresses.
- [Why Pimlico for Enterprises](/guides/why-pimlico/enterprise): Are you an enterprise looking to leverage smart accounts and wondering why you should use Pimlico as your account abstraction infrastructure provider?
- [Why Pimlico for Startups](/guides/why-pimlico/startups): Are you a startup looking to use smart accounts and wondering why you should use Pimlico as your account abstraction infrastructure provider?
- [Bundler Error Codes](/references/bundler/bundler-error-codes): The bundler implements the [EIP-7769](https://eips.ethereum.org/EIPS/eip-7769) spec which standardizes ERC-4337 bundler error codes across different bundler implementations.
- [Bundler FAQs](/references/bundler/faqs): There can be many reasons for this. The most common are:
- [Alto Bundler](/references/bundler): ![Landscape](/alto.png)
- [Public Endpoint](/references/bundler/public-endpoint): Pimlico provides a public bundler endpoint for developers to test and prototype their applications without requiring an API key.
- [Self-Host Guide](/references/bundler/self-host): This guide holds all information related to self hosting your own Alto bundler instance. Including installation, setting up, running, and troubleshooting.
- [How to use Alto in CI/CD testing](/references/bundler/testing): To effectively integrate Alto, a performant and type-safe ERC-4337 bundler developed by Pimlico, into your CI/CD testing pipeline, we recommend utilizing Prool, a library that provides programmatic HTTP testing instances for Ethereum.rool facilitates the creation of isolated Ethereum environments, enabling efficient testing of smart contracts and related components.
**Installation Steps:**
- [How to use the bundler](/references/bundler/usage): Tip
- [Pimlico Paymasters](/references/paymaster): Pimlico providers two different types of paymasters to allow you to abstract away the gas fees for your users.
- [permissionless.js FAQs](/references/permissionless/faqs): Just decrease your bundler's polling interval like so:
- [Overview](/references/permissionless): <h1 className="vocs_HomePage_title">permissionless.js</h1>
<HomePage.Tagline>Build with ERC-4337 smart accounts, bundlers, paymasters, and user operations</HomePage.Tagline>
- [Features](/references/permissionless): <h1 className="vocs_HomePage_title">permissionless.js</h1>
<HomePage.Tagline>Build with ERC-4337 smart accounts, bundlers, paymasters, and user operations</HomePage.Tagline>
- [Source Code](/references/permissionless): <h1 className="vocs_HomePage_title">permissionless.js</h1>
<HomePage.Tagline>Build with ERC-4337 smart accounts, bundlers, paymasters, and user operations</HomePage.Tagline>
- [Why permissionless.js](/references/permissionless/why): A summary of why we built permissionless.js
- [Pimlico Platform](/references/platform): **Pimlico** is the world's most popular ERC-4337 account abstraction infrastructure platform. Pimlico provides a suite of tools and services to help you build, deploy, and manage smart accounts on Ethereum and other EVM-compatible chains.
- [Difference between various Smart Account types in permissionless.js](/guides/how-to/accounts/comparison): permissionless.js supports 8 types of accounts. Below is an overview of each account type and their key features:
- [Account Support](/guides/how-to/accounts/support): permissionless.js supports 6 types of accounts natively (but can easily be extended to support any compatible ERC-4337 account). The below table details which EntryPoints each account is valid for.
- [How to create and use a Biconomy account with permissionless.js](/guides/how-to/accounts/use-biconomy-account): [Biconomy Smart Account](https://github.com/bcnmy/scw-contracts) is a smart account building on the core concepts of Gnosis and Argent safes. You can use Biconomy with plugins such as session keys, and even write your own plugins.
- [How to create and use a Coinbase smart account with permissionless.js](/guides/how-to/accounts/use-coinbase-account): Warning
- [How to use an ERC-7579 compatible smart account with permissionless.js](/guides/how-to/accounts/use-erc7579-account): [ERC-7579](https://eips.ethereum.org/EIPS/eip-7579) defines a standard for modular smart account interfaces. It also defines behavior for interoperability with minimal restrictions for accounts and modules.
- [How to create and use a Kernel account with permissionless.js](/guides/how-to/accounts/use-kernel-account): ZeroDev, the author of Kernel, maintains their own in-house SDK built closely on top of permissionless.js that you can use for the account system while still plugging in all the other components from permissionless.js. Take a look at [their documentation](https://docs.zerodev.app) for more information.
- [How to create and use a LightAccount with permissionless.js](/guides/how-to/accounts/use-light-account): [LightAccount](https://github.com/alchemyplatform/light-account) is the smart account implementation made by Alchemy and inspired by SimpleAccount.
It has a few additional [features](https://github.com/alchemyplatform/light-account?tab=readme-ov-file#features), such as transferrable ownership and upgradability.
This guide will show you how to create and use a LightAccount with permissionless.js.
- [How to use MetaMask Smart Accounts with permissionless.js](/guides/how-to/accounts/use-metamask-account): MetaMask maintains their own in-house SDK built closely on top of viem that you can use for the account system while still plugging in all the other components from permissionless.js. Take a look at [their documentation](https://docs.metamask.io/delegation-toolkit/how-to/send-user-operation) for more information.
- [How to create and use a Biconomy Nexus account with permissionless.js](/guides/how-to/accounts/use-nexus-account): [Biconomy Nexus Smart Account](https://github.com/bcnmy/nexus) is a smart account building on the core concepts of ERC-7579. You can use Nexus with plugins such as session keys, and even write your own plugins.
- [How to create and use a Safe account with multiple signers](/guides/how-to/accounts/use-safe-account-with-multiple-signers): [Safe](https://safe.global) is the most battle-tested Ethereum smart account provider. With their recent release of their ERC-4337 module, it is now possible to plug in Safe accounts to ERC-4337 bundlers and paymasters. This guide will walk you through how to create and use a Safe account with permissionless.js.
- [How to create and use a Safe account with permissionless.js](/guides/how-to/accounts/use-safe-account): [Safe](https://safe.global) is the most battle-tested Ethereum smart account provider. With their recent release of their ERC-4337 module, it is now possible to plug in Safe accounts to ERC-4337 bundlers and paymasters. This guide will walk you through how to create and use a Safe account with permissionless.js.
- [How to create and use a SimpleAccount with permissionless.js](/guides/how-to/accounts/use-simple-account): [SimpleAccount](https://github.com/eth-infinitism/account-abstraction/blob/develop/contracts/accounts/SimpleAccount.sol) is the original reference sample implementation of an ERC-4337 made by the Eth-Infinitism team. Despite being a reference implementation, it is widely used in production. It allows for a single EOA signer to sign user operations for the account. This guide will show you how to create and use a SimpleAccount with permissionless.js.
- [How to create and use a Thirdweb account with permissionless.js](/guides/how-to/accounts/use-thirdweb-account): Thirdweb is compatible with EntryPoint versions v0.6 and v0.7. In this guide, we will use EntryPoint v0.7.
- [How to create and use a Trust smart account with permissionless.js](/guides/how-to/accounts/use-trustwallet-account): [Trust Wallet](https://trustwallet.com/), the author of [Barz](https://github.com/trustwallet/barz), provides a smart contract security monitoring service for each and every Barz deployed on-chain including Barz created by SDK.
This is a service that TrustWallet provides to builders to build innovative products on top of a secure foundation.
Monitoring will automatically start as soon as the Barz account is deployed on-chain; for projects wanting to get security monitoring information, reach out to the smart wallet channel in [TrustWallet Discord](https://discord.gg/trustwallet).
- [How to debug dropped user operations](/guides/how-to/debugging/dropped-user-operations): If a user operation is dropped in the mempool of the bundler after initially being accepted by it, the error can not be propagated by the bundler to the user. To debug what happened to these user operations, we recommend using the [User Operation Tracking](https://dashboard.pimlico.io/debugging/tracking) page on our dashboard, which will show you the exact flow of the user operation stage-by-stage through Pimlico's bundler with timestamps, including any errors it encounters.
- [Debugging User Operations](/guides/how-to/debugging/user-operations): When debugging user operations, Pimlico provides powerful tools to help you identify and resolve issues quickly. This guide covers the essential debugging techniques using request logs and the debugging section.
- [ERC-20 Paymaster Architecture](/guides/how-to/erc20-paymaster/architecture): You can view the whole ERC-20 Paymaster contract [in our repository](https://github.com/pimlicolabs).
- [ERC-20 Paymaster Contract Addresses](/guides/how-to/erc20-paymaster/contract-addresses): Below are the contract addresses for the ERC-20 Paymaster contracts that are currently deployed.
- [ERC-20 Paymaster FAQs](/guides/how-to/erc20-paymaster/faqs): A Paymaster is a special smart contract under the [ERC-4337](https://eips.ethereum.org/EIPS/eip-4337) specification that user operations are able to delegate the responsibility of gas fee payments to. This means that ERC-4337 smart contract wallets no longer need to necessarily be responsible for directly paying gas fees in ETH. The paymaster contracts are able to use custom logic (with certain limitations) to decide whether or not they are willing to sponsor a user operation.
- [ERC-20 Paymaster](/guides/how-to/erc20-paymaster): ![Landscape](/erc20paymaster.png)
- [Supported Tokens](/guides/how-to/erc20-paymaster/supported-tokens): List of tokens that are supported by Pimlico's ERC-20 Paymaster. You can view the list of enabled tokens on your [Pimlico dashboard](https://dashboard.pimlico.io/billing/plan).
- [How to claim a gas grant](/guides/how-to/gas-programs/claim): This guide explains how to claim a gas grant that has been allocated to you through an organization like Arbitrum or Safe on Pimlico.
- [How to create a gas program on Pimlico](/guides/how-to/gas-programs/gas-program): This guide is for chain operators who want to create a gas program on Pimlico. If you are a developer looking to use a gas program made by someone else or looking to sponsor your own user operations, you should instead look in the [sponsorship policies guide](/guides/how-to/sponsorship-policies).
- [How to use the claimed gas grant](/guides/how-to/gas-programs/use): If you are using [permissionless.js](/references/permissionless), you can use the `PimlicoPaymasterClient` to use sponsorship policies.
- [Using Pimlico with Privy](/guides/how-to/integrations/privy): This guide shows you how to enable Smart accounts on your Privy account powered by Pimlico's infrastructure.
- [How to conditionally sponsor a user operation](/guides/how-to/paymasters/conditional-sponsoring): With permissionless.js and Viem, you can conditionally sponsor a user operation. This can be useful in situations like:
- [Extending sponsorship duration](/guides/how-to/paymasters/extending-sponsorship-duration): By default, verifying paymaster sponsorships are valid for 10 minutes. It’s now possible to set a custom validity period of up to 24 hours.
- [How to Protect Your API Keys](/guides/how-to/security/protect-api-keys): Keeping your API keys secure is essential. Here are three main ways to protect them:
- [How to use a DFNS signer with permissionless.js](/guides/how-to/signers/dfns): [Dfns](https://www.dfns.co/) is an MPC/TSS Wallet-as-a-Service API/SDK provider. Dfns aims to optimize the balance of security and UX by deploying key shares into a decentralized network on the backend while enabling wallet access via biometric open standards on the frontend like Webauthn. Reach out [here](https://www.dfns.co/) to set up a sandbox environment to get started.
- [How to use a Dynamic signer with permissionless.js](/guides/how-to/signers/dynamic): permissionless.js allows you to plug in custom signers to control the accounts that you create. Dynamic is an embedded wallet provider that allows you to easily onboard users to your dapp. It is possible to use Dynamic as a signer with permissionless.js, allowing you to use Dynamic to create and control smart accounts and sign transactions.
- [How to use a Fireblocks signer with permissionless.js](/guides/how-to/signers/fireblocks): [Fireblocks](https://www.fireblocks.com/) is a user-friendly platform designed for building blockchain-based products and managing digital asset operations. It uses a direct custody approach, combining high performance with zero counterparty risk and multi-layered security. The platform includes secure MPC-based digital asset wallets, a policy engine for governance and transaction rules, and comprehensive treasury management. Fireblocks' security framework features multiple layers, including MPC-CMP technology, secure enclaves, and a robust policy engine, ensuring protection against cyberattacks, internal threats, and human errors. It's widely used for various operations like treasury, trading, and managing NFTs, smart contracts, and user wallets.
- [Signers for permissionless.js](/guides/how-to/signers): Smart accounts are able to define custom authentication and authorization schemes, but still require signatures to validate user operations coming from signers. permissionless.js which accepts `LocalAccount | EIP1193Provider | WalletClient`, that can be passed as an owner to `createSmartAccountClient`. While by default these owners have full control over the smart account, it's possible to define custom roles and permissions for owners, and mix-and-match them to create complex multi-signature schemes, as well as rotate signers and revoke their access.
- [How to Integrate Pimlico with Lit Protocol OTP Authentication](/guides/how-to/signers/lit-protocol): This how-to guide will walk you through the steps to integrate Lit Protocol's OTP sign-in with email, SMS, and Whatsapp with a smart account whose user operations are relayed and sponsored by Pimlico.
- [How to use a Magic signer with permissionless.js](/guides/how-to/signers/magic): [Magic](https://magic.link/) is a popular embedded wallet provider that supports social logins. While social logins are great, your users still need to onramp in order to pay for gas, which introduces significant friction.
- [How to use an Openfort signer with permissionless.js](/guides/how-to/signers/openfort): permissionless.js allows you to plug in custom signers to control the accounts that you create. Openfort is an embedded wallet provider that allows you to easily onboard users to your dapp.
- [How to use a Para signer with permissionless.js](/guides/how-to/signers/para): [Para](https://www.getpara.com/) offers a signing solution enabling the creation of secure, embedded MPC wallets accessible via email or social login. These wallets, compatible across different applications, offer portability, recoverability, and programmability, eliminating the need for users to establish separate signers or contract accounts for each application.
- [How to use a Particle Network signer with permissionless.js](/guides/how-to/signers/particle-network): [Particle Network](https://particle.network/) is an intent-centric, modular wallet-as-a-service (WaaS). By utilizing MPC-TSS for key management, Particle can streamline onboarding via familiar Web2 methods such as Google, emails, and phone numbers.
- [How to use a Passkey (WebAuthn) server](/guides/how-to/signers/passkey-server): This how-to guide will walk you through the steps to integrate Passkey (WebAuthn) server with a smart account whose user operations are relayed and sponsored by Pimlico.
- [How to use a Passkey (WebAuthn) signer](/guides/how-to/signers/passkey): This how-to guide will walk you through the steps to integrate Passkey (WebAuthn) signer with a smart account whose user operations are relayed and sponsored by Pimlico.
- [How to use a Privy signer with permissionless.js](/guides/how-to/signers/privy): permissionless.js allows you to plug in custom signers to control the accounts that you create. Privy is an embedded wallet provider that allows you to easily onboard users to your dapp. It is possible to use Privy as a signer with permissionless.js, allowing you to use Privy to create and control smart accounts and sign transactions.
- [How to use a Turnkey signer with permissionless.js](/guides/how-to/signers/turnkey): [Turnkey](https://turnkey.com/) is a key infrastructure provider with a great developer API and a powerful security policy engine.
- [How to use Web3Auth with Pimlico](/guides/how-to/signers/web3auth): [Web3Auth](https://web3auth.io) is a popular embedded wallet provider that supports a range of login methods. Web3Auth also has strong native account abstraction support allowing you to offer smooth UX for your users through features like social logins, sponsored transactions, and transaction batching.
- [How to use Sponsorship Policies](/guides/how-to/sponsorship-policies): Sponsorship Policies are hosted policies that allow you to define custom rules for sponsorships.
- [How to use Sponsorship Policy webhooks](/guides/how-to/sponsorship-policies/webhook): Webhooks allow you to receive real-time notifications when sponsorship-related events occur. You can use webhooks to approve or reject sponsorship requests and receive notifications about finalized sponsorships. Start by going to the [sponsorship policies page](https://dashboard.pimlico.io/sponsorship-policies) on the Pimlico dashboard, clicking on the existing policy and clicking on the "Edit button".
- [Testing with BuildBear Sandboxes](/guides/how-to/testing/build-bear): This guide introduces how to setup a BuildBear Sandbox with for testing the Alto bundler and a mock paymaster. We will be using viem and permissionless to interact with the sandbox enviornment.
- [Local Testing With Docker](/guides/how-to/testing/docker): This guide introduces a ready-to-use mock test environment, that contains:
- [Prool](/guides/how-to/testing/prool): This guide introduces how to setup and run tests in a mock environment using [Prool](https://github.com/wevm/prool).
- [Overview](/guides/how-to/testing/prool): Prool is a library by [Wevm](https://github.com/wevm/viem) that lets you programmatically interact with Ethereum server instances like Nodes, Bundlers, and Paymasters.
- [Chain is not supported](/references/bundler/bundler-errors/chain-not-supported): The chain you are trying to use is not supported by Pimlico.
- [Invalid 'apikey' query parameter](/references/bundler/bundler-errors/invalid-api-key): The API key you are trying to use is not valid. It either does not exist or has been deleted.
- [Validation error: Invalid discriminator value](/references/bundler/bundler-errors/invalid-discriminator-value): If you see an error similar to the one above, it means you are calling a method on the Pimlico API that is not supported. The most common reason for this is using the Pimlico API endpoint for standard public Ethereum JSON-RPC methods. As a reminder, the Pimlico API only supports bundler and paymaster methods.
- [Unknown error from alto bundler](/references/bundler/bundler-errors/unknown-error): The bundler encountered an unexpected error. This is either an internal 500 error, or an error with sensitive information that can not returned.
- [eth_estimateUserOperationGas](/references/bundler/endpoints/eth_estimateUserOperationGas): This method simulates the user operation and estimates the appropriate gas limits for it. If the operation is not successful, it will return an error.
- [eth_getUserOperationByHash](/references/bundler/endpoints/eth_getUserOperationByHash): This method fetches the user operation, given the `userOpHash`. If the user operation is not available, it will return `null`.
- [eth_getUserOperationReceipt](/references/bundler/endpoints/eth_getUserOperationReceipt): This method fetches the receipt of a user operation, given the `userOpHash`. If the receipt is not available, it will return `null`.
- [eth_sendUserOperation](/references/bundler/endpoints/eth_sendUserOperation): Submits a user operation to be included on-chain and returns the `userOpHash` if successful (or queued). If the operation is not successful, it will return an error.
- [eth_supportedEntryPoints](/references/bundler/endpoints/eth_supportedEntryPoints): This method fetches the EntryPoint addresses supported by the bundler. The first address is the one preferred by the bundler to use.
- [pimlico_getUserOperationGasPrice](/references/bundler/endpoints/pimlico_getUserOperationGasPrice): This method returns the gas prices that must be used for the user operation you are bundling with Pimlico bundlers.
- [pimlico_getUserOperationStatus](/references/bundler/endpoints/pimlico_getUserOperationStatus): This method takes in a user operation hash and returns the status of the operation and, optionally, the transaction hash the bundler is using to bundle the user operation on-chain. The status can be one of the following:
- [pimlico_simulateAssetChanges](/references/bundler/endpoints/pimlico_simulateAssetChanges): NOTICE: This page is still in draft and the API may change.
- [AA10 sender already constructed](/references/bundler/entrypoint-errors/aa10): The sender (i.e. the smart account) has already been created previously. You may be trying to create the account multiple times.
- [AA13 initCode failed or OOG](/references/bundler/entrypoint-errors/aa13): OOG = Out Of Gas
- [AA14 initCode must return sender](/references/bundler/entrypoint-errors/aa14): The address of the smart account deployed with the `initCode` provided does not match match the `sender` address provided in the user operation.
- [AA15 initCode must create sender](/references/bundler/entrypoint-errors/aa15): The smart account deployment process with the `initCode` does not return any `sender` address. There are two possible reasons:
- [AA20 account not deployed](/references/bundler/entrypoint-errors/aa20): An `initCode` was not specified, but the `sender` address (i.e. the smart account) is not deployed.
- [AA21 didn't pay prefund](/references/bundler/entrypoint-errors/aa21): You are *not* using a paymaster, but the `sender` address did not have enough native tokens to cover the gas costs associated with the user operation.
- [AA22 expired or not due](/references/bundler/entrypoint-errors/aa22): The `signature` used in the user operation is not valid, because it is outside of the time range it specified.
- [AA23 reverted (or OOG)](/references/bundler/entrypoint-errors/aa23): OOG = Out Of Gas
- [AA24 signature error](/references/bundler/entrypoint-errors/aa24): The `validateUserOp` function of the smart account rejected the signature of the user operation.
- [AA25 invalid account nonce](/references/bundler/entrypoint-errors/aa25): The `nonce` of the user operation is invalid.
- [AA30 paymaster not deployed](/references/bundler/entrypoint-errors/aa30): The first 20 bytes of the `paymasterAndData` field specify the address of the paymaster contract you are requesting to use.
- [AA31 paymaster deposit too low](/references/bundler/entrypoint-errors/aa31): The first 20 bytes of the `paymasterAndData` field specify the address of the paymaster contract you are requesting to use.
- [AA32 expired or not due](/references/bundler/entrypoint-errors/aa32): By default, signatures from Pimlico's verifying paymaster are only valid for 10 minutes.
- [AA33 reverted (or OOG)](/references/bundler/entrypoint-errors/aa33): OOG = Out Of Gas
- [AA34 signature error](/references/bundler/entrypoint-errors/aa34): The first 20 bytes of the `paymasterAndData` field specify the address of the paymaster contract you are requesting to use.
- [AA40 over verificationGasLimit](/references/bundler/entrypoint-errors/aa40): The amount of gas used by the smart account and paymaster verification exceeded the `verificationGasLimit` set for the user operation.
- [AA41 too little verificationGas](/references/bundler/entrypoint-errors/aa41): The amount of gas used by the smart account verification exceeded the `verificationGasLimit` set for the user operation.
- [AA50 postOp reverted](/references/bundler/entrypoint-errors/aa50): `postOp` is a function that is called by the EntryPoint on the paymaster contract after the user operation execution is completed. It is often used by paymasters to perform additional accounting logic.
- [AA51 prefund below actualGasCost](/references/bundler/entrypoint-errors/aa51): The actual gas cost of the user operation ended up being higher than the prefund paid by the smart account or the paymaster.
- [AA90 invalid beneficiary](/references/bundler/entrypoint-errors/aa90): The bundler did not set a beneficiary address when bundling the user operation.
- [AA91 failed send to beneficiary](/references/bundler/entrypoint-errors/aa91): The EntryPoint's transfer to the beneficiary of the funds accrued from the user operation reverted.
- [AA92 internal call only](/references/bundler/entrypoint-errors/aa92): The bundler attempted to call `innerHandleOp` function of the EntryPoint directly as opposed to through the `handleOps` function.
- [AA93 invalid paymasterAndData](/references/bundler/entrypoint-errors/aa93): The first 20 bytes of the `paymasterAndData` field specify the address of the paymaster contract you are requesting to use.
- [AA94 gas values overflow](/references/bundler/entrypoint-errors/aa94): One or more of the gas values of the user operation do not fit into a `uint160`.
- [AA95 out of gas](/references/bundler/entrypoint-errors/aa95): The bundler tried to bundle the user operation with the gas limit set too low.
- [AA96 invalid aggregator](/references/bundler/entrypoint-errors/aa96): The bundler tried to bundle aggregated user operations with an invalid aggregator.
- [EntryPoint Errors](/references/bundler/entrypoint-errors): We have listed all the errors that an ERC 4337 EntryPoint can return.
- [ERC-20 Paymaster Architecture](/references/paymaster/erc20-paymaster/architecture): You can view the whole ERC-20 Paymaster contract [in our repository](https://github.com/pimlicolabs).
- [ERC-20 Paymaster Contract Addresses](/references/paymaster/erc20-paymaster/contract-addresses): Below are the contract addresses for the ERC-20 Paymaster contracts that are currently deployed.
- [ERC-20 Paymaster FAQs](/references/paymaster/erc20-paymaster/faqs): A Paymaster is a special smart contract under the [ERC-4337](https://eips.ethereum.org/EIPS/eip-4337) specification that user operations are able to delegate the responsibility of gas fee payments to. This means that ERC-4337 smart contract wallets no longer need to necessarily be responsible for directly paying gas fees in ETH. The paymaster contracts are able to use custom logic (with certain limitations) to decide whether or not they are willing to sponsor a user operation.
- [ERC-20 Paymaster](/references/paymaster/erc20-paymaster): ![Landscape](/erc20paymaster.png)
- [Supported Tokens](/references/paymaster/erc20-paymaster/supported-tokens): List of tokens that are supported by Pimlico's ERC-20 Paymaster. You can view the list of enabled tokens on your [Pimlico dashboard](https://dashboard.pimlico.io/billing/plan).
- [Verifying Paymaster Common Errors](/references/paymaster/verifying-paymaster/common-errors): `Insufficient Pimlico balance for sponsorship, please top up`
- [Verifying Paymaster Endpoints](/references/paymaster/verifying-paymaster/endpoints): All calls are in JSON-RPC format and have to be made to the following URL: `https://api.pimlico.io/v2/{chain}/rpc?apikey=[YOUR_API_KEY_HERE]`
- [Paymaster FAQs](/references/paymaster/verifying-paymaster/faqs): Frequently Asked Questions about Pimlico's Verifying Paymaster
- [Verifying Paymaster](/references/paymaster/verifying-paymaster): Pimlico's Verifying Paymaster is a combination of an API and an on-chain smart contract that allows you to sponsor gas fees for your users. By calling our API, you get back a signature that will be accepted by our smart contract and will pay for the gas fees of your users.
- [How to use the Verifying Paymaster](/references/paymaster/verifying-paymaster/usage): Tip
- [Update your existing app to sponsor gas fees for smart account users](/references/permissionless/how-to/dapp-gas-sponsorship): If you are looking to sponsor gas fees for your users without embedding a wallet in your app, you can use this guide to update your existing app to sponsor gas fees for smart accounts.
- [Migration Guide](/references/permissionless/how-to/migration-guide): This migration guide is assuming you have already migrated to ^0.1.0 and are now migrating to 0.2.0.
- [How to send multiple user operations in parallel](/references/permissionless/how-to/parallel-transactions): permissionless.js library lets you to send multiple transactions in parallel. This can be useful if you want to batch multiple calls in a single user operation or if you want to send user operations concurrently.
- [permissionless.js](/references/permissionless/reference): permissionless.js is a TypeScript library built on viem for interacting with ERC-4337 bundlers, paymasters, and User Operations.
- [Tutorials](/references/permissionless/tutorial): Learning-oriented lessons that take you through a series of steps to complete a project. Most useful when you want to get started with Pimlico.
- [Tutorial 1 — Send your first gasless transaction](/references/permissionless/tutorial/tutorial-1): In this tutorial, you will submit your first fully-gasless transaction from a smart account.
- [Tutorial 2 — Submit a user operation with an ERC-20 Paymaster](/references/permissionless/tutorial/tutorial-2): You can visit our [ERC-20 Paymaster overview page](/references/paymaster/erc20-paymaster) to learn more about the design and architecture of our ERC-20 Paymaster, and the deployed smart contract addresses.
- [permissionless.js FAQs](/references/permissionless/v0_1/faqs): This error is thrown when the bundler takes too long to bundle your user operation or the default timeout configured in permissionless.js is not enough.
This could be due to the block time of the chain you are using is more than the default timeout.
- [Overview](/references/permissionless/v0_1): <h1 className="vocs_HomePage_title">permissionless.js</h1>
- [Features](/references/permissionless/v0_1): <h1 className="vocs_HomePage_title">permissionless.js</h1>
- [Source Code](/references/permissionless/v0_1): <h1 className="vocs_HomePage_title">permissionless.js</h1>
- [Why permissionless.js](/references/permissionless/v0_1/why): A summary of why we built permissionless.js
- [Overview](/references/permissionless/wagmi): <h1 className="vocs_HomePage_title">@permissionless/wagmi</h1>
<HomePage.Tagline>Enable gas sponsorship and transaction batching for your app with just a couple lines of code</HomePage.Tagline>
- [Features](/references/permissionless/wagmi): <h1 className="vocs_HomePage_title">@permissionless/wagmi</h1>
<HomePage.Tagline>Enable gas sponsorship and transaction batching for your app with just a couple lines of code</HomePage.Tagline>
- [Source Code](/references/permissionless/wagmi): <h1 className="vocs_HomePage_title">@permissionless/wagmi</h1>
<HomePage.Tagline>Enable gas sponsorship and transaction batching for your app with just a couple lines of code</HomePage.Tagline>
- [Pagination](/references/platform/api/pagination): The Pimlico platform API supports certain “list” API methods. For example, you can list sponsorship policies. These list API methods share a common structure and accept, at a minimum, the following three parameters: `limit`, `starting_after`, and `ending_before`.
- [API Upgrade](/references/platform/api/upgrade): We are announcing a change to our API behavior for the `eth_estimateUserOperationGas` method. Previously, our system provided a default ETH balance override when estimating gas for User Operations. This is an optional upgrade to make sure your users have enough ETH to cover the operation’s cost.
- [pimlico_getTokenQuotes](/guides/how-to/erc20-paymaster/endpoints/pimlico_getTokenQuotes): This method returns the tentative token exchange rates used by the ERC-20 Paymaster.
- [pm_getPaymasterData](/guides/how-to/erc20-paymaster/endpoints/pm_getPaymasterData): This method returns values to be used in paymaster-related fields of a signed user operation. The context parameter can be an object with either a `token` field (for ERC-20 mode) or a `sponsorshipPolicyId` field (for sponsorship mode), or null.
- [pm_getPaymasterStubData](/guides/how-to/erc20-paymaster/endpoints/pm_getPaymasterStubData): This method returns stub values to be used in paymaster-related fields of an unsigned user operation for gas estimation. The context parameter can be an object with either a `token` field (for ERC-20 mode) or a `sponsorshipPolicyId` field (for sponsorship mode), or null.
- [pm_sponsorUserOperation](/guides/how-to/erc20-paymaster/endpoints/pm_sponsorUserOperation): This method sponsors a user operation by providing all necessary paymaster-related fields and updated gas parameters. The context parameter can be an object with either a `token` field (for ERC-20 mode) or a `sponsorshipPolicyId` field (for sponsorship mode), or null.
- [How to calculate UserOperation's costs using the ERC-20 Paymaster](/guides/how-to/erc20-paymaster/how-to/calculate-costs): This guide will show you how to estimate your user operation's cost in denomination of the ERC-20 token as well as USD.
- [How to use the ERC-20 Paymaster with unlimited token approvals](/guides/how-to/erc20-paymaster/how-to/use-paymaster-with-unlimited-approval): When using Pimlico's ERC-20 Paymaster, the paymaster needs approval to spend funds on the payer's behalf. The amount to approve must be atleast equal to the userOperation's maxCost.
- [How to use the ERC-20 Paymaster](/guides/how-to/erc20-paymaster/how-to/use-paymaster): This guide will show you how to use the `prepareUserOperationForErc20Paymaster` function in permissionless.
- [pimlico_getSupportedTokens](/references/paymaster/erc20-paymaster/endpoints/pimlico_getSupportedTokens): This method returns the list of tokens supported by the ERC-20 Paymaster for the current user on a specific chain.
- [pimlico_getTokenQuotes](/references/paymaster/erc20-paymaster/endpoints/pimlico_getTokenQuotes): This method returns the tentative token exchange rates used by the ERC-20 Paymaster.
- [pm_getPaymasterData](/references/paymaster/erc20-paymaster/endpoints/pm_getPaymasterData): This method returns values to be used in paymaster-related fields of a signed user operation. The context parameter can be an object with either a `token` field (for ERC-20 mode) or a `sponsorshipPolicyId` field (for sponsorship mode), or null.
- [pm_getPaymasterStubData](/references/paymaster/erc20-paymaster/endpoints/pm_getPaymasterStubData): This method returns stub values to be used in paymaster-related fields of an unsigned user operation for gas estimation. The context parameter can be an object with either a `token` field (for ERC-20 mode) or a `sponsorshipPolicyId` field (for sponsorship mode), or null.
- [pm_sponsorUserOperation](/references/paymaster/erc20-paymaster/endpoints/pm_sponsorUserOperation): This method sponsors a user operation by providing all necessary paymaster-related fields and updated gas parameters. The context parameter can be an object with either a `token` field (for ERC-20 mode) or a `sponsorshipPolicyId` field (for sponsorship mode), or null.
- [Difference between various Smart Account types in permissionless.js](/references/permissionless/how-to/accounts/comparison): permissionless.js supports 8 types of accounts. Below is an overview of each account type and their key features:
- [Account Support](/references/permissionless/how-to/accounts/support): permissionless.js supports 6 types of accounts natively (but can easily be extended to support any compatible ERC-4337 account). The below table details which EntryPoints each account is valid for.
- [How to create and use a Biconomy account with permissionless.js](/references/permissionless/how-to/accounts/use-biconomy-account): [Biconomy Smart Account](https://github.com/bcnmy/scw-contracts) is a smart account building on the core concepts of Gnosis and Argent safes. You can use Biconomy with plugins such as session keys, and even write your own plugins.
- [How to create and use a Coinbase smart account with permissionless.js](/references/permissionless/how-to/accounts/use-coinbase-account): Warning
- [How to use an ERC-7579 compatible smart account with permissionless.js](/references/permissionless/how-to/accounts/use-erc7579-account): [ERC-7579](https://eips.ethereum.org/EIPS/eip-7579) defines a standard for modular smart account interfaces. It also defines behavior for interoperability with minimal restrictions for accounts and modules.
- [How to create and use a Kernel account with permissionless.js](/references/permissionless/how-to/accounts/use-kernel-account): ZeroDev, the author of Kernel, maintains their own in-house SDK built closely on top of permissionless.js that you can use for the account system while still plugging in all the other components from permissionless.js. Take a look at [their documentation](https://docs.zerodev.app) for more information.
- [How to create and use a LightAccount with permissionless.js](/references/permissionless/how-to/accounts/use-light-account): [LightAccount](https://github.com/alchemyplatform/light-account) is the smart account implementation made by Alchemy and inspired by SimpleAccount.
It has a few additional [features](https://github.com/alchemyplatform/light-account?tab=readme-ov-file#features), such as transferrable ownership and upgradability.
This guide will show you how to create and use a LightAccount with permissionless.js.
- [How to create and use a Biconomy Nexus account with permissionless.js](/references/permissionless/how-to/accounts/use-nexus-account): [Biconomy Nexus Smart Account](https://github.com/bcnmy/nexus) is a smart account building on the core concepts of ERC-7579. You can use Nexus with plugins such as session keys, and even write your own plugins.
- [How to create and use a Safe account with multiple signers](/references/permissionless/how-to/accounts/use-safe-account-with-multiple-signers): [Safe](https://safe.global) is the most battle-tested Ethereum smart account provider. With their recent release of their ERC-4337 module, it is now possible to plug in Safe accounts to ERC-4337 bundlers and paymasters. This guide will walk you through how to create and use a Safe account with permissionless.js.
- [How to create and use a Safe account with permissionless.js](/references/permissionless/how-to/accounts/use-safe-account): [Safe](https://safe.global) is the most battle-tested Ethereum smart account provider. With their recent release of their ERC-4337 module, it is now possible to plug in Safe accounts to ERC-4337 bundlers and paymasters. This guide will walk you through how to create and use a Safe account with permissionless.js.
- [How to create and use a SimpleAccount with permissionless.js](/references/permissionless/how-to/accounts/use-simple-account): [SimpleAccount](https://github.com/eth-infinitism/account-abstraction/blob/develop/contracts/accounts/SimpleAccount.sol) is the original reference sample implementation of an ERC-4337 made by the Eth-Infinitism team. Despite being a reference implementation, it is widely used in production. It allows for a single EOA signer to sign user operations for the account. This guide will show you how to create and use a SimpleAccount with permissionless.js.
- [How to create and use a Thirdweb account with permissionless.js](/references/permissionless/how-to/accounts/use-thirdweb-account): Thirdweb is compatible with EntryPoint versions v0.6 and v0.7. In this guide, we will use EntryPoint v0.7.
- [How to create and use a Trust smart account with permissionless.js](/references/permissionless/how-to/accounts/use-trustwallet-account): [Trust Wallet](https://trustwallet.com/), the author of [Barz](https://github.com/trustwallet/barz), provides a smart contract security monitoring service for each and every Barz deployed on-chain including Barz created by SDK.
This is a service that TrustWallet provides to builders to build innovative products on top of a secure foundation.
Monitoring will automatically start as soon as the Barz account is deployed on-chain; for projects wanting to get security monitoring information, reach out to the smart wallet channel in [TrustWallet Discord](https://discord.gg/trustwallet).
- [How to conditionally sponsor a user operation](/references/permissionless/how-to/paymasters/conditional-sponsoring): The permissionless.js library allows you to conditionally sponsor a user operation. This can be useful in situations like:
- [How to use a DFNS signer with permissionless.js](/references/permissionless/how-to/signers/dfns): [Dfns](https://www.dfns.co/) is an MPC/TSS Wallet-as-a-Service API/SDK provider. Dfns aims to optimize the balance of security and UX by deploying key shares into a decentralized network on the backend while enabling wallet access via biometric open standards on the frontend like Webauthn. Reach out [here](https://www.dfns.co/) to set up a sandbox environment to get started.
- [How to use a Dynamic signer with permissionless.js](/references/permissionless/how-to/signers/dynamic): permissionless.js allows you to plug in custom signers to control the accounts that you create. Dynamic is an embedded wallet provider that allows you to easily onboard users to your dapp. It is possible to use Dynamic as a signer with permissionless.js, allowing you to use Dynamic to create and control smart accounts and sign transactions.
- [How to use a Fireblocks signer with permissionless.js](/references/permissionless/how-to/signers/fireblocks): [Fireblocks](https://www.fireblocks.com/) is a user-friendly platform designed for building blockchain-based products and managing digital asset operations. It uses a direct custody approach, combining high performance with zero counterparty risk and multi-layered security. The platform includes secure MPC-based digital asset wallets, a policy engine for governance and transaction rules, and comprehensive treasury management. Fireblocks' security framework features multiple layers, including MPC-CMP technology, secure enclaves, and a robust policy engine, ensuring protection against cyberattacks, internal threats, and human errors. It's widely used for various operations like treasury, trading, and managing NFTs, smart contracts, and user wallets.
- [Signers for permissionless.js](/references/permissionless/how-to/signers): Smart accounts are able to define custom authentication and authorization schemes, but still require signatures to validate user operations coming from signers. permissionless.js which accepts `LocalAccount | EIP1193Provider | WalletClient`, that can be passed as an owner to `createSmartAccountClient`. While by default these owners have full control over the smart account, it's possible to define custom roles and permissions for owners, and mix-and-match them to create complex multi-signature schemes, as well as rotate signers and revoke their access.
- [How to Integrate Pimlico with Lit Protocol OTP Authentication](/references/permissionless/how-to/signers/lit-protocol): This how-to guide will walk you through the steps to integrate Lit Protocol's OTP sign-in with email, SMS, and Whatsapp with a smart account whose user operations are relayed and sponsored by Pimlico.
- [How to use a Magic signer with permissionless.js](/references/permissionless/how-to/signers/magic): [Magic](https://magic.link/) is a popular embedded wallet provider that supports social logins. While social logins are great, your users still need to onramp in order to pay for gas, which introduces significant friction.
- [How to use a Para signer with permissionless.js](/references/permissionless/how-to/signers/para): [Para](https://www.getpara.com/) offers a signing solution enabling the creation of secure, embedded MPC wallets accessible via email or social login. These wallets, compatible across different applications, offer portability, recoverability, and programmability, eliminating the need for users to establish separate signers or contract accounts for each application.
- [How to use a Particle Network signer with permissionless.js](/references/permissionless/how-to/signers/particle-network): [Particle Network](https://particle.network/) is an intent-centric, modular wallet-as-a-service (WaaS). By utilizing MPC-TSS for key management, Particle can streamline onboarding via familiar Web2 methods such as Google, emails, and phone numbers.
- [How to use a Passkey (WebAuthn) server](/references/permissionless/how-to/signers/passkey-server): This how-to guide will walk you through the steps to integrate Passkey (WebAuthn) server with a smart account whose user operations are relayed and sponsored by Pimlico.
- [How to use a Passkey (WebAuthn) signer](/references/permissionless/how-to/signers/passkey): This how-to guide will walk you through the steps to integrate Passkey (WebAuthn) signer with a smart account whose user operations are relayed and sponsored by Pimlico.
- [How to use a Privy signer with permissionless.js](/references/permissionless/how-to/signers/privy): permissionless.js allows you to plug in custom signers to control the accounts that you create. Privy is an embedded wallet provider that allows you to easily onboard users to your dapp. It is possible to use Privy as a signer with permissionless.js, allowing you to use Privy to create and control smart accounts and sign transactions.
- [How to use a Turnkey signer with permissionless.js](/references/permissionless/how-to/signers/turnkey): [Turnkey](https://turnkey.com/) is a key infrastructure provider with a great developer API and a powerful security policy engine.
- [How to use a Web3Auth signer with permissionless.js](/references/permissionless/how-to/signers/web3auth): [Web3Auth](https://web3auth.io/) is a popular embedded wallet provider that supports social logins. While social logins are great, your users still need to onramp in order to pay for gas, which introduces significant friction.
- [Testing with BuildBear Sandboxes](/references/permissionless/how-to/testing/build-bear): This guide introduces how to setup a BuildBear Sandbox with for testing the Alto bundler and a mock paymaster. We will be using viem and permissionless to interact with the sandbox enviornment.
- [Local Testing With Docker](/references/permissionless/how-to/testing/docker): This guide introduces a ready-to-use mock test environment, that contains:
- [to7702KernelSmartAccount](/references/permissionless/reference/accounts/to7702KernelSmartAccount): Creates a KernelAccount instance by delegating `owner` using EIP-7702.  Check out [this guide](/guides/eip7702/demo) for a complete tutorial.
- [to7702SimpleSmartAccount](/references/permissionless/reference/accounts/to7702SimpleSmartAccount): Creates a SimpleAccount instance by delegating `owner` using EIP-7702.
- [toKernelSmartAccount](/references/permissionless/reference/accounts/toKernelSmartAccount): Creates a KernelAccount instance controlled by a `owners`.  Check out [this guide](/guides/how-to/accounts/use-kernel-account) for a complete tutorial.
- [toLightSmartAccount](/references/permissionless/reference/accounts/toLightSmartAccount): Creates a LightAccount instance controlled by a `owner`.
- [toNexusSmartAccount](/references/permissionless/reference/accounts/toNexusSmartAccount): Creates a Biconomy's [Nexus SmartAccount](https://github.com/bcnmy/nexus) instance controlled by a `owner`.
- [toSafeSmartAccount](/references/permissionless/reference/accounts/toSafeSmartAccount): Creates a Safe smart account instance controlled by a `owners`.
- [toSimpleSmartAccount](/references/permissionless/reference/accounts/toSimpleSmartAccount): Creates a SimpleAccount instance controlled by a `owner`.
- [toTrustSmartAccount](/references/permissionless/reference/accounts/toTrustSmartAccount): Creates a Trust Wallet Smart Account instance controlled by a `owner`.  Check out [this guide](/references/permissionless/how-to/accounts/use-trustwallet-account) for a complete tutorial.
- [Pimlico Client](/references/permissionless/reference/clients/pimlicoClient): A Pimlico Bundler Client is an interface to official ERC-4337 & ERC-7677 JSON-RPC API methods that include sending user operations, estimation user operation gas limits, getting user operation receipts, supporting paymaster rpc methods and more as well as the Pimlico-specific bundler methods [pimlico\_getUserOperationStatus](/references/bundler/endpoints/pimlico_getUserOperationStatus) and [pimlico\_getUserOperationGasPrice](/references/bundler/endpoints/pimlico_getUserOperationGasPrice).
- [Smart Account Client](/references/permissionless/reference/clients/smartAccountClient): A Smart Account Client is an almost drop-in replacement for a standard viem [walletClient](https://viem.sh/docs/clients/wallet) but for managing smart accounts instead of EOA accounts. In addition, a Smart Account Client also contains, depending on the underlying smart account implementation used, a few extra actions that are specific to smart accounts.
- [accountId](/references/permissionless/reference/erc7579-actions/accountId): Gets the accountId of the smart account as defined in [ERC-7579](https://eips.ethereum.org/EIPS/eip-7579). Check out [this guide](/references/permissionless/how-to/accounts/use-erc7579-account) for a complete tutorial.
- [installModule](/references/permissionless/reference/erc7579-actions/installModule): Installs a [ERC-7579](https://eips.ethereum.org/EIPS/eip-7579) module to the smart account. Check out [this guide](/references/permissionless/how-to/accounts/use-erc7579-account) for a complete tutorial.
- [isModuleInstalled](/references/permissionless/reference/erc7579-actions/isModuleInstalled): Checks if an [ERC-7579](https://eips.ethereum.org/EIPS/eip-7579) module is installed on the smart account. Check out [this guide](/references/permissionless/how-to/accounts/use-erc7579-account) for a complete tutorial.
- [supportsExecutionMode](/references/permissionless/reference/erc7579-actions/supportsExecutionMode): Checks if a [ERC-7579](https://eips.ethereum.org/EIPS/eip-7579) execution mode is supported on the smart account. Check out [this guide](/references/permissionless/how-to/accounts/use-erc7579-account) for a complete tutorial.
- [supportsModule](/references/permissionless/reference/erc7579-actions/supportsModule): Checks if a [ERC-7579](https://eips.ethereum.org/EIPS/eip-7579) module type is supported by the smart account. Check out [this guide](/references/permissionless/how-to/accounts/use-erc7579-account) for a complete tutorial.
- [uninstallModule](/references/permissionless/reference/erc7579-actions/uninstallModule): Uninstalls a [ERC-7579](https://eips.ethereum.org/EIPS/eip-7579) module from the smart account. Check out [this guide](/references/permissionless/how-to/accounts/use-erc7579-account) for a complete tutorial.
- [getPaymasterData](/references/permissionless/reference/pimlico-actions/getPaymasterData): Retrieves paymaster-related User Operation properties to be used for sending the User Operation from Pimlico.
- [getPaymasterStubData](/references/permissionless/reference/pimlico-actions/getPaymasterStubData): Retrieves paymaster-related User Operation properties to be used for User Operation gas estimation from Pimlico.
- [getUserOperationGasPrice](/references/permissionless/reference/pimlico-actions/getUserOperationGasPrice): Return the gas price that Pimlico's bundler will accept for the User Operation.
- [getUserOperationStatus](/references/permissionless/reference/pimlico-actions/getUserOperationStatus): Return a status of the User Operation as well as potentially the hash of the transaction being used to bundle the User Operation.
- [validateSponsorshipPolicies](/references/permissionless/reference/pimlico-actions/validateSponsorshipPolicies): Validates a User Operation against an array of [sponsorship policies](https://dashboard.pimlico.io/sponsorship-policies), and returns an array of sponsorship policies (alongside additional data for each policy) that are willing to sponsor the user operation.
- [getAccountNonce](/references/permissionless/reference/public-actions/getAccountNonce): Returns the current nonce of the smart account for a specified key.
- [getSenderAddress](/references/permissionless/reference/public-actions/getSenderAddress): Return a sender address corresponding to the initCode of the User Operation where the smart account will be deployed.
- [estimateUserOperationGas](/references/permissionless/reference/smart-account-actions/estimateUserOperationGas): `SmartAccountClient` extends viem's `BundlerClient` and so extends the `estimateUserOperationGas` method.
- [getChainId](/references/permissionless/reference/smart-account-actions/getChainId): `SmartAccountClient` extends viem's `BundlerClient` and so extends the `getChainId` method.
- [getSupportedEntryPoints](/references/permissionless/reference/smart-account-actions/getSupportedEntryPoints): `SmartAccountClient` extends viem's `BundlerClient` and so extends the `getSupportedEntryPoints` method.
- [getUserOperation](/references/permissionless/reference/smart-account-actions/getUserOperation): `SmartAccountClient` extends viem's `BundlerClient` and so extends the `getUserOperation` method.
- [getUserOperationReceipt](/references/permissionless/reference/smart-account-actions/getUserOperationReceipt): `SmartAccountClient` extends viem's `BundlerClient` and so extends the `getUserOperationReceipt` method.
- [prepareUserOperation](/references/permissionless/reference/smart-account-actions/prepareUserOperation): `SmartAccountClient` extends viem's `BundlerClient` and so extends the `prepareUserOperation` method.
- [sendTransaction](/references/permissionless/reference/smart-account-actions/sendTransaction): Send a transaction from a smart account using the same `sendTransaction` interface as viem.
- [sendUserOperation](/references/permissionless/reference/smart-account-actions/sendUserOperation): `SmartAccountClient` extends viem's `BundlerClient` and so extends the `sendUserOperation` method.
- [waitForUserOperationReceipt](/references/permissionless/reference/smart-account-actions/waitForUserOperationReceipt): `SmartAccountClient` extends viem's `BundlerClient` and so extends the `waitForUserOperationReceipt` method.
- [writeContract](/references/permissionless/reference/smart-account-actions/writeContract): Uses a smart account to executes a write function on a contract.
- [getRequiredPrefund](/references/permissionless/reference/utils/getRequiredPrefund): Returns the minimum required funds in wei in the senders's smart account to execute the user operation.
- [Update your existing app to sponsor gas fees for smart account users](/references/permissionless/v0_1/how-to/dapp-gas-sponsorship): If you are looking to sponsor gas fees for your users without embedding a wallet in your app, you can use this guide to update your existing app to sponsor gas fees for smart accounts.
- [Error Handling](/references/permissionless/v0_1/how-to/error-handling): Similarly to how [error handling in viem works](https://viem.sh/docs/error-handling), every module in permissionless.js exports an accompanying error type which you can use to strongly type your `catch` statements.
- [Local Testing](/references/permissionless/v0_1/how-to/local-testing): This guide introduces a ready-to-use mock test environment, that contains:
- [Migration Guide](/references/permissionless/v0_1/how-to/migration-guide): This migration guide is assuming you migrating to ^0.1.0, but you are still looking to use EntryPoint version v0.6.
- [How to send multiple user operations in parallel](/references/permissionless/v0_1/how-to/parallel-transactions): permissionless.js library lets you to send multiple transactions in parallel. This can be useful if you want to batch multiple calls in a single user operation or if you want to send user operations concurrently.
- [permissionless.js](/references/permissionless/v0_1/reference): permissionless.js is a TypeScript library built on viem for interacting with ERC-4337 bundlers, paymasters, and User Operations.
- [Tutorials](/references/permissionless/v0_1/tutorial): Learning-oriented lessons that take you through a series of steps to complete a project. Most useful when you want to get started with Pimlico.
- [Tutorial 1 — Send your first gasless transaction](/references/permissionless/v0_1/tutorial/tutorial-1): In this tutorial, you will submit your first fully-gasless transaction from a smart account.
- [Tutorial 2 — Submit a user operation with a Verifying Paymaster](/references/permissionless/v0_1/tutorial/tutorial-2): This is a low-level tutorial that walks you through the steps of constructing a user operation from scratch. If you would like to leverage permissionless.js's high-level functions, take a look at [tutorial 1](/references/permissionless/tutorial/tutorial-1).
- [Check if an external account supports paymasters](/references/permissionless/wagmi/how-to/check-paymaster-support): If you have added support to sponsor transactions for external accounts using `@permissionless/wagmi`, you can use this guide to check if the external account supports ERC-7677 paymasters and display custom UI for your users.
- [Tutorials](/references/permissionless/wagmi/tutorial): Learning-oriented lessons that take you through a series of steps to complete a project. Most useful when you want to get started with Pimlico.
- [Tutorial 1 — Send your first gasless transaction](/references/permissionless/wagmi/tutorial/tutorial-1): In this tutorial, you will submit your first fully-gasless transaction from an external smart account.
- [Create a sponsorship policy](/references/platform/api/sponsorship-policies/create): Creates a sponsorship policy.
- [Sponsorship Policies API](/references/platform/api/sponsorship-policies): Sponsorship policies represent the rules that govern which user operations you are willing to sponsor. Use it to customize the conditions under which you are willing to subsidize the gas fees for your users.
- [List all sponsorship policies](/references/platform/api/sponsorship-policies/list): Returns a list of your sponsorship policies. The sponsorship policies are returned sorted by creation date, with the most recent sponsorship policies appearing first.
- [The Sponsorship Policy object](/references/platform/api/sponsorship-policies/object): **id:** `string`
- [Retrieve a sponsorship policy](/references/platform/api/sponsorship-policies/retrieve): Retrieves a sponsorship policy by its ID.
- [Update a sponsorship policy](/references/platform/api/sponsorship-policies/update): Updates a sponsorship policy. Any parameters not provided will be left unchanged.
- [getPaymasterData](/references/permissionless/v0_1/experimental/eip7677/getPaymasterData): Return values to be used in paymaster-related fields of a signed user operation. This method calls `pm_getPaymasterData` and is part of the experimental [ERC-7677 specification](https://github.com/ethereum/ERCs/pull/360/files).
- [getPaymasterStubData](/references/permissionless/v0_1/experimental/eip7677/getPaymasterStubData): Returns stub values to be used in paymaster-related fields of an unsigned user operation for gas estimation. This method calls `pm_getPaymasterStubData` and is part of the experimental [ERC-7677 specification](https://github.com/ethereum/ERCs/pull/360/files).
- [Account Support](/references/permissionless/v0_1/how-to/accounts/support): permissionless.js supports 6 types of accounts natively (but can easily be extended to support any compatible ERC-4337 account). The below table details which EntryPoints each account is valid for.
- [How to create and use a Biconomy account with permissionless.js](/references/permissionless/v0_1/how-to/accounts/use-biconomy-account): [Biconomy Smart Account](https://github.com/bcnmy/scw-contracts) is a smart account building on the core concepts of Gnosis and Argent safes. You can use Biconomy with plugins such as session keys, and even write your own plugins.
- [How to use an ERC-7579 compatible smart account with permissionless.js](/references/permissionless/v0_1/how-to/accounts/use-erc7579-account): [ERC-7579](https://eips.ethereum.org/EIPS/eip-7579) defines a standard for modular smart account interfaces. It also defines behavior for interoperability with minimal restrictions for accounts and modules.
- [How to create and use a Kernel account with permissionless.js](/references/permissionless/v0_1/how-to/accounts/use-kernel-account): ZeroDev, the author of Kernel, maintains their own in-house SDK built closely on top of permissionless.js that you can use for the account system while still plugging in all the other components from permissionless.js. Take a look at [their documentation](https://docs.zerodev.app) for more information.
- [How to create and use a LightAccount with permissionless.js](/references/permissionless/v0_1/how-to/accounts/use-light-account): [LightAccount](https://github.com/alchemyplatform/light-account) is the smart account implementation made by Alchemy and inspired by SimpleAccount.
It has a few additional [features](https://github.com/alchemyplatform/light-account?tab=readme-ov-file#features), such as transferrable ownership and upgradability.
This guide will show you how to create and use a LightAccount with permissionless.js.
- [How to create and use a Safe account with permissionless.js](/references/permissionless/v0_1/how-to/accounts/use-safe-account): [Safe](https://safe.global) is the most battle-tested Ethereum smart account provider. With their recent release of their ERC-4337 module, it is now possible to plug in Safe accounts to ERC-4337 bundlers and paymasters. This guide will walk you through how to create and use a Safe account with permissionless.js.
- [How to create and use a SimpleAccount with permissionless.js](/references/permissionless/v0_1/how-to/accounts/use-simple-account): [SimpleAccount](https://github.com/eth-infinitism/account-abstraction/blob/develop/contracts/accounts/SimpleAccount.sol) is the original reference sample implementation of an ERC-4337 made by the Eth-Infinitism team. Despite being a reference implementation, it is widely used in production. It allows for a single EOA signer to sign user operations for the account. This guide will show you how to create and use a SimpleAccount with permissionless.js.
- [How to create and use a Trust smart account with permissionless.js](/references/permissionless/v0_1/how-to/accounts/use-trustwallet-account): [Trust Wallet](https://trustwallet.com/), the author of [Barz](https://github.com/trustwallet/barz), provides a smart contract security monitoring service for each and every Barz deployed on-chain including Barz created by SDK.
This is a service that TrustWallet provides to builders to build innovative products on top of a secure foundation.
Monitoring will automatically start as soon as the Barz account is deployed on-chain; for projects wanting to get security monitoring information, reach out to the smart wallet channel in [TrustWallet Discord](https://discord.gg/trustwallet).
- [How to conditionally sponsor a user operation](/references/permissionless/v0_1/how-to/paymasters/conditional-sponsoring): The permissionless.js library allows you to conditionally sponsor a user operation. This can be useful in situations like:
- [How to use a DFNS signer with permissionless.js](/references/permissionless/v0_1/how-to/signers/dfns): [Dfns](https://www.dfns.co/) is an MPC/TSS Wallet-as-a-Service API/SDK provider. Dfns aims to optimize the balance of security and UX by deploying key shares into a decentralized network on the backend while enabling wallet access via biometric open standards on the frontend like Webauthn. Reach out [here](https://www.dfns.co/) to set up a sandbox environment to get started.
- [How to use a Dynamic signer with permissionless.js](/references/permissionless/v0_1/how-to/signers/dynamic): permissionless.js allows you to plug in custom signers to control the accounts that you create. Dynamic is an embedded wallet provider that allows you to easily onboard users to your dapp. It is possible to use Dynamic as a signer with permissionless.js, allowing you to use Dynamic to create and control smart accounts and sign transactions.
- [How to use a Fireblocks signer with permissionless.js](/references/permissionless/v0_1/how-to/signers/fireblocks): [Fireblocks](https://www.fireblocks.com/) is a user-friendly platform designed for building blockchain-based products and managing digital asset operations. It uses a direct custody approach, combining high performance with zero counterparty risk and multi-layered security. The platform includes secure MPC-based digital asset wallets, a policy engine for governance and transaction rules, and comprehensive treasury management. Fireblocks' security framework features multiple layers, including MPC-CMP technology, secure enclaves, and a robust policy engine, ensuring protection against cyberattacks, internal threats, and human errors. It's widely used for various operations like treasury, trading, and managing NFTs, smart contracts, and user wallets.
- [Signers for permissionless.js](/references/permissionless/v0_1/how-to/signers): Smart accounts are able to define custom authentication and authorization schemes, but still require signatures to validate user operations coming from signers. permissionless.js defines the `SmartAccountSigner` interface, which is a generic interface that signers for smart accounts can implement. While by default these signers have full control over the smart account, it's possible to define custom roles and permissions for signers, and mix-and-match them to create complex multi-signature schemes, as well as rotate signers and revoke their access.
- [How to Integrate Pimlico with Lit Protocol OTP Authentication](/references/permissionless/v0_1/how-to/signers/lit-protocol): This how-to guide will walk you through the steps to integrate Lit Protocol's OTP sign-in with email, SMS, and Whatsapp with a smart account whose user operations are relayed and sponsored by Pimlico.
- [How to use a Magic signer with permissionless.js](/references/permissionless/v0_1/how-to/signers/magic): [Magic](https://magic.link/) is a popular embedded wallet provider that supports social logins. While social logins are great, your users still need to onramp in order to pay for gas, which introduces significant friction.
- [How to use a Para signer with permissionless.js](/references/permissionless/v0_1/how-to/signers/para): [Para](https://www.getpara.com/) offers a signing solution enabling the creation of secure, embedded MPC wallets accessible via email or social login. These wallets, compatible across different applications, offer portability, recoverability, and programmability, eliminating the need for users to establish separate signers or contract accounts for each application.
- [How to use a Particle Network signer with permissionless.js](/references/permissionless/v0_1/how-to/signers/particle-network): [Particle Network](https://particle.network/) is an intent-centric, modular wallet-as-a-service (WaaS). By utilizing MPC-TSS for key management, Particle can streamline onboarding via familiar Web2 methods such as Google, emails, and phone numbers.
- [How to use a Privy signer with permissionless.js](/references/permissionless/v0_1/how-to/signers/privy): permissionless.js allows you to plug in custom signers to control the accounts that you create. Privy is an embedded wallet provider that allows you to easily onboard users to your dapp. It is possible to use Privy as a signer with permissionless.js, allowing you to use Privy to create and control smart accounts and sign transactions.
- [How to use a Turnkey signer with permissionless.js](/references/permissionless/v0_1/how-to/signers/turnkey): [Turnkey](https://turnkey.com/) is a key infrastructure provider with a great developer API and a powerful security policy engine.
- [How to use a Web3Auth signer with permissionless.js](/references/permissionless/v0_1/how-to/signers/web3auth): [Web3Auth](https://web3auth.io/) is a popular embedded wallet provider that supports social logins. While social logins are great, your users still need to onramp in order to pay for gas, which introduces significant friction.
- [signerToKernelSmartAccount](/references/permissionless/v0_1/reference/accounts/signerToKernelSmartAccount): Creates a KernelAccount instance controlled by a `SmartAccountSigner`.  Check out [this guide](/references/permissionless/how-to/accounts/use-kernel-account) for a complete tutorial.
- [signerToLightSmartAccount](/references/permissionless/v0_1/reference/accounts/signerToLightSmartAccount): Creates a LightAccount instance controlled by a `SmartAccountSigner`.
- [signerToSafeSmartAccount](/references/permissionless/v0_1/reference/accounts/signerToSafeSmartAccount): Creates a Safe smart account instance controlled by a `SmartAccountSigner`.
- [signerToSimpleSmartAccount](/references/permissionless/v0_1/reference/accounts/signerToSimpleSmartAccount): Creates a SimpleAccount instance controlled by a `SmartAccountSigner`.
- [signerToTrustSmartAccount](/references/permissionless/v0_1/reference/accounts/signerToTrustSmartAccount): Creates a Trust Wallet Smart Account instance controlled by a `SmartAccountSigner`.  Check out [this guide](/references/permissionless/how-to/accounts/use-trustwallet-account) for a complete tutorial.
- [estimateUserOperationGas](/references/permissionless/v0_1/reference/bundler-actions/estimateUserOperationGas): Estimate the gas limits for a User Operation.
- [getUserOperationByHash](/references/permissionless/v0_1/reference/bundler-actions/getUserOperationByHash): Return a User Operation based on a User Operation hash.
- [getUserOperationReceipt](/references/permissionless/v0_1/reference/bundler-actions/getUserOperationReceipt): Return a User Operation receipt based on a User Operation hash.
- [sendUserOperation](/references/permissionless/v0_1/reference/bundler-actions/sendUserOperation): Submits a user operation to the bundler.
- [supportedEntryPoints](/references/permissionless/v0_1/reference/bundler-actions/supportedEntryPoints): Return the Entry Points supported by the bundler.
- [waitForUserOperationReceipt](/references/permissionless/v0_1/reference/bundler-actions/waitForUserOperationReceipt): Waits for the User Operation to be included on a block (one confirmation), and then returns the User Operation Receipt.
- [Bundler Client](/references/permissionless/v0_1/reference/clients/bundlerClient): A Bundler Client is an interface to official ERC-4337 JSON-RPC API methods that include sending user operations, estimation user operation gas limits, getting user operation receipts and more.
- [Pimlico Bundler Client](/references/permissionless/v0_1/reference/clients/pimlicoBundlerClient): A Pimlico Bundler Client is an interface to official ERC-4337 JSON-RPC API methods that include sending user operations, estimation user operation gas limits, getting user operation receipts and more as well as the Pimlico-specific bundler methods [pimlico\_getUserOperationStatus](/references/bundler/endpoints/pimlico_getUserOperationStatus) and [pimlico\_getUserOperationGasPrice](/references/bundler/endpoints/pimlico_getUserOperationGasPrice).
- [Pimlico Paymaster Client](/references/permissionless/v0_1/reference/clients/pimlicoPaymasterClient): The Pimlico paymaster actions in permissionless.js only work with the v2 Pimlico API. The v1 API for paymasters is deprecated and will be removed in the future.
- [Smart Account Client](/references/permissionless/v0_1/reference/clients/smartAccountClient): A Smart Account Client is an almost drop-in replacement for a standard viem [walletClient](https://viem.sh/docs/clients/wallet) but for managing smart accounts instead of EOA accounts. In addition, a Smart Account Client also contains, depending on the underlying smart account implementation used, a few extra actions that are specific to smart accounts.
- [accountId](/references/permissionless/v0_1/reference/erc7579-actions/accountId): Gets the accountId of the smart account as defined in [ERC-7579](https://eips.ethereum.org/EIPS/eip-7579). Check out [this guide](/references/permissionless/how-to/accounts/use-erc7579-account) for a complete tutorial.
- [installModule](/references/permissionless/v0_1/reference/erc7579-actions/installModule): Installs a [ERC-7579](https://eips.ethereum.org/EIPS/eip-7579) module to the smart account. Check out [this guide](/references/permissionless/how-to/accounts/use-erc7579-account) for a complete tutorial.
- [isModuleInstalled](/references/permissionless/v0_1/reference/erc7579-actions/isModuleInstalled): Checks if an [ERC-7579](https://eips.ethereum.org/EIPS/eip-7579) module is installed on the smart account. Check out [this guide](/references/permissionless/how-to/accounts/use-erc7579-account) for a complete tutorial.
- [supportsExecutionMode](/references/permissionless/v0_1/reference/erc7579-actions/supportsExecutionMode): Checks if a [ERC-7579](https://eips.ethereum.org/EIPS/eip-7579) execution mode is supported on the smart account. Check out [this guide](/references/permissionless/how-to/accounts/use-erc7579-account) for a complete tutorial.
- [supportsModule](/references/permissionless/v0_1/reference/erc7579-actions/supportsModule): Checks if a [ERC-7579](https://eips.ethereum.org/EIPS/eip-7579) module type is supported by the smart account. Check out [this guide](/references/permissionless/how-to/accounts/use-erc7579-account) for a complete tutorial.
- [uninstallModule](/references/permissionless/v0_1/reference/erc7579-actions/uninstallModule): Uninstalls a [ERC-7579](https://eips.ethereum.org/EIPS/eip-7579) module from the smart account. Check out [this guide](/references/permissionless/how-to/accounts/use-erc7579-account) for a complete tutorial.
- [Errors](/references/permissionless/v0_1/reference/glossary/errors): Glossary of Errors in permissionless.js.
- [getUserOperationGasPrice](/references/permissionless/v0_1/reference/pimlico-bundler-actions/getUserOperationGasPrice): Return a User Operation based on a User Operation hash.
- [getUserOperationStatus](/references/permissionless/v0_1/reference/pimlico-bundler-actions/getUserOperationStatus): Return a status of the User Operation as well as potentially the hash of the transaction being used to bundle the User Operation.
- [sponsorUserOperation](/references/permissionless/v0_1/reference/pimlico-paymaster-actions/sponsorUserOperation): The Pimlico paymaster actions in permissionless.js only work with the v2 Pimlico API. The v1 API for paymasters is deprecated and will be removed in the future.
- [validateSponsorshipPolicies](/references/permissionless/v0_1/reference/pimlico-paymaster-actions/validateSponsorshipPolicies): Validates a User Operation against an array of [sponsorship policies](https://dashboard.pimlico.io/sponsorship-policies), and returns an array of sponsorship policies (alongside additional data for each policy) that are willing to sponsor the user operation.
- [getAccountNonce](/references/permissionless/v0_1/reference/public-actions/getAccountNonce): Returns the current nonce of the smart account for a specified key.
- [getSenderAddress](/references/permissionless/v0_1/reference/public-actions/getSenderAddress): Return a sender address corresponding to the initCode of the User Operation where the smart account will be deployed.
- [deployContract](/references/permissionless/v0_1/reference/smart-account-actions/deployContract): deploys a contract to the network from a smart account, given bytecode & constructor arguments.
- [prepareUserOperationRequest](/references/permissionless/v0_1/reference/smart-account-actions/prepareUserOperationRequest): Prepares a user operation request for signing by populating a `sender`, `nonce`, `initCode`, gas price values, gas limit values, and optionally requesting sponsorship from a paymaster.
- [sendTransaction](/references/permissionless/v0_1/reference/smart-account-actions/sendTransaction): Send a transaction from a smart account using the same `sendTransaction` interface as viem.
- [sendTransactions](/references/permissionless/v0_1/reference/smart-account-actions/sendTransactions): Send a batch of transaction from a smart account.
- [sendUserOperation](/references/permissionless/v0_1/reference/smart-account-actions/sendUserOperation): Submits a user operation to the smart account client's underlying bundler.
- [signMessage](/references/permissionless/v0_1/reference/smart-account-actions/signMessage): Uses a smart account to sign and calculate an Ethereum-specific signature in [EIP-191 format](https://eips.ethereum.org/EIPS/eip-191): `keccak256("\x19Ethereum Signed Message:\n" + len(message) + message))`.
- [signTypedData](/references/permissionless/v0_1/reference/smart-account-actions/signTypedData): Signs typed data from a smart account and calculates an Ethereum-specific signature in [https://eips.ethereum.org/EIPS/eip-712](https://eips.ethereum.org/EIPS/eip-712): `sign(keccak256("\x19\x01" ‖ domainSeparator ‖ hashStruct(message)))`
- [writeContract](/references/permissionless/v0_1/reference/smart-account-actions/writeContract): Uses a smart account to executes a write function on a contract.
- [getRequiredPrefund](/references/permissionless/v0_1/reference/utils/getRequiredPrefund): Returns the minimum required funds in wei in the senders's smart account to execute the user operation.
- [getUserOperationHash](/references/permissionless/v0_1/reference/utils/getUserOperationHash): Generates the hash of the User Operation [as calculated by the EntryPoint](https://github.com/eth-infinitism/account-abstraction/blob/465f22310fcc639964e6ab5f8aa648770c6d8981/contracts/core/EntryPoint.sol#L296-L302).
- [providerToSmartAccountSigner](/references/permissionless/v0_1/reference/utils/providerToSmartAccountSigner): Takes an EIP-1193 provider and returns a signer that can be used as a signer with permissionless accounts.
- [signUserOperationHashWithECDSA](/references/permissionless/v0_1/reference/utils/signUserOperationHashWithECDSA): Signs the hash of the User Operation with the standard ECDSA signature scheme (used by all EOAs and most smart wallets).
- [walletClientToSmartAccountSigner](/references/permissionless/v0_1/reference/utils/walletClientToSmartAccountSigner): Takes a walletClient and returns a custom signer that can be used as a signer with permissionless accounts. This is especially useful when using `useWallet` from wagmi, allowing for an easy way to plug in custom frontend wagmi signers to permissionless accounts.
- [PermissionlessProvider](/references/permissionless/wagmi/reference/configuration/PermissionlessProvider): React Context Provider for Permissionless.
- [useSendTransaction](/references/permissionless/wagmi/reference/hooks/useSendTransaction): Hook for creating, signing, and sending transactions to networks.
- [useWaitForTransactionReceipt](/references/permissionless/wagmi/reference/hooks/useWaitForTransactionReceipt): Hook that waits for the transaction to be included on a block, and then returns the transaction receipt. If the transaction reverts, then the action will throw an error. Replacement detection (e.g. sped up transactions) is also supported.