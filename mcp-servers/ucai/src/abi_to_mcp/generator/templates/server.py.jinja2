"""
MCP Server for {{ server_name }}

Contract: {{ contract_address }}
Network: {{ network }}

Generated by UCAI (https://github.com/nirholas/UCAI)
"""

from mcp.server.fastmcp import FastMCP
from web3 import Web3
from typing import Optional, Dict, Any, List
import os
import json
from dotenv import load_dotenv

load_dotenv()

# =============================================================================
# Server Initialization
# =============================================================================

mcp = FastMCP("{{ server_name }}")

# =============================================================================
# Configuration
# =============================================================================

RPC_URL = os.environ.get("RPC_URL", "{{ default_rpc }}")
CONTRACT_ADDRESS = os.environ.get("CONTRACT_ADDRESS", "{{ contract_address }}")
PRIVATE_KEY = os.environ.get("PRIVATE_KEY")  # Optional, for write operations

# Safety settings
SIMULATION_DEFAULT = {{ simulation_default | default(true, true) }}
READ_ONLY_MODE = {{ read_only | default(false, true) }}

# =============================================================================
# Web3 Setup
# =============================================================================

w3 = Web3(Web3.HTTPProvider(RPC_URL))

# Contract ABI
ABI = json.loads('''
{{ abi_json }}
''')

# Initialize contract
contract = w3.eth.contract(
    address=Web3.to_checksum_address(CONTRACT_ADDRESS),
    abi=ABI
)


# =============================================================================
# Utility Functions
# =============================================================================

{% if include_utilities %}
def _get_signer():
    """Get signer account from private key."""
    if not PRIVATE_KEY:
        raise ValueError(
            "PRIVATE_KEY environment variable not set. "
            "Required for write operations."
        )
    return w3.eth.account.from_key(PRIVATE_KEY)


def _estimate_gas(tx: Dict) -> int:
    """Estimate gas for a transaction with buffer."""
    try:
        estimate = w3.eth.estimate_gas(tx)
        return int(estimate * 1.2)  # 20% buffer
    except Exception:
        return 200000  # Default fallback


def _format_value(value: Any, decimals: int = 18) -> str:
    """Format a wei value to human-readable."""
    if isinstance(value, int) and value > 10**12:
        return f"{value / (10 ** decimals):.6f}"
    return str(value)
{% endif %}


# =============================================================================
# READ FUNCTIONS (No gas required)
# =============================================================================

{% for tool in tools if tool.tool_type == 'read' %}
@mcp.tool()
def {{ tool.name }}(
    {%- for param in tool.parameters %}
    {{ param.name }}: {{ param.python_type }}{{ ", " if not loop.last else "" }}
    {%- endfor %}
) -> {{ tool.return_schema.get('python_type', 'Any') if tool.return_schema else 'Any' }}:
    """
    {{ tool.description }}
    {% if tool.parameters %}
    
    Args:
    {%- for param in tool.parameters %}
        {{ param.name }}: {{ param.description }}
    {%- endfor %}
    {% endif %}
    
    Returns:
        {{ tool.return_description }}
    """
    {% if tool.parameters %}
    result = contract.functions.{{ tool.original_name }}(
        {%- for param in tool.parameters %}
        {{ param.name }}{{ ", " if not loop.last else "" }}
        {%- endfor %}
    ).call()
    {% else %}
    result = contract.functions.{{ tool.original_name }}().call()
    {% endif %}
    return result


{% endfor %}

# =============================================================================
# WRITE FUNCTIONS (Require gas, simulation by default)
# =============================================================================

{% if not read_only %}
{% for tool in tools if tool.tool_type in ['write', 'write_payable'] %}
@mcp.tool()
def {{ tool.name }}(
    {%- for param in tool.parameters %}
    {{ param.name }}: {{ param.python_type }},
    {%- endfor %}
    {% if tool.tool_type == 'write_payable' %}
    value_wei: str = "0",
    {% endif %}
    simulate: bool = SIMULATION_DEFAULT
) -> Dict[str, Any]:
    """
    {{ tool.description }}
    
    ⚠️ This is a WRITE operation that modifies blockchain state and requires gas.
    {% if simulation_default %}
    By default, this will only SIMULATE the transaction. Set simulate=False to execute.
    {% endif %}
    {% if tool.parameters %}
    
    Args:
    {%- for param in tool.parameters %}
        {{ param.name }}: {{ param.description }}
    {%- endfor %}
    {% endif %}
        {% if tool.tool_type == 'write_payable' %}
        value_wei: Amount of {{ currency | default('ETH') }} to send (in wei)
        {% endif %}
        simulate: If True, only simulate the transaction without executing
    
    Returns:
        Transaction result with hash, status, gas used, or simulation result
    """
    if READ_ONLY_MODE:
        return {"error": "Server is in read-only mode. Write operations disabled."}
    
    signer = _get_signer()
    
    # Build transaction
    tx_params = {
        "from": signer.address,
        "nonce": w3.eth.get_transaction_count(signer.address),
        "gas": 0,
        "gasPrice": w3.eth.gas_price,
        {% if tool.tool_type == 'write_payable' %}
        "value": int(value_wei),
        {% endif %}
    }
    
    func = contract.functions.{{ tool.original_name }}(
        {%- for param in tool.parameters %}
        {{ param.name }}{{ ", " if not loop.last else "" }}
        {%- endfor %}
    )
    
    tx = func.build_transaction(tx_params)
    tx["gas"] = _estimate_gas(tx)
    
    if simulate:
        # Simulation only - does not execute
        try:
            result = func.call({
                "from": signer.address
                {%- if tool.tool_type == 'write_payable' %},
                "value": int(value_wei)
                {%- endif %}
            })
            return {
                "simulated": True,
                "success": True,
                "result": result,
                "estimated_gas": tx["gas"],
                "gas_price_gwei": float(w3.from_wei(tx["gasPrice"], "gwei")),
                "estimated_cost_eth": float(w3.from_wei(tx["gas"] * tx["gasPrice"], "ether")),
                "note": "This was a simulation. Set simulate=False to execute for real."
            }
        except Exception as e:
            return {
                "simulated": True,
                "success": False,
                "error": str(e),
                "note": "Simulation failed. The transaction would likely revert."
            }
    
    # Execute transaction for real
    signed = w3.eth.account.sign_transaction(tx, PRIVATE_KEY)
    tx_hash = w3.eth.send_raw_transaction(signed.rawTransaction)
    receipt = w3.eth.wait_for_transaction_receipt(tx_hash, timeout=120)
    
    return {
        "simulated": False,
        "success": receipt.status == 1,
        "tx_hash": receipt.transactionHash.hex(),
        "block_number": receipt.blockNumber,
        "gas_used": receipt.gasUsed,
        "effective_gas_price": receipt.effectiveGasPrice,
        "cost_eth": float(w3.from_wei(receipt.gasUsed * receipt.effectiveGasPrice, "ether")),
    }


{% endfor %}
{% endif %}

# =============================================================================
# EVENT QUERY TOOLS
# =============================================================================

{% for resource in resources %}
@mcp.tool()
async def {{ resource.function_name }}(
    from_block: int = None,
    to_block: int = None
) -> List[Dict[str, Any]]:
    """
    {{ resource.description }}
    
    Args:
        from_block: Starting block (default: latest - 1000)
        to_block: Ending block (default: latest)
    
    Returns:
        List of {{ resource.original_name }} events with transaction details
    """
    if from_block is None:
        from_block = max(0, w3.eth.block_number - 1000)
    if to_block is None:
        to_block = "latest"
    
    events = contract.events.{{ resource.original_name }}.get_logs(
        fromBlock=from_block,
        toBlock=to_block
    )
    
    return [
        {
            {%- for field in resource.fields %}
            "{{ field.name }}": event.args.get("{{ field.original_name }}"),
            {%- endfor %}
            "block_number": event.blockNumber,
            "transaction_hash": event.transactionHash.hex(),
            "log_index": event.logIndex,
        }
        for event in events
    ]


{% endfor %}

# =============================================================================
# UTILITY TOOLS
# =============================================================================

{% if include_utilities %}
@mcp.tool()
def get_contract_info() -> Dict[str, Any]:
    """
    Get information about this contract and connection status.
    
    Returns:
        Contract address, network status, and detected token info if available
    """
    info = {
        "address": CONTRACT_ADDRESS,
        "network": "{{ network }}",
        "chain_id": w3.eth.chain_id,
        "connected": w3.is_connected(),
        "latest_block": w3.eth.block_number,
    }
    
    # Try to get token info (works for ERC20/721)
    try:
        info["name"] = contract.functions.name().call()
    except Exception:
        pass
    
    try:
        info["symbol"] = contract.functions.symbol().call()
    except Exception:
        pass
    
    try:
        info["decimals"] = contract.functions.decimals().call()
    except Exception:
        pass
    
    try:
        info["total_supply"] = str(contract.functions.totalSupply().call())
    except Exception:
        pass
    
    return info


@mcp.tool()
def format_units(amount: str, decimals: int = 18) -> str:
    """
    Format a raw token amount to human-readable format.
    
    Args:
        amount: Raw amount as string (e.g., "1000000000000000000" for 1 token)
        decimals: Token decimals (default: 18, use decimals() to check)
    
    Returns:
        Formatted amount (e.g., "1.0")
    """
    return str(int(amount) / (10 ** decimals))


@mcp.tool()
def parse_units(amount: str, decimals: int = 18) -> str:
    """
    Parse a human-readable amount to raw token units.
    
    Args:
        amount: Human-readable amount (e.g., "1.5")
        decimals: Token decimals (default: 18)
    
    Returns:
        Raw amount as string (e.g., "1500000000000000000")
    """
    return str(int(float(amount) * (10 ** decimals)))


@mcp.tool()
def get_balance(address: str) -> Dict[str, Any]:
    """
    Get the native currency balance of an address.
    
    Args:
        address: Ethereum address to check
    
    Returns:
        Balance in wei and formatted in ETH
    """
    balance_wei = w3.eth.get_balance(Web3.to_checksum_address(address))
    return {
        "address": address,
        "balance_wei": str(balance_wei),
        "balance_eth": float(w3.from_wei(balance_wei, "ether")),
    }
{% endif %}


# =============================================================================
# Server Entry Point
# =============================================================================

if __name__ == "__main__":
    mcp.run()
