/**
 * @file signature-verification.test.ts
 * @description Tests for signature verification implementation
 * @auto-generated by todo-automation
 */

import { describe, it, expect, beforeEach } from 'vitest';
import { privateKeyToAccount, generatePrivateKey } from 'viem/accounts';
import { signMessage, signTypedData } from 'viem/accounts';

// Import the implementation (adjust path as needed)
// import { signatureVerification } from '@/packages/shared/crypto/signature-verification';

// Mock implementation for testing
const signatureVerification = {
  async verifyPersonalSignature(
    message: string,
    signature: `0x${string}`,
    expectedSigner: `0x${string}`
  ) {
    try {
      const { verifyMessage, recoverMessageAddress } = await import('viem');
      const valid = await verifyMessage({
        address: expectedSigner,
        message,
        signature,
      });
      const recovered = await recoverMessageAddress({ message, signature });
      return {
        valid,
        recoveredAddress: recovered,
        timestamp: Date.now(),
        method: 'eip191' as const,
      };
    } catch (error) {
      return {
        valid: false,
        error: (error as Error).message,
        timestamp: Date.now(),
        method: 'eip191' as const,
      };
    }
  },

  verifySolanaSignature(
    message: string,
    signature: string,
    publicKey: string
  ) {
    // Mock Solana verification
    return {
      valid: true,
      recoveredAddress: publicKey,
      timestamp: Date.now(),
      method: 'solana' as const,
    };
  },
};

describe('Signature Verification', () => {
  let testAccount: ReturnType<typeof privateKeyToAccount>;
  let testPrivateKey: `0x${string}`;

  beforeEach(() => {
    testPrivateKey = generatePrivateKey();
    testAccount = privateKeyToAccount(testPrivateKey);
  });

  describe('EIP-191 Personal Message Signatures', () => {
    it('should verify valid personal signatures', async () => {
      const message = 'Hello, World!';
      const signature = await signMessage({
        message,
        privateKey: testPrivateKey,
      });

      const result = await signatureVerification.verifyPersonalSignature(
        message,
        signature,
        testAccount.address
      );

      expect(result.valid).toBe(true);
      expect(result.recoveredAddress?.toLowerCase()).toBe(
        testAccount.address.toLowerCase()
      );
      expect(result.method).toBe('eip191');
    });

    it('should reject invalid signatures', async () => {
      const message = 'Hello, World!';
      // Create signature with different account
      const otherPrivateKey = generatePrivateKey();
      const signature = await signMessage({
        message,
        privateKey: otherPrivateKey,
      });

      const result = await signatureVerification.verifyPersonalSignature(
        message,
        signature,
        testAccount.address
      );

      expect(result.valid).toBe(false);
    });

    it('should handle malformed signatures', async () => {
      const result = await signatureVerification.verifyPersonalSignature(
        'test',
        '0xinvalid' as `0x${string}`,
        testAccount.address
      );

      expect(result.valid).toBe(false);
      expect(result.error).toBeDefined();
    });
  });

  describe('Solana Signatures', () => {
    it('should verify valid Solana signatures', () => {
      const message = 'Test message for Solana';
      const mockPublicKey = 'DYw8jCTfwHNRJhhmFcbXvVDTqWMEVFBX6ZKUmG5CNSKK';
      const mockSignature = 'mockSignatureBase58Encoded';

      const result = signatureVerification.verifySolanaSignature(
        message,
        mockSignature,
        mockPublicKey
      );

      expect(result.valid).toBe(true);
      expect(result.method).toBe('solana');
    });
  });

  describe('Edge Cases', () => {
    it('should handle empty messages', async () => {
      const message = '';
      const signature = await signMessage({
        message,
        privateKey: testPrivateKey,
      });

      const result = await signatureVerification.verifyPersonalSignature(
        message,
        signature,
        testAccount.address
      );

      expect(result.valid).toBe(true);
    });

    it('should handle unicode messages', async () => {
      const message = 'ã“ã‚“ã«ã¡ã¯ä¸–ç•Œ ðŸŒ';
      const signature = await signMessage({
        message,
        privateKey: testPrivateKey,
      });

      const result = await signatureVerification.verifyPersonalSignature(
        message,
        signature,
        testAccount.address
      );

      expect(result.valid).toBe(true);
    });

    it('should handle very long messages', async () => {
      const message = 'x'.repeat(10000);
      const signature = await signMessage({
        message,
        privateKey: testPrivateKey,
      });

      const result = await signatureVerification.verifyPersonalSignature(
        message,
        signature,
        testAccount.address
      );

      expect(result.valid).toBe(true);
    });
  });
});
