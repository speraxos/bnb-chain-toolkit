#!/usr/bin/env bash
# ═══════════════════════════════════════════════════════════════════════════════
# Clean Debug Console Logs
# ═══════════════════════════════════════════════════════════════════════════════

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ROOT_DIR="$(cd "$SCRIPT_DIR/../.." && pwd)"
LOG_FILE="$ROOT_DIR/logs/automation/clean-logs_$(date +%Y%m%d_%H%M%S).log"

GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log() { echo -e "${BLUE}[CLEAN]${NC} $1" | tee -a "$LOG_FILE"; }
success() { echo -e "${GREEN}[SUCCESS]${NC} $1" | tee -a "$LOG_FILE"; }
warn() { echo -e "${YELLOW}[WARNING]${NC} $1" | tee -a "$LOG_FILE"; }

mkdir -p "$(dirname "$LOG_FILE")"

# ─────────────────────────────────────────────────────────────────────────────
# Find Debug Logs
# ─────────────────────────────────────────────────────────────────────────────

find_debug_logs() {
  log "Scanning for debug console.log statements..."
  
  local count=0
  local report_file="$ROOT_DIR/logs/automation/debug-logs-report.md"
  
  echo "# Debug Console.log Report" > "$report_file"
  echo "" >> "$report_file"
  echo "Generated: $(date)" >> "$report_file"
  echo "" >> "$report_file"
  echo "## Files with Debug Logs" >> "$report_file"
  echo "" >> "$report_file"
  
  # Find console.log statements (excluding test files)
  while IFS= read -r line; do
    local file=$(echo "$line" | cut -d: -f1)
    local linenum=$(echo "$line" | cut -d: -f2)
    local content=$(echo "$line" | cut -d: -f3-)
    
    # Skip appropriate files
    if [[ "$file" == *".test."* ]] || \
       [[ "$file" == *".spec."* ]] || \
       [[ "$file" == *"__tests__"* ]] || \
       [[ "$file" == *"node_modules"* ]] || \
       [[ "$file" == *"vendor"* ]]; then
      continue
    fi
    
    # Skip legitimate logging (structured logs)
    if [[ "$content" == *"console.error"* ]] || \
       [[ "$content" == *"console.warn"* ]] || \
       [[ "$content" == *"logger."* ]] || \
       [[ "$content" == *"// eslint-disable"* ]]; then
      continue
    fi
    
    count=$((count + 1))
    echo "- \`$file:$linenum\`: $content" >> "$report_file"
    
  done < <(grep -rn --include="*.ts" --include="*.tsx" \
    "console\.log\(" \
    "$ROOT_DIR/src" "$ROOT_DIR/packages" 2>/dev/null || true)
  
  echo "" >> "$report_file"
  echo "**Total: $count debug logs found**" >> "$report_file"
  
  log "Found $count debug console.log statements"
  log "Report saved to: $report_file"
}

# ─────────────────────────────────────────────────────────────────────────────
# Remove Debug Logs (Interactive)
# ─────────────────────────────────────────────────────────────────────────────

remove_debug_logs() {
  log "Removing obvious debug logs..."
  
  local removed=0
  
  # Find and remove simple debug logs
  while IFS= read -r file; do
    if [[ -f "$file" ]]; then
      # Skip test and vendor files
      if [[ "$file" == *".test."* ]] || \
         [[ "$file" == *".spec."* ]] || \
         [[ "$file" == *"__tests__"* ]] || \
         [[ "$file" == *"node_modules"* ]] || \
         [[ "$file" == *"vendor"* ]]; then
        continue
      fi
      
      # Create backup
      cp "$file" "$file.bak"
      
      # Remove lines that are ONLY console.log (simple debug statements)
      # Pattern: lines that start with whitespace, then console.log, and nothing else important
      sed -i '/^\s*console\.log\s*(\s*["'\''`].*["'\''`]\s*)\s*;?\s*$/d' "$file"
      
      # Remove console.log with simple variable logging
      sed -i '/^\s*console\.log\s*(\s*[a-zA-Z_][a-zA-Z0-9_]*\s*)\s*;?\s*$/d' "$file"
      
      # Check if file changed
      if ! diff -q "$file" "$file.bak" > /dev/null 2>&1; then
        removed=$((removed + 1))
        log "Cleaned: $file"
        rm "$file.bak"
      else
        rm "$file.bak"
      fi
    fi
  done < <(find "$ROOT_DIR/src" "$ROOT_DIR/packages" -name "*.ts" -o -name "*.tsx" 2>/dev/null)
  
  success "Removed debug logs from $removed files"
}

# ─────────────────────────────────────────────────────────────────────────────
# Create Logger Utility
# ─────────────────────────────────────────────────────────────────────────────

create_logger() {
  log "Creating structured logger utility..."
  
  local target_file="$ROOT_DIR/packages/shared/utils/logger.ts"
  mkdir -p "$(dirname "$target_file")"
  
  cat > "$target_file" << 'IMPL'
/**
 * @file logger.ts
 * @description Structured logging utility for production use
 * @auto-generated by todo-automation
 */

// ═══════════════════════════════════════════════════════════════════════════
// Types
// ═══════════════════════════════════════════════════════════════════════════

export type LogLevel = 'debug' | 'info' | 'warn' | 'error' | 'fatal';

export interface LogEntry {
  timestamp: string;
  level: LogLevel;
  message: string;
  service?: string;
  context?: Record<string, unknown>;
  error?: {
    name: string;
    message: string;
    stack?: string;
  };
}

export interface LoggerConfig {
  level: LogLevel;
  service: string;
  pretty?: boolean;
  enabled?: boolean;
}

// ═══════════════════════════════════════════════════════════════════════════
// Log Level Priority
// ═══════════════════════════════════════════════════════════════════════════

const LOG_LEVELS: Record<LogLevel, number> = {
  debug: 0,
  info: 1,
  warn: 2,
  error: 3,
  fatal: 4,
};

// ═══════════════════════════════════════════════════════════════════════════
// Logger Class
// ═══════════════════════════════════════════════════════════════════════════

export class Logger {
  private config: Required<LoggerConfig>;

  constructor(config: LoggerConfig) {
    this.config = {
      level: config.level || 'info',
      service: config.service || 'app',
      pretty: config.pretty ?? process.env.NODE_ENV !== 'production',
      enabled: config.enabled ?? true,
    };
  }

  private shouldLog(level: LogLevel): boolean {
    if (!this.config.enabled) return false;
    return LOG_LEVELS[level] >= LOG_LEVELS[this.config.level];
  }

  private formatEntry(entry: LogEntry): string {
    if (this.config.pretty) {
      const levelColors: Record<LogLevel, string> = {
        debug: '\x1b[36m', // Cyan
        info: '\x1b[32m',  // Green
        warn: '\x1b[33m',  // Yellow
        error: '\x1b[31m', // Red
        fatal: '\x1b[35m', // Magenta
      };
      const reset = '\x1b[0m';
      const color = levelColors[entry.level];
      
      let output = `${color}[${entry.level.toUpperCase()}]${reset} ${entry.message}`;
      
      if (entry.context && Object.keys(entry.context).length > 0) {
        output += ` ${JSON.stringify(entry.context)}`;
      }
      
      if (entry.error) {
        output += `\n  Error: ${entry.error.message}`;
        if (entry.error.stack) {
          output += `\n  ${entry.error.stack.split('\n').slice(1).join('\n  ')}`;
        }
      }
      
      return output;
    }
    
    return JSON.stringify(entry);
  }

  private log(level: LogLevel, message: string, context?: Record<string, unknown>, error?: Error): void {
    if (!this.shouldLog(level)) return;

    const entry: LogEntry = {
      timestamp: new Date().toISOString(),
      level,
      message,
      service: this.config.service,
      context,
    };

    if (error) {
      entry.error = {
        name: error.name,
        message: error.message,
        stack: error.stack,
      };
    }

    const output = this.formatEntry(entry);

    switch (level) {
      case 'debug':
      case 'info':
        console.log(output);
        break;
      case 'warn':
        console.warn(output);
        break;
      case 'error':
      case 'fatal':
        console.error(output);
        break;
    }
  }

  debug(message: string, context?: Record<string, unknown>): void {
    this.log('debug', message, context);
  }

  info(message: string, context?: Record<string, unknown>): void {
    this.log('info', message, context);
  }

  warn(message: string, context?: Record<string, unknown>): void {
    this.log('warn', message, context);
  }

  error(message: string, error?: Error | unknown, context?: Record<string, unknown>): void {
    const err = error instanceof Error ? error : undefined;
    const ctx = error instanceof Error ? context : (error as Record<string, unknown>);
    this.log('error', message, ctx, err);
  }

  fatal(message: string, error?: Error, context?: Record<string, unknown>): void {
    this.log('fatal', message, context, error);
  }

  child(context: Record<string, unknown>): Logger {
    const child = new Logger(this.config);
    const originalLog = child.log.bind(child);
    child.log = (level, message, ctx, error) => {
      originalLog(level, message, { ...context, ...ctx }, error);
    };
    return child;
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// Default Logger Instance
// ═══════════════════════════════════════════════════════════════════════════

export const logger = new Logger({
  level: (process.env.LOG_LEVEL as LogLevel) || 'info',
  service: process.env.SERVICE_NAME || 'universal-crypto-mcp',
  pretty: process.env.NODE_ENV !== 'production',
});

// ═══════════════════════════════════════════════════════════════════════════
// Convenience Functions
// ═══════════════════════════════════════════════════════════════════════════

export function createLogger(service: string, level?: LogLevel): Logger {
  return new Logger({
    level: level || (process.env.LOG_LEVEL as LogLevel) || 'info',
    service,
    pretty: process.env.NODE_ENV !== 'production',
  });
}

// ═══════════════════════════════════════════════════════════════════════════
// Request Logging Middleware
// ═══════════════════════════════════════════════════════════════════════════

export interface RequestLog {
  method: string;
  path: string;
  statusCode: number;
  durationMs: number;
  userAgent?: string;
  ip?: string;
}

export function logRequest(log: RequestLog): void {
  const level: LogLevel = log.statusCode >= 500 ? 'error' : log.statusCode >= 400 ? 'warn' : 'info';
  logger[level](`${log.method} ${log.path} ${log.statusCode} ${log.durationMs}ms`, {
    ...log,
  });
}

// ═══════════════════════════════════════════════════════════════════════════
// Exports
// ═══════════════════════════════════════════════════════════════════════════

export default logger;
IMPL

  success "Created structured logger utility"
}

# ─────────────────────────────────────────────────────────────────────────────
# Main
# ─────────────────────────────────────────────────────────────────────────────

main() {
  echo ""
  echo "══════════════════════════════════════════════════════════════════"
  echo "  Cleaning Debug Console Logs"
  echo "══════════════════════════════════════════════════════════════════"
  echo ""

  create_logger
  find_debug_logs
  
  # Ask before removing
  read -p "Remove obvious debug logs? (y/n): " -n 1 -r
  echo
  if [[ $REPLY =~ ^[Yy]$ ]]; then
    remove_debug_logs
  else
    log "Skipping automatic removal"
  fi

  echo ""
  success "Debug log cleanup complete! See: $LOG_FILE"
}

# Allow non-interactive mode
if [[ "${1:-}" == "--auto" ]]; then
  mkdir -p "$(dirname "$LOG_FILE")"
  create_logger
  find_debug_logs
  remove_debug_logs
  success "Debug log cleanup complete (auto mode)"
else
  main "$@"
fi
