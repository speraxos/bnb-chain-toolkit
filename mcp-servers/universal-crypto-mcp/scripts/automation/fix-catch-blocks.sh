#!/usr/bin/env bash
# ═══════════════════════════════════════════════════════════════════════════════
# Fix Empty Catch Blocks
# ═══════════════════════════════════════════════════════════════════════════════

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ROOT_DIR="$(cd "$SCRIPT_DIR/../.." && pwd)"
LOG_FILE="$ROOT_DIR/logs/automation/fix-catch-blocks_$(date +%Y%m%d_%H%M%S).log"

GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log() { echo -e "${BLUE}[CATCH-FIX]${NC} $1" | tee -a "$LOG_FILE"; }
success() { echo -e "${GREEN}[SUCCESS]${NC} $1" | tee -a "$LOG_FILE"; }
warn() { echo -e "${YELLOW}[WARNING]${NC} $1" | tee -a "$LOG_FILE"; }

mkdir -p "$(dirname "$LOG_FILE")"

# ─────────────────────────────────────────────────────────────────────────────
# Find and Fix Empty Catch Blocks
# ─────────────────────────────────────────────────────────────────────────────

fix_empty_catches() {
  log "Scanning for empty catch blocks..."
  
  local count=0
  local fixed=0
  
  # Find files with empty catch blocks
  while IFS= read -r file; do
    if [[ -f "$file" ]]; then
      # Check if file contains empty catch
      if grep -qE 'catch\s*\([^)]*\)\s*\{\s*\}' "$file" 2>/dev/null; then
        count=$((count + 1))
        log "Found empty catch in: $file"
        
        # Create backup
        cp "$file" "$file.bak"
        
        # Replace empty catch blocks with proper error handling
        # Pattern 1: catch (error) { }
        sed -i -E 's/catch\s*\(\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*\)\s*\{\s*\}/catch (\1) {\n    console.error("[\1]", \1 instanceof Error ? \1.message : String(\1));\n  }/g' "$file"
        
        # Pattern 2: catch { } (no error variable)
        sed -i -E 's/catch\s*\{\s*\}/catch (error) {\n    console.error("[Caught error]", error instanceof Error ? error.message : String(error));\n  }/g' "$file"
        
        # Pattern 3: catch (e) { } (short variable)
        sed -i -E 's/catch\s*\(\s*e\s*\)\s*\{\s*\}/catch (e) {\n    console.error("[Error]", e instanceof Error ? e.message : String(e));\n  }/g' "$file"
        
        # Verify fix was applied
        if ! grep -qE 'catch\s*\([^)]*\)\s*\{\s*\}' "$file" 2>/dev/null; then
          fixed=$((fixed + 1))
          rm -f "$file.bak"
        else
          # Restore backup if fix didn't work
          mv "$file.bak" "$file"
          warn "Could not automatically fix: $file"
        fi
      fi
    fi
  done < <(find "$ROOT_DIR/src" "$ROOT_DIR/packages" -name "*.ts" -o -name "*.tsx" 2>/dev/null | grep -v node_modules | grep -v ".d.ts")
  
  success "Scanned $count files with empty catches, fixed $fixed"
}

# ─────────────────────────────────────────────────────────────────────────────
# Fix Ignored Errors in Catch Blocks
# ─────────────────────────────────────────────────────────────────────────────

fix_ignored_errors() {
  log "Fixing ignored error parameters..."
  
  local count=0
  
  # Find catch blocks with unused error parameter
  while IFS= read -r file; do
    if [[ -f "$file" ]]; then
      # Pattern: catch (_error) or catch (_e) or catch (_)
      if grep -qE 'catch\s*\(\s*_[a-zA-Z]*\s*\)' "$file" 2>/dev/null; then
        # These are intentionally ignored - add comment if missing
        if ! grep -qE 'catch\s*\(\s*_[a-zA-Z]*\s*\)\s*\{[^}]*//.*ignore' "$file" 2>/dev/null; then
          count=$((count + 1))
          log "Found ignored error in: $file"
        fi
      fi
    fi
  done < <(find "$ROOT_DIR/src" "$ROOT_DIR/packages" -name "*.ts" -o -name "*.tsx" 2>/dev/null | grep -v node_modules)
  
  log "Found $count files with intentionally ignored errors"
}

# ─────────────────────────────────────────────────────────────────────────────
# Add Error Boundary Helper
# ─────────────────────────────────────────────────────────────────────────────

create_error_utils() {
  log "Creating error handling utilities..."
  
  local target_file="$ROOT_DIR/packages/shared/utils/error-handling.ts"
  mkdir -p "$(dirname "$target_file")"
  
  cat > "$target_file" << 'IMPL'
/**
 * @file error-handling.ts
 * @description Centralized error handling utilities
 * @auto-generated by todo-automation
 */

// ═══════════════════════════════════════════════════════════════════════════
// Error Types
// ═══════════════════════════════════════════════════════════════════════════

export class AppError extends Error {
  public readonly code: string;
  public readonly statusCode: number;
  public readonly isOperational: boolean;
  public readonly context?: Record<string, unknown>;

  constructor(
    message: string,
    options?: {
      code?: string;
      statusCode?: number;
      isOperational?: boolean;
      context?: Record<string, unknown>;
      cause?: Error;
    }
  ) {
    super(message, { cause: options?.cause });
    this.name = 'AppError';
    this.code = options?.code || 'UNKNOWN_ERROR';
    this.statusCode = options?.statusCode || 500;
    this.isOperational = options?.isOperational ?? true;
    this.context = options?.context;
    Error.captureStackTrace(this, this.constructor);
  }
}

export class ValidationError extends AppError {
  constructor(message: string, context?: Record<string, unknown>) {
    super(message, {
      code: 'VALIDATION_ERROR',
      statusCode: 400,
      isOperational: true,
      context,
    });
    this.name = 'ValidationError';
  }
}

export class NotFoundError extends AppError {
  constructor(resource: string, identifier?: string) {
    super(`${resource} not found${identifier ? `: ${identifier}` : ''}`, {
      code: 'NOT_FOUND',
      statusCode: 404,
      isOperational: true,
      context: { resource, identifier },
    });
    this.name = 'NotFoundError';
  }
}

export class AuthenticationError extends AppError {
  constructor(message: string = 'Authentication required') {
    super(message, {
      code: 'UNAUTHENTICATED',
      statusCode: 401,
      isOperational: true,
    });
    this.name = 'AuthenticationError';
  }
}

export class AuthorizationError extends AppError {
  constructor(message: string = 'Permission denied') {
    super(message, {
      code: 'UNAUTHORIZED',
      statusCode: 403,
      isOperational: true,
    });
    this.name = 'AuthorizationError';
  }
}

export class RateLimitError extends AppError {
  constructor(retryAfter?: number) {
    super('Rate limit exceeded', {
      code: 'RATE_LIMITED',
      statusCode: 429,
      isOperational: true,
      context: { retryAfter },
    });
    this.name = 'RateLimitError';
  }
}

export class ChainError extends AppError {
  constructor(message: string, chainId: number, cause?: Error) {
    super(message, {
      code: 'CHAIN_ERROR',
      statusCode: 502,
      isOperational: true,
      context: { chainId },
      cause,
    });
    this.name = 'ChainError';
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// Error Handling Utilities
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Safely extract error message from unknown error
 */
export function getErrorMessage(error: unknown): string {
  if (error instanceof Error) {
    return error.message;
  }
  if (typeof error === 'string') {
    return error;
  }
  if (error && typeof error === 'object' && 'message' in error) {
    return String((error as { message: unknown }).message);
  }
  return 'An unknown error occurred';
}

/**
 * Safely extract error code from unknown error
 */
export function getErrorCode(error: unknown): string {
  if (error instanceof AppError) {
    return error.code;
  }
  if (error && typeof error === 'object' && 'code' in error) {
    return String((error as { code: unknown }).code);
  }
  return 'UNKNOWN_ERROR';
}

/**
 * Wrap async function with error handling
 */
export function catchAsync<T extends (...args: unknown[]) => Promise<unknown>>(
  fn: T,
  errorHandler?: (error: unknown) => void
): T {
  return (async (...args: Parameters<T>) => {
    try {
      return await fn(...args);
    } catch (error) {
      if (errorHandler) {
        errorHandler(error);
      } else {
        console.error('[catchAsync]', getErrorMessage(error));
      }
      throw error;
    }
  }) as T;
}

/**
 * Try-catch wrapper that returns Result type
 */
export type Result<T, E = Error> =
  | { success: true; data: T }
  | { success: false; error: E };

export async function tryCatch<T>(
  fn: () => Promise<T>
): Promise<Result<T, Error>> {
  try {
    const data = await fn();
    return { success: true, data };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error : new Error(getErrorMessage(error)),
    };
  }
}

/**
 * Retry a function with exponential backoff
 */
export async function retry<T>(
  fn: () => Promise<T>,
  options?: {
    maxAttempts?: number;
    initialDelayMs?: number;
    maxDelayMs?: number;
    backoffMultiplier?: number;
    shouldRetry?: (error: unknown) => boolean;
  }
): Promise<T> {
  const {
    maxAttempts = 3,
    initialDelayMs = 1000,
    maxDelayMs = 30000,
    backoffMultiplier = 2,
    shouldRetry = () => true,
  } = options || {};

  let lastError: unknown;
  let delay = initialDelayMs;

  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error;

      if (attempt === maxAttempts || !shouldRetry(error)) {
        break;
      }

      console.warn(
        `[retry] Attempt ${attempt}/${maxAttempts} failed: ${getErrorMessage(error)}. ` +
          `Retrying in ${delay}ms...`
      );

      await new Promise((resolve) => setTimeout(resolve, delay));
      delay = Math.min(delay * backoffMultiplier, maxDelayMs);
    }
  }

  throw lastError;
}

// ═══════════════════════════════════════════════════════════════════════════
// Logging
// ═══════════════════════════════════════════════════════════════════════════

export interface ErrorLog {
  timestamp: string;
  level: 'error' | 'warn' | 'info';
  message: string;
  code?: string;
  stack?: string;
  context?: Record<string, unknown>;
}

/**
 * Create structured error log
 */
export function createErrorLog(error: unknown, context?: Record<string, unknown>): ErrorLog {
  const message = getErrorMessage(error);
  const code = getErrorCode(error);
  const stack = error instanceof Error ? error.stack : undefined;

  return {
    timestamp: new Date().toISOString(),
    level: 'error',
    message,
    code,
    stack,
    context: {
      ...context,
      ...(error instanceof AppError ? error.context : {}),
    },
  };
}

/**
 * Log error with structured format
 */
export function logError(error: unknown, context?: Record<string, unknown>): void {
  const log = createErrorLog(error, context);
  console.error(JSON.stringify(log, null, 2));
}

// ═══════════════════════════════════════════════════════════════════════════
// Exports
// ═══════════════════════════════════════════════════════════════════════════

export default {
  AppError,
  ValidationError,
  NotFoundError,
  AuthenticationError,
  AuthorizationError,
  RateLimitError,
  ChainError,
  getErrorMessage,
  getErrorCode,
  catchAsync,
  tryCatch,
  retry,
  createErrorLog,
  logError,
};
IMPL

  success "Created error handling utilities"
}

# ─────────────────────────────────────────────────────────────────────────────
# Main
# ─────────────────────────────────────────────────────────────────────────────

main() {
  echo ""
  echo "══════════════════════════════════════════════════════════════════"
  echo "  Fixing Empty Catch Blocks"
  echo "══════════════════════════════════════════════════════════════════"
  echo ""

  create_error_utils
  fix_empty_catches
  fix_ignored_errors

  echo ""
  success "Catch block fixes complete! See: $LOG_FILE"
}

main "$@"
