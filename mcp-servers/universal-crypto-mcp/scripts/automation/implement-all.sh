#!/usr/bin/env bash
# ═══════════════════════════════════════════════════════════════════════════════
# Implement All TODOs - Full Automated Implementation
# ═══════════════════════════════════════════════════════════════════════════════

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ROOT_DIR="$(cd "$SCRIPT_DIR/../.." && pwd)"
GENERATED_DIR="$ROOT_DIR/generated/implementations"
BACKUP_DIR="$ROOT_DIR/.backups/automation/$(date +%Y%m%d_%H%M%S)"
LOG_FILE="$ROOT_DIR/logs/automation/implement-all_$(date +%Y%m%d_%H%M%S).log"

# Colors
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
RED='\033[0;31m'
NC='\033[0m'

log() { echo -e "${BLUE}[$(date +%H:%M:%S)]${NC} $1" | tee -a "$LOG_FILE"; }
success() { echo -e "${GREEN}[SUCCESS]${NC} $1" | tee -a "$LOG_FILE"; }
warn() { echo -e "${YELLOW}[WARNING]${NC} $1" | tee -a "$LOG_FILE"; }
error() { echo -e "${RED}[ERROR]${NC} $1" | tee -a "$LOG_FILE"; }

mkdir -p "$GENERATED_DIR" "$BACKUP_DIR" "$(dirname "$LOG_FILE")"

# ─────────────────────────────────────────────────────────────────────────────
# Implementation: Signature Verification
# ─────────────────────────────────────────────────────────────────────────────

implement_signature_verification() {
  log "Implementing signature verification..."
  
  local target_file="$ROOT_DIR/packages/shared/crypto/signature-verification.ts"
  mkdir -p "$(dirname "$target_file")"
  
  cat > "$target_file" << 'IMPL'
/**
 * @file signature-verification.ts
 * @description Cryptographic signature verification implementation
 * @implements x402-gateway.ts#L339 TODO: Verify signature cryptographically
 * @auto-generated by todo-automation
 */

import { createPublicClient, http, verifyMessage, verifyTypedData, recoverMessageAddress } from 'viem';
import { mainnet, sepolia, base, arbitrum, optimism, polygon } from 'viem/chains';
import { keccak256, toBytes, concat, hexToBytes, bytesToHex } from 'viem';
import * as nacl from 'tweetnacl';
import { PublicKey } from '@solana/web3.js';
import bs58 from 'bs58';

// ═══════════════════════════════════════════════════════════════════════════
// Types
// ═══════════════════════════════════════════════════════════════════════════

export interface SignatureVerificationResult {
  valid: boolean;
  recoveredAddress?: string;
  error?: string;
  timestamp: number;
  method: 'eip191' | 'eip712' | 'solana' | 'eip1271';
}

export interface EIP712Domain {
  name: string;
  version: string;
  chainId: number;
  verifyingContract: `0x${string}`;
}

export interface PaymentPayload {
  scheme: string;
  network: string;
  maxAmountRequired: string;
  resource: string;
  description: string;
  mimeType: string;
  payTo: string;
  maxTimeoutSeconds: number;
  asset: string;
  extra?: Record<string, unknown>;
}

export interface SignedPayment {
  payload: PaymentPayload;
  signature: string;
  signer: string;
}

// ═══════════════════════════════════════════════════════════════════════════
// EVM Signature Verification
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Verify EIP-191 personal message signature
 */
export async function verifyPersonalSignature(
  message: string,
  signature: `0x${string}`,
  expectedSigner: `0x${string}`
): Promise<SignatureVerificationResult> {
  try {
    const valid = await verifyMessage({
      address: expectedSigner,
      message,
      signature,
    });

    const recoveredAddress = await recoverMessageAddress({
      message,
      signature,
    });

    return {
      valid,
      recoveredAddress,
      timestamp: Date.now(),
      method: 'eip191',
    };
  } catch (error) {
    return {
      valid: false,
      error: error instanceof Error ? error.message : 'Verification failed',
      timestamp: Date.now(),
      method: 'eip191',
    };
  }
}

/**
 * Verify EIP-712 typed data signature
 */
export async function verifyTypedDataSignature(
  domain: EIP712Domain,
  types: Record<string, Array<{ name: string; type: string }>>,
  primaryType: string,
  message: Record<string, unknown>,
  signature: `0x${string}`,
  expectedSigner: `0x${string}`
): Promise<SignatureVerificationResult> {
  try {
    const valid = await verifyTypedData({
      address: expectedSigner,
      domain,
      types,
      primaryType,
      message,
      signature,
    });

    return {
      valid,
      recoveredAddress: expectedSigner,
      timestamp: Date.now(),
      method: 'eip712',
    };
  } catch (error) {
    return {
      valid: false,
      error: error instanceof Error ? error.message : 'Verification failed',
      timestamp: Date.now(),
      method: 'eip712',
    };
  }
}

/**
 * Verify x402 payment signature
 */
export async function verifyX402PaymentSignature(
  signedPayment: SignedPayment
): Promise<SignatureVerificationResult> {
  const { payload, signature, signer } = signedPayment;

  // Determine chain type
  if (payload.network.toLowerCase().includes('solana')) {
    return verifySolanaSignature(
      JSON.stringify(payload),
      signature,
      signer
    );
  }

  // EVM signature verification
  const domain: EIP712Domain = {
    name: 'x402 Payment',
    version: '1',
    chainId: getChainId(payload.network),
    verifyingContract: payload.payTo as `0x${string}`,
  };

  const types = {
    Payment: [
      { name: 'scheme', type: 'string' },
      { name: 'network', type: 'string' },
      { name: 'maxAmountRequired', type: 'string' },
      { name: 'resource', type: 'string' },
      { name: 'payTo', type: 'address' },
      { name: 'asset', type: 'address' },
      { name: 'maxTimeoutSeconds', type: 'uint256' },
    ],
  };

  return verifyTypedDataSignature(
    domain,
    types,
    'Payment',
    {
      scheme: payload.scheme,
      network: payload.network,
      maxAmountRequired: payload.maxAmountRequired,
      resource: payload.resource,
      payTo: payload.payTo,
      asset: payload.asset,
      maxTimeoutSeconds: BigInt(payload.maxTimeoutSeconds),
    },
    signature as `0x${string}`,
    signer as `0x${string}`
  );
}

// ═══════════════════════════════════════════════════════════════════════════
// Solana Signature Verification
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Verify Solana Ed25519 signature
 */
export function verifySolanaSignature(
  message: string,
  signature: string,
  publicKeyString: string
): SignatureVerificationResult {
  try {
    // Decode the public key
    const publicKey = new PublicKey(publicKeyString);
    const publicKeyBytes = publicKey.toBytes();

    // Decode the signature (base58 or hex)
    let signatureBytes: Uint8Array;
    if (signature.startsWith('0x')) {
      signatureBytes = hexToBytes(signature as `0x${string}`);
    } else {
      signatureBytes = bs58.decode(signature);
    }

    // Convert message to bytes
    const messageBytes = new TextEncoder().encode(message);

    // Verify using nacl
    const valid = nacl.sign.detached.verify(
      messageBytes,
      signatureBytes,
      publicKeyBytes
    );

    return {
      valid,
      recoveredAddress: publicKeyString,
      timestamp: Date.now(),
      method: 'solana',
    };
  } catch (error) {
    return {
      valid: false,
      error: error instanceof Error ? error.message : 'Solana verification failed',
      timestamp: Date.now(),
      method: 'solana',
    };
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// EIP-1271 Smart Contract Signature Verification
// ═══════════════════════════════════════════════════════════════════════════

const EIP1271_MAGIC_VALUE = '0x1626ba7e';

const EIP1271_ABI = [
  {
    inputs: [
      { name: 'hash', type: 'bytes32' },
      { name: 'signature', type: 'bytes' },
    ],
    name: 'isValidSignature',
    outputs: [{ name: '', type: 'bytes4' }],
    stateMutability: 'view',
    type: 'function',
  },
] as const;

/**
 * Verify EIP-1271 smart contract wallet signature
 */
export async function verifyContractSignature(
  message: string,
  signature: `0x${string}`,
  contractAddress: `0x${string}`,
  chainId: number
): Promise<SignatureVerificationResult> {
  try {
    const chain = getChainById(chainId);
    const client = createPublicClient({
      chain,
      transport: http(),
    });

    // Hash the message
    const messageHash = keccak256(toBytes(message));

    // Call isValidSignature on the contract
    const result = await client.readContract({
      address: contractAddress,
      abi: EIP1271_ABI,
      functionName: 'isValidSignature',
      args: [messageHash, signature],
    });

    const valid = result === EIP1271_MAGIC_VALUE;

    return {
      valid,
      recoveredAddress: contractAddress,
      timestamp: Date.now(),
      method: 'eip1271',
    };
  } catch (error) {
    return {
      valid: false,
      error: error instanceof Error ? error.message : 'Contract verification failed',
      timestamp: Date.now(),
      method: 'eip1271',
    };
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// Batch Verification
// ═══════════════════════════════════════════════════════════════════════════

export interface BatchVerificationResult {
  total: number;
  valid: number;
  invalid: number;
  results: SignatureVerificationResult[];
}

/**
 * Verify multiple signatures in batch
 */
export async function verifyBatch(
  items: Array<{
    message: string;
    signature: string;
    signer: string;
    type: 'evm' | 'solana';
  }>
): Promise<BatchVerificationResult> {
  const results = await Promise.all(
    items.map(async (item) => {
      if (item.type === 'solana') {
        return verifySolanaSignature(item.message, item.signature, item.signer);
      }
      return verifyPersonalSignature(
        item.message,
        item.signature as `0x${string}`,
        item.signer as `0x${string}`
      );
    })
  );

  return {
    total: results.length,
    valid: results.filter((r) => r.valid).length,
    invalid: results.filter((r) => !r.valid).length,
    results,
  };
}

// ═══════════════════════════════════════════════════════════════════════════
// Helpers
// ═══════════════════════════════════════════════════════════════════════════

function getChainId(network: string): number {
  const networkMap: Record<string, number> = {
    mainnet: 1,
    ethereum: 1,
    sepolia: 11155111,
    base: 8453,
    'base-sepolia': 84532,
    arbitrum: 42161,
    'arbitrum-one': 42161,
    optimism: 10,
    polygon: 137,
  };
  return networkMap[network.toLowerCase()] || 1;
}

function getChainById(chainId: number) {
  const chainMap: Record<number, typeof mainnet> = {
    1: mainnet,
    11155111: sepolia,
    8453: base,
    42161: arbitrum,
    10: optimism,
    137: polygon,
  };
  return chainMap[chainId] || mainnet;
}

// ═══════════════════════════════════════════════════════════════════════════
// Exports
// ═══════════════════════════════════════════════════════════════════════════

export const signatureVerification = {
  verifyPersonalSignature,
  verifyTypedDataSignature,
  verifyX402PaymentSignature,
  verifySolanaSignature,
  verifyContractSignature,
  verifyBatch,
};

export default signatureVerification;
IMPL
  
  success "Created signature verification implementation"
}

# ─────────────────────────────────────────────────────────────────────────────
# Implementation: Refund Logic
# ─────────────────────────────────────────────────────────────────────────────

implement_refund_logic() {
  log "Implementing refund logic..."
  
  local target_file="$ROOT_DIR/packages/shared/payments/refund.ts"
  mkdir -p "$(dirname "$target_file")"
  
  cat > "$target_file" << 'IMPL'
/**
 * @file refund.ts
 * @description Payment refund implementation
 * @implements facilitator.ts#L457, payment.ts#L405, revenue.ts#L519 TODOs
 * @auto-generated by todo-automation
 */

import {
  createWalletClient,
  createPublicClient,
  http,
  parseUnits,
  formatUnits,
  type Address,
  type Hash,
} from 'viem';
import { privateKeyToAccount } from 'viem/accounts';
import { mainnet, base, arbitrum, optimism } from 'viem/chains';

// ═══════════════════════════════════════════════════════════════════════════
// Types
// ═══════════════════════════════════════════════════════════════════════════

export interface RefundRequest {
  paymentId: string;
  originalTxHash: Hash;
  recipient: Address;
  amount: bigint;
  asset: Address;
  chainId: number;
  reason: RefundReason;
  metadata?: Record<string, unknown>;
}

export enum RefundReason {
  CUSTOMER_REQUEST = 'customer_request',
  SERVICE_UNAVAILABLE = 'service_unavailable',
  DUPLICATE_PAYMENT = 'duplicate_payment',
  FAILED_DELIVERY = 'failed_delivery',
  FRAUD_DETECTED = 'fraud_detected',
  PARTIAL_FULFILLMENT = 'partial_fulfillment',
  OVERPAYMENT = 'overpayment',
}

export enum RefundStatus {
  PENDING = 'pending',
  PROCESSING = 'processing',
  COMPLETED = 'completed',
  FAILED = 'failed',
  CANCELLED = 'cancelled',
}

export interface RefundResult {
  refundId: string;
  status: RefundStatus;
  txHash?: Hash;
  amount: bigint;
  fee: bigint;
  netAmount: bigint;
  timestamp: number;
  error?: string;
}

export interface RefundPolicy {
  maxRefundWindowDays: number;
  refundFeePercent: number;
  minRefundAmount: bigint;
  maxRefundAmount: bigint;
  allowPartialRefunds: boolean;
  requiresApproval: boolean;
  autoApproveThreshold: bigint;
}

// ═══════════════════════════════════════════════════════════════════════════
// ERC20 ABI for transfers
// ═══════════════════════════════════════════════════════════════════════════

const ERC20_ABI = [
  {
    inputs: [
      { name: 'to', type: 'address' },
      { name: 'amount', type: 'uint256' },
    ],
    name: 'transfer',
    outputs: [{ name: '', type: 'bool' }],
    stateMutability: 'nonpayable',
    type: 'function',
  },
  {
    inputs: [{ name: 'account', type: 'address' }],
    name: 'balanceOf',
    outputs: [{ name: '', type: 'uint256' }],
    stateMutability: 'view',
    type: 'function',
  },
  {
    inputs: [],
    name: 'decimals',
    outputs: [{ name: '', type: 'uint8' }],
    stateMutability: 'view',
    type: 'function',
  },
] as const;

// ═══════════════════════════════════════════════════════════════════════════
// Refund Service
// ═══════════════════════════════════════════════════════════════════════════

export class RefundService {
  private policy: RefundPolicy;
  private signerPrivateKey: `0x${string}`;
  
  constructor(signerPrivateKey: `0x${string}`, policy?: Partial<RefundPolicy>) {
    this.signerPrivateKey = signerPrivateKey;
    this.policy = {
      maxRefundWindowDays: 30,
      refundFeePercent: 0,
      minRefundAmount: parseUnits('0.01', 6), // 0.01 USDC
      maxRefundAmount: parseUnits('10000', 6), // 10k USDC
      allowPartialRefunds: true,
      requiresApproval: false,
      autoApproveThreshold: parseUnits('100', 6), // Auto-approve under $100
      ...policy,
    };
  }

  /**
   * Process a refund request
   */
  async processRefund(request: RefundRequest): Promise<RefundResult> {
    const refundId = `ref_${Date.now()}_${Math.random().toString(36).slice(2, 11)}`;
    
    try {
      // Validate the request
      await this.validateRefundRequest(request);
      
      // Calculate fees
      const fee = (request.amount * BigInt(this.policy.refundFeePercent)) / 100n;
      const netAmount = request.amount - fee;
      
      // Check if approval is required
      if (this.policy.requiresApproval && request.amount > this.policy.autoApproveThreshold) {
        return {
          refundId,
          status: RefundStatus.PENDING,
          amount: request.amount,
          fee,
          netAmount,
          timestamp: Date.now(),
        };
      }
      
      // Execute the refund
      const txHash = await this.executeRefund(request, netAmount);
      
      return {
        refundId,
        status: RefundStatus.COMPLETED,
        txHash,
        amount: request.amount,
        fee,
        netAmount,
        timestamp: Date.now(),
      };
    } catch (error) {
      return {
        refundId,
        status: RefundStatus.FAILED,
        amount: request.amount,
        fee: 0n,
        netAmount: 0n,
        timestamp: Date.now(),
        error: error instanceof Error ? error.message : 'Refund failed',
      };
    }
  }

  /**
   * Execute the on-chain refund transfer
   */
  private async executeRefund(request: RefundRequest, amount: bigint): Promise<Hash> {
    const chain = this.getChainById(request.chainId);
    const account = privateKeyToAccount(this.signerPrivateKey);
    
    const publicClient = createPublicClient({
      chain,
      transport: http(),
    });
    
    const walletClient = createWalletClient({
      account,
      chain,
      transport: http(),
    });

    // Check balance before transfer
    const balance = await publicClient.readContract({
      address: request.asset,
      abi: ERC20_ABI,
      functionName: 'balanceOf',
      args: [account.address],
    });

    if (balance < amount) {
      throw new Error(`Insufficient balance for refund: ${balance} < ${amount}`);
    }

    // Execute the transfer
    const hash = await walletClient.writeContract({
      address: request.asset,
      abi: ERC20_ABI,
      functionName: 'transfer',
      args: [request.recipient, amount],
    });

    // Wait for confirmation
    await publicClient.waitForTransactionReceipt({ hash });

    return hash;
  }

  /**
   * Validate refund request against policy
   */
  private async validateRefundRequest(request: RefundRequest): Promise<void> {
    // Check amount limits
    if (request.amount < this.policy.minRefundAmount) {
      throw new Error(`Refund amount below minimum: ${request.amount} < ${this.policy.minRefundAmount}`);
    }
    
    if (request.amount > this.policy.maxRefundAmount) {
      throw new Error(`Refund amount exceeds maximum: ${request.amount} > ${this.policy.maxRefundAmount}`);
    }

    // Validate recipient address
    if (!request.recipient || !/^0x[a-fA-F0-9]{40}$/.test(request.recipient)) {
      throw new Error('Invalid recipient address');
    }

    // Validate original transaction exists (in production, verify on-chain)
    if (!request.originalTxHash || !/^0x[a-fA-F0-9]{64}$/.test(request.originalTxHash)) {
      throw new Error('Invalid original transaction hash');
    }
  }

  /**
   * Calculate refund amount after fees
   */
  calculateRefundAmount(grossAmount: bigint): { fee: bigint; netAmount: bigint } {
    const fee = (grossAmount * BigInt(this.policy.refundFeePercent)) / 100n;
    return {
      fee,
      netAmount: grossAmount - fee,
    };
  }

  /**
   * Check if a refund is eligible
   */
  async checkRefundEligibility(
    paymentDate: Date,
    amount: bigint
  ): Promise<{ eligible: boolean; reason?: string }> {
    const daysSincePayment = Math.floor(
      (Date.now() - paymentDate.getTime()) / (1000 * 60 * 60 * 24)
    );

    if (daysSincePayment > this.policy.maxRefundWindowDays) {
      return {
        eligible: false,
        reason: `Refund window expired (${daysSincePayment} days > ${this.policy.maxRefundWindowDays} days)`,
      };
    }

    if (amount < this.policy.minRefundAmount) {
      return {
        eligible: false,
        reason: `Amount below minimum refundable amount`,
      };
    }

    if (amount > this.policy.maxRefundAmount) {
      return {
        eligible: false,
        reason: `Amount exceeds maximum refundable amount`,
      };
    }

    return { eligible: true };
  }

  private getChainById(chainId: number) {
    const chains: Record<number, typeof mainnet> = {
      1: mainnet,
      8453: base,
      42161: arbitrum,
      10: optimism,
    };
    return chains[chainId] || mainnet;
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// Batch Refund Processing
// ═══════════════════════════════════════════════════════════════════════════

export async function processBatchRefunds(
  service: RefundService,
  requests: RefundRequest[]
): Promise<{
  successful: RefundResult[];
  failed: RefundResult[];
  totalRefunded: bigint;
  totalFees: bigint;
}> {
  const results = await Promise.allSettled(
    requests.map((req) => service.processRefund(req))
  );

  const successful: RefundResult[] = [];
  const failed: RefundResult[] = [];
  let totalRefunded = 0n;
  let totalFees = 0n;

  for (const result of results) {
    if (result.status === 'fulfilled') {
      const refund = result.value;
      if (refund.status === RefundStatus.COMPLETED) {
        successful.push(refund);
        totalRefunded += refund.netAmount;
        totalFees += refund.fee;
      } else {
        failed.push(refund);
      }
    } else {
      failed.push({
        refundId: 'unknown',
        status: RefundStatus.FAILED,
        amount: 0n,
        fee: 0n,
        netAmount: 0n,
        timestamp: Date.now(),
        error: result.reason?.message || 'Unknown error',
      });
    }
  }

  return { successful, failed, totalRefunded, totalFees };
}

// ═══════════════════════════════════════════════════════════════════════════
// Exports
// ═══════════════════════════════════════════════════════════════════════════

export default RefundService;
IMPL

  success "Created refund logic implementation"
}

# ─────────────────────────────────────────────────────────────────────────────
# Implementation: Price Aggregator
# ─────────────────────────────────────────────────────────────────────────────

implement_price_aggregator() {
  log "Implementing price aggregator..."
  
  local target_file="$ROOT_DIR/packages/shared/prices/aggregator.ts"
  mkdir -p "$(dirname "$target_file")"
  
  cat > "$target_file" << 'IMPL'
/**
 * @file aggregator.ts
 * @description Multi-source price aggregation with fallback
 * @implements workers.ts#L96 TODO: Implement price fetching from CoinGecko/DeFiLlama
 * @auto-generated by todo-automation
 */

// ═══════════════════════════════════════════════════════════════════════════
// Types
// ═══════════════════════════════════════════════════════════════════════════

export interface PriceData {
  symbol: string;
  price: number;
  priceUsd: number;
  change24h: number;
  volume24h: number;
  marketCap: number;
  lastUpdated: number;
  source: PriceSource;
  confidence: number;
}

export enum PriceSource {
  COINGECKO = 'coingecko',
  DEFILLAMA = 'defillama',
  CHAINLINK = 'chainlink',
  UNISWAP = 'uniswap',
  BINANCE = 'binance',
  AGGREGATED = 'aggregated',
}

export interface PriceAggregatorConfig {
  sources: PriceSource[];
  cacheTtlMs: number;
  maxStaleMs: number;
  minConfidence: number;
  useMedian: boolean;
}

interface CacheEntry {
  data: PriceData;
  timestamp: number;
}

// ═══════════════════════════════════════════════════════════════════════════
// Price Fetchers
// ═══════════════════════════════════════════════════════════════════════════

async function fetchFromCoinGecko(tokenId: string): Promise<PriceData | null> {
  try {
    const response = await fetch(
      `https://api.coingecko.com/api/v3/simple/price?ids=${tokenId}&vs_currencies=usd&include_24hr_change=true&include_24hr_vol=true&include_market_cap=true`,
      {
        headers: {
          'Accept': 'application/json',
        },
      }
    );

    if (!response.ok) return null;

    const data = await response.json();
    const tokenData = data[tokenId];
    
    if (!tokenData) return null;

    return {
      symbol: tokenId,
      price: tokenData.usd,
      priceUsd: tokenData.usd,
      change24h: tokenData.usd_24h_change || 0,
      volume24h: tokenData.usd_24h_vol || 0,
      marketCap: tokenData.usd_market_cap || 0,
      lastUpdated: Date.now(),
      source: PriceSource.COINGECKO,
      confidence: 0.95,
    };
  } catch (error) {
    console.error('[CoinGecko] Error fetching price:', error);
    return null;
  }
}

async function fetchFromDefiLlama(tokenAddress: string, chain: string = 'ethereum'): Promise<PriceData | null> {
  try {
    const coinId = `${chain}:${tokenAddress}`;
    const response = await fetch(
      `https://coins.llama.fi/prices/current/${coinId}`,
      {
        headers: {
          'Accept': 'application/json',
        },
      }
    );

    if (!response.ok) return null;

    const data = await response.json();
    const coin = data.coins?.[coinId];
    
    if (!coin) return null;

    return {
      symbol: coin.symbol || tokenAddress,
      price: coin.price,
      priceUsd: coin.price,
      change24h: 0, // DeFiLlama doesn't provide this directly
      volume24h: 0,
      marketCap: 0,
      lastUpdated: coin.timestamp * 1000 || Date.now(),
      source: PriceSource.DEFILLAMA,
      confidence: coin.confidence || 0.9,
    };
  } catch (error) {
    console.error('[DeFiLlama] Error fetching price:', error);
    return null;
  }
}

async function fetchFromBinance(symbol: string): Promise<PriceData | null> {
  try {
    const pair = `${symbol.toUpperCase()}USDT`;
    const [tickerRes, statsRes] = await Promise.all([
      fetch(`https://api.binance.com/api/v3/ticker/price?symbol=${pair}`),
      fetch(`https://api.binance.com/api/v3/ticker/24hr?symbol=${pair}`),
    ]);

    if (!tickerRes.ok || !statsRes.ok) return null;

    const ticker = await tickerRes.json();
    const stats = await statsRes.json();

    return {
      symbol,
      price: parseFloat(ticker.price),
      priceUsd: parseFloat(ticker.price),
      change24h: parseFloat(stats.priceChangePercent),
      volume24h: parseFloat(stats.volume) * parseFloat(ticker.price),
      marketCap: 0,
      lastUpdated: Date.now(),
      source: PriceSource.BINANCE,
      confidence: 0.98,
    };
  } catch (error) {
    console.error('[Binance] Error fetching price:', error);
    return null;
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// Price Aggregator Service
// ═══════════════════════════════════════════════════════════════════════════

export class PriceAggregator {
  private cache: Map<string, CacheEntry> = new Map();
  private config: PriceAggregatorConfig;

  constructor(config?: Partial<PriceAggregatorConfig>) {
    this.config = {
      sources: [PriceSource.COINGECKO, PriceSource.DEFILLAMA, PriceSource.BINANCE],
      cacheTtlMs: 30000, // 30 seconds
      maxStaleMs: 300000, // 5 minutes
      minConfidence: 0.8,
      useMedian: true,
      ...config,
    };
  }

  /**
   * Get aggregated price from multiple sources
   */
  async getPrice(identifier: string, options?: {
    chain?: string;
    forceRefresh?: boolean;
  }): Promise<PriceData | null> {
    const cacheKey = `${identifier}:${options?.chain || 'default'}`;
    
    // Check cache first
    if (!options?.forceRefresh) {
      const cached = this.cache.get(cacheKey);
      if (cached && Date.now() - cached.timestamp < this.config.cacheTtlMs) {
        return cached.data;
      }
    }

    // Fetch from all configured sources
    const prices = await this.fetchFromAllSources(identifier, options?.chain);
    
    if (prices.length === 0) {
      // Return stale cache if available
      const stale = this.cache.get(cacheKey);
      if (stale && Date.now() - stale.timestamp < this.config.maxStaleMs) {
        return { ...stale.data, confidence: stale.data.confidence * 0.5 };
      }
      return null;
    }

    // Aggregate prices
    const aggregated = this.aggregatePrices(prices, identifier);
    
    // Cache the result
    this.cache.set(cacheKey, {
      data: aggregated,
      timestamp: Date.now(),
    });

    return aggregated;
  }

  /**
   * Get prices for multiple tokens
   */
  async getPrices(identifiers: string[]): Promise<Map<string, PriceData | null>> {
    const results = await Promise.all(
      identifiers.map(async (id) => ({
        id,
        data: await this.getPrice(id),
      }))
    );

    return new Map(results.map(({ id, data }) => [id, data]));
  }

  /**
   * Fetch from all configured sources
   */
  private async fetchFromAllSources(identifier: string, chain?: string): Promise<PriceData[]> {
    const fetchers: Promise<PriceData | null>[] = [];

    for (const source of this.config.sources) {
      switch (source) {
        case PriceSource.COINGECKO:
          fetchers.push(fetchFromCoinGecko(identifier));
          break;
        case PriceSource.DEFILLAMA:
          if (identifier.startsWith('0x')) {
            fetchers.push(fetchFromDefiLlama(identifier, chain));
          }
          break;
        case PriceSource.BINANCE:
          fetchers.push(fetchFromBinance(identifier));
          break;
      }
    }

    const results = await Promise.allSettled(fetchers);
    
    return results
      .filter((r): r is PromiseFulfilledResult<PriceData | null> => r.status === 'fulfilled')
      .map((r) => r.value)
      .filter((data): data is PriceData => data !== null && data.confidence >= this.config.minConfidence);
  }

  /**
   * Aggregate prices using median or weighted average
   */
  private aggregatePrices(prices: PriceData[], symbol: string): PriceData {
    if (prices.length === 1) return prices[0];

    const priceValues = prices.map((p) => p.price).sort((a, b) => a - b);
    
    let aggregatedPrice: number;
    
    if (this.config.useMedian) {
      // Median
      const mid = Math.floor(priceValues.length / 2);
      aggregatedPrice = priceValues.length % 2 === 0
        ? (priceValues[mid - 1] + priceValues[mid]) / 2
        : priceValues[mid];
    } else {
      // Weighted average by confidence
      const totalConfidence = prices.reduce((sum, p) => sum + p.confidence, 0);
      aggregatedPrice = prices.reduce(
        (sum, p) => sum + (p.price * p.confidence) / totalConfidence,
        0
      );
    }

    // Calculate deviation to assess confidence
    const deviation = this.calculateDeviation(priceValues, aggregatedPrice);
    const baseConfidence = Math.min(...prices.map((p) => p.confidence));
    const adjustedConfidence = baseConfidence * (1 - Math.min(deviation, 0.2));

    return {
      symbol,
      price: aggregatedPrice,
      priceUsd: aggregatedPrice,
      change24h: this.median(prices.map((p) => p.change24h)),
      volume24h: Math.max(...prices.map((p) => p.volume24h)),
      marketCap: Math.max(...prices.map((p) => p.marketCap)),
      lastUpdated: Date.now(),
      source: PriceSource.AGGREGATED,
      confidence: adjustedConfidence,
    };
  }

  private calculateDeviation(values: number[], mean: number): number {
    if (values.length < 2) return 0;
    const variance = values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / values.length;
    return Math.sqrt(variance) / mean;
  }

  private median(values: number[]): number {
    const sorted = [...values].sort((a, b) => a - b);
    const mid = Math.floor(sorted.length / 2);
    return sorted.length % 2 === 0
      ? (sorted[mid - 1] + sorted[mid]) / 2
      : sorted[mid];
  }

  /**
   * Clear the price cache
   */
  clearCache(): void {
    this.cache.clear();
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// Common Token Mappings
// ═══════════════════════════════════════════════════════════════════════════

export const TOKEN_MAPPINGS: Record<string, { coingecko: string; binance: string }> = {
  ETH: { coingecko: 'ethereum', binance: 'ETH' },
  WETH: { coingecko: 'weth', binance: 'ETH' },
  BTC: { coingecko: 'bitcoin', binance: 'BTC' },
  WBTC: { coingecko: 'wrapped-bitcoin', binance: 'BTC' },
  USDC: { coingecko: 'usd-coin', binance: 'USDC' },
  USDT: { coingecko: 'tether', binance: 'USDT' },
  DAI: { coingecko: 'dai', binance: 'DAI' },
  SOL: { coingecko: 'solana', binance: 'SOL' },
  MATIC: { coingecko: 'matic-network', binance: 'MATIC' },
  ARB: { coingecko: 'arbitrum', binance: 'ARB' },
  OP: { coingecko: 'optimism', binance: 'OP' },
  LINK: { coingecko: 'chainlink', binance: 'LINK' },
  UNI: { coingecko: 'uniswap', binance: 'UNI' },
  AAVE: { coingecko: 'aave', binance: 'AAVE' },
};

// ═══════════════════════════════════════════════════════════════════════════
// Singleton Instance
// ═══════════════════════════════════════════════════════════════════════════

export const priceAggregator = new PriceAggregator();

export default PriceAggregator;
IMPL

  success "Created price aggregator implementation"
}

# ─────────────────────────────────────────────────────────────────────────────
# Implementation: Database Initialization (Volume Bot)
# ─────────────────────────────────────────────────────────────────────────────

implement_database_init() {
  log "Implementing database initialization..."
  
  local target_file="$ROOT_DIR/packages/shared/database/init.ts"
  mkdir -p "$(dirname "$target_file")"
  
  cat > "$target_file" << 'IMPL'
/**
 * @file init.ts
 * @description Database initialization and migration system
 * @implements cli.ts#L56 TODO: Implement database initialization
 * @implements cli.ts#L76 TODO: Implement migrations
 * @auto-generated by todo-automation
 */

import { drizzle } from 'drizzle-orm/postgres-js';
import { migrate } from 'drizzle-orm/postgres-js/migrator';
import postgres from 'postgres';
import * as schema from './schema';
import { sql } from 'drizzle-orm';

// ═══════════════════════════════════════════════════════════════════════════
// Types
// ═══════════════════════════════════════════════════════════════════════════

export interface DatabaseConfig {
  connectionString: string;
  maxConnections?: number;
  idleTimeout?: number;
  ssl?: boolean | 'require' | 'allow' | 'prefer';
}

export interface MigrationResult {
  success: boolean;
  appliedMigrations: string[];
  error?: string;
}

export interface HealthCheckResult {
  connected: boolean;
  latencyMs: number;
  version?: string;
  error?: string;
}

// ═══════════════════════════════════════════════════════════════════════════
// Database Manager
// ═══════════════════════════════════════════════════════════════════════════

export class DatabaseManager {
  private client: ReturnType<typeof postgres> | null = null;
  private db: ReturnType<typeof drizzle> | null = null;
  private config: DatabaseConfig;

  constructor(config: DatabaseConfig) {
    this.config = {
      maxConnections: 10,
      idleTimeout: 30,
      ssl: 'prefer',
      ...config,
    };
  }

  /**
   * Initialize database connection
   */
  async initialize(): Promise<void> {
    console.log('[Database] Initializing connection...');
    
    this.client = postgres(this.config.connectionString, {
      max: this.config.maxConnections,
      idle_timeout: this.config.idleTimeout,
      ssl: this.config.ssl,
      onnotice: () => {}, // Suppress notices
    });

    this.db = drizzle(this.client, { schema });

    // Test connection
    const health = await this.healthCheck();
    if (!health.connected) {
      throw new Error(`Database connection failed: ${health.error}`);
    }

    console.log(`[Database] Connected to PostgreSQL ${health.version}`);
  }

  /**
   * Run database migrations
   */
  async runMigrations(migrationsFolder: string = './drizzle'): Promise<MigrationResult> {
    if (!this.db || !this.client) {
      return { success: false, appliedMigrations: [], error: 'Database not initialized' };
    }

    console.log('[Database] Running migrations...');

    try {
      await migrate(this.db, { migrationsFolder });
      
      // Get list of applied migrations
      const result = await this.client`
        SELECT name FROM drizzle.__drizzle_migrations 
        ORDER BY created_at DESC
      `.catch(() => []);

      const appliedMigrations = result.map((r: { name: string }) => r.name);
      
      console.log(`[Database] Applied ${appliedMigrations.length} migrations`);
      
      return { success: true, appliedMigrations };
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Migration failed';
      console.error('[Database] Migration error:', message);
      return { success: false, appliedMigrations: [], error: message };
    }
  }

  /**
   * Create required tables if they don't exist
   */
  async createTables(): Promise<void> {
    if (!this.client) throw new Error('Database not initialized');

    console.log('[Database] Creating tables...');

    // Campaigns table
    await this.client`
      CREATE TABLE IF NOT EXISTS campaigns (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        name VARCHAR(255) NOT NULL,
        status VARCHAR(50) DEFAULT 'pending',
        target_volume DECIMAL(20, 8) NOT NULL,
        current_volume DECIMAL(20, 8) DEFAULT 0,
        token_address VARCHAR(66) NOT NULL,
        chain_id INTEGER NOT NULL,
        start_time TIMESTAMP,
        end_time TIMESTAMP,
        config JSONB DEFAULT '{}',
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      )
    `;

    // Trades table
    await this.client`
      CREATE TABLE IF NOT EXISTS trades (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        campaign_id UUID REFERENCES campaigns(id),
        tx_hash VARCHAR(66) UNIQUE NOT NULL,
        direction VARCHAR(10) NOT NULL,
        amount DECIMAL(20, 8) NOT NULL,
        price DECIMAL(20, 8) NOT NULL,
        status VARCHAR(50) DEFAULT 'pending',
        wallet_address VARCHAR(66) NOT NULL,
        gas_used DECIMAL(20, 8),
        error_message TEXT,
        created_at TIMESTAMP DEFAULT NOW()
      )
    `;

    // Wallets table
    await this.client`
      CREATE TABLE IF NOT EXISTS wallets (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        address VARCHAR(66) UNIQUE NOT NULL,
        chain VARCHAR(50) NOT NULL,
        label VARCHAR(255),
        balance JSONB DEFAULT '{}',
        last_used TIMESTAMP,
        created_at TIMESTAMP DEFAULT NOW()
      )
    `;

    // Bots table
    await this.client`
      CREATE TABLE IF NOT EXISTS bots (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        name VARCHAR(255) NOT NULL,
        type VARCHAR(50) NOT NULL,
        status VARCHAR(50) DEFAULT 'stopped',
        config JSONB DEFAULT '{}',
        stats JSONB DEFAULT '{}',
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      )
    `;

    // Payments table (for x402)
    await this.client`
      CREATE TABLE IF NOT EXISTS payments (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        tx_hash VARCHAR(66) UNIQUE,
        payer_address VARCHAR(66) NOT NULL,
        recipient_address VARCHAR(66) NOT NULL,
        amount DECIMAL(20, 8) NOT NULL,
        asset_address VARCHAR(66) NOT NULL,
        chain_id INTEGER NOT NULL,
        status VARCHAR(50) DEFAULT 'pending',
        resource VARCHAR(512),
        settled_at TIMESTAMP,
        refunded_at TIMESTAMP,
        created_at TIMESTAMP DEFAULT NOW()
      )
    `;

    // Indexes
    await this.client`
      CREATE INDEX IF NOT EXISTS idx_campaigns_status ON campaigns(status);
      CREATE INDEX IF NOT EXISTS idx_trades_campaign ON trades(campaign_id);
      CREATE INDEX IF NOT EXISTS idx_trades_status ON trades(status);
      CREATE INDEX IF NOT EXISTS idx_payments_payer ON payments(payer_address);
      CREATE INDEX IF NOT EXISTS idx_payments_status ON payments(status);
    `;

    console.log('[Database] Tables created successfully');
  }

  /**
   * Seed initial data
   */
  async seed(): Promise<void> {
    if (!this.client) throw new Error('Database not initialized');

    console.log('[Database] Seeding initial data...');

    // Check if already seeded
    const existingBots = await this.client`SELECT COUNT(*) as count FROM bots`;
    if (existingBots[0].count > 0) {
      console.log('[Database] Database already seeded, skipping...');
      return;
    }

    // Insert default bot configurations
    await this.client`
      INSERT INTO bots (name, type, status, config) VALUES
      ('Volume Bot Alpha', 'volume', 'stopped', '{"maxTradesPerMinute": 10, "minTradeSize": 0.1, "maxTradeSize": 1.0}'),
      ('Market Maker Beta', 'market_maker', 'stopped', '{"spread": 0.002, "orderSize": 0.5, "rebalanceThreshold": 0.05}'),
      ('Arbitrage Scanner', 'arbitrage', 'stopped', '{"minProfitBps": 50, "maxGasPrice": 100, "chains": [1, 8453, 42161]}')
    `;

    console.log('[Database] Seeding complete');
  }

  /**
   * Health check
   */
  async healthCheck(): Promise<HealthCheckResult> {
    if (!this.client) {
      return { connected: false, latencyMs: 0, error: 'Not initialized' };
    }

    const start = Date.now();
    
    try {
      const result = await this.client`SELECT version()`;
      return {
        connected: true,
        latencyMs: Date.now() - start,
        version: result[0]?.version,
      };
    } catch (error) {
      return {
        connected: false,
        latencyMs: Date.now() - start,
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }
  }

  /**
   * Get database instance
   */
  getDb() {
    if (!this.db) throw new Error('Database not initialized');
    return this.db;
  }

  /**
   * Get raw client
   */
  getClient() {
    if (!this.client) throw new Error('Database not initialized');
    return this.client;
  }

  /**
   * Close connection
   */
  async close(): Promise<void> {
    if (this.client) {
      await this.client.end();
      this.client = null;
      this.db = null;
      console.log('[Database] Connection closed');
    }
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// CLI Database Commands
// ═══════════════════════════════════════════════════════════════════════════

export async function initializeDatabase(connectionString: string): Promise<void> {
  const manager = new DatabaseManager({ connectionString });
  
  try {
    await manager.initialize();
    await manager.createTables();
    await manager.seed();
    console.log('✅ Database initialization complete');
  } finally {
    await manager.close();
  }
}

export async function runDatabaseMigrations(
  connectionString: string,
  migrationsPath: string
): Promise<MigrationResult> {
  const manager = new DatabaseManager({ connectionString });
  
  try {
    await manager.initialize();
    return await manager.runMigrations(migrationsPath);
  } finally {
    await manager.close();
  }
}

export async function checkDatabaseHealth(connectionString: string): Promise<HealthCheckResult> {
  const manager = new DatabaseManager({ connectionString });
  
  try {
    await manager.initialize();
    return await manager.healthCheck();
  } finally {
    await manager.close();
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// Exports
// ═══════════════════════════════════════════════════════════════════════════

export default DatabaseManager;
IMPL

  success "Created database initialization implementation"
}

# ─────────────────────────────────────────────────────────────────────────────
# Implementation: Sweep Logic
# ─────────────────────────────────────────────────────────────────────────────

implement_sweep_logic() {
  log "Implementing sweep logic..."
  
  local target_file="$ROOT_DIR/packages/shared/automation/sweep.ts"
  mkdir -p "$(dirname "$target_file")"
  
  cat > "$target_file" << 'IMPL'
/**
 * @file sweep.ts
 * @description Token sweeping and consolidation implementation
 * @implements workers.ts#L49, sweep.ts#L104, sweep.ts#L220 TODOs
 * @auto-generated by todo-automation
 */

import {
  createPublicClient,
  createWalletClient,
  http,
  parseUnits,
  formatUnits,
  type Address,
  type Hash,
  type Chain,
} from 'viem';
import { privateKeyToAccount } from 'viem/accounts';
import { mainnet, base, arbitrum, optimism, polygon } from 'viem/chains';

// ═══════════════════════════════════════════════════════════════════════════
// Types
// ═══════════════════════════════════════════════════════════════════════════

export interface SweepConfig {
  sourceWallets: Address[];
  destinationWallet: Address;
  tokens: TokenConfig[];
  chainId: number;
  minSweepValue: bigint;
  maxGasPrice: bigint;
  batchSize: number;
  retryAttempts: number;
  gasBuffer: number; // Percentage buffer for gas estimation
}

export interface TokenConfig {
  address: Address;
  symbol: string;
  decimals: number;
  minBalance: bigint;
}

export interface SweepResult {
  sweepId: string;
  sourceWallet: Address;
  destinationWallet: Address;
  transfers: TransferResult[];
  totalValueUsd: number;
  gasUsed: bigint;
  gasPrice: bigint;
  timestamp: number;
  status: 'completed' | 'partial' | 'failed';
}

export interface TransferResult {
  token: Address;
  amount: bigint;
  txHash?: Hash;
  status: 'success' | 'failed' | 'skipped';
  error?: string;
}

export interface ConsolidationPlan {
  sourceWallets: Address[];
  destination: Address;
  estimatedTransfers: number;
  estimatedGas: bigint;
  tokens: Array<{
    address: Address;
    symbol: string;
    totalAmount: bigint;
    walletBalances: Map<Address, bigint>;
  }>;
}

// ═══════════════════════════════════════════════════════════════════════════
// ABIs
// ═══════════════════════════════════════════════════════════════════════════

const ERC20_ABI = [
  {
    inputs: [{ name: 'account', type: 'address' }],
    name: 'balanceOf',
    outputs: [{ name: '', type: 'uint256' }],
    stateMutability: 'view',
    type: 'function',
  },
  {
    inputs: [
      { name: 'to', type: 'address' },
      { name: 'amount', type: 'uint256' },
    ],
    name: 'transfer',
    outputs: [{ name: '', type: 'bool' }],
    stateMutability: 'nonpayable',
    type: 'function',
  },
  {
    inputs: [],
    name: 'decimals',
    outputs: [{ name: '', type: 'uint8' }],
    stateMutability: 'view',
    type: 'function',
  },
  {
    inputs: [],
    name: 'symbol',
    outputs: [{ name: '', type: 'string' }],
    stateMutability: 'view',
    type: 'function',
  },
] as const;

// ═══════════════════════════════════════════════════════════════════════════
// Sweep Service
// ═══════════════════════════════════════════════════════════════════════════

export class SweepService {
  private chain: Chain;
  private publicClient: ReturnType<typeof createPublicClient>;

  constructor(chainId: number, rpcUrl?: string) {
    this.chain = this.getChainById(chainId);
    this.publicClient = createPublicClient({
      chain: this.chain,
      transport: http(rpcUrl),
    });
  }

  /**
   * Plan consolidation before execution
   */
  async planConsolidation(
    sourceWallets: Address[],
    destination: Address,
    tokens: Address[]
  ): Promise<ConsolidationPlan> {
    const tokenDetails: ConsolidationPlan['tokens'] = [];

    for (const tokenAddress of tokens) {
      const walletBalances = new Map<Address, bigint>();
      let totalAmount = 0n;

      // Get token info
      const [symbol, decimals] = await Promise.all([
        this.publicClient.readContract({
          address: tokenAddress,
          abi: ERC20_ABI,
          functionName: 'symbol',
        }),
        this.publicClient.readContract({
          address: tokenAddress,
          abi: ERC20_ABI,
          functionName: 'decimals',
        }),
      ]);

      // Get balances from all source wallets
      for (const wallet of sourceWallets) {
        const balance = await this.publicClient.readContract({
          address: tokenAddress,
          abi: ERC20_ABI,
          functionName: 'balanceOf',
          args: [wallet],
        });

        if (balance > 0n) {
          walletBalances.set(wallet, balance);
          totalAmount += balance;
        }
      }

      if (totalAmount > 0n) {
        tokenDetails.push({
          address: tokenAddress,
          symbol,
          totalAmount,
          walletBalances,
        });
      }
    }

    // Estimate gas
    const estimatedTransfers = tokenDetails.reduce(
      (sum, t) => sum + t.walletBalances.size,
      0
    );
    const estimatedGas = BigInt(estimatedTransfers) * 65000n; // ~65k gas per ERC20 transfer

    return {
      sourceWallets,
      destination,
      estimatedTransfers,
      estimatedGas,
      tokens: tokenDetails,
    };
  }

  /**
   * Execute sweep from a single wallet
   */
  async sweepWallet(
    sourcePrivateKey: `0x${string}`,
    destination: Address,
    tokens: TokenConfig[],
    options?: {
      minBalance?: bigint;
      maxGasPrice?: bigint;
    }
  ): Promise<SweepResult> {
    const sweepId = `swp_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
    const account = privateKeyToAccount(sourcePrivateKey);
    const transfers: TransferResult[] = [];

    const walletClient = createWalletClient({
      account,
      chain: this.chain,
      transport: http(),
    });

    // Check gas price
    const gasPrice = await this.publicClient.getGasPrice();
    if (options?.maxGasPrice && gasPrice > options.maxGasPrice) {
      return {
        sweepId,
        sourceWallet: account.address,
        destinationWallet: destination,
        transfers: [],
        totalValueUsd: 0,
        gasUsed: 0n,
        gasPrice,
        timestamp: Date.now(),
        status: 'failed',
      };
    }

    // Process each token
    let totalGasUsed = 0n;

    for (const token of tokens) {
      try {
        // Get balance
        const balance = await this.publicClient.readContract({
          address: token.address,
          abi: ERC20_ABI,
          functionName: 'balanceOf',
          args: [account.address],
        });

        const minBalance = options?.minBalance || token.minBalance;
        
        if (balance <= minBalance) {
          transfers.push({
            token: token.address,
            amount: balance,
            status: 'skipped',
          });
          continue;
        }

        // Execute transfer
        const hash = await walletClient.writeContract({
          address: token.address,
          abi: ERC20_ABI,
          functionName: 'transfer',
          args: [destination, balance],
        });

        const receipt = await this.publicClient.waitForTransactionReceipt({ hash });
        totalGasUsed += receipt.gasUsed;

        transfers.push({
          token: token.address,
          amount: balance,
          txHash: hash,
          status: 'success',
        });
      } catch (error) {
        transfers.push({
          token: token.address,
          amount: 0n,
          status: 'failed',
          error: error instanceof Error ? error.message : 'Transfer failed',
        });
      }
    }

    // Sweep native token (ETH)
    try {
      const ethBalance = await this.publicClient.getBalance({
        address: account.address,
      });
      
      // Reserve gas for the transfer
      const gasLimit = 21000n;
      const gasCost = gasLimit * gasPrice;
      const transferAmount = ethBalance - gasCost - parseUnits('0.001', 18); // Keep small buffer

      if (transferAmount > 0n) {
        const hash = await walletClient.sendTransaction({
          to: destination,
          value: transferAmount,
        });

        const receipt = await this.publicClient.waitForTransactionReceipt({ hash });
        totalGasUsed += receipt.gasUsed;

        transfers.push({
          token: '0x0000000000000000000000000000000000000000' as Address,
          amount: transferAmount,
          txHash: hash,
          status: 'success',
        });
      }
    } catch (error) {
      // Native transfer failed, continue
    }

    const successCount = transfers.filter((t) => t.status === 'success').length;
    const status =
      successCount === transfers.length
        ? 'completed'
        : successCount > 0
        ? 'partial'
        : 'failed';

    return {
      sweepId,
      sourceWallet: account.address,
      destinationWallet: destination,
      transfers,
      totalValueUsd: 0, // Would need price oracle
      gasUsed: totalGasUsed,
      gasPrice,
      timestamp: Date.now(),
      status,
    };
  }

  /**
   * Execute batch sweep from multiple wallets
   */
  async batchSweep(
    walletKeys: `0x${string}`[],
    destination: Address,
    tokens: TokenConfig[],
    options?: {
      batchSize?: number;
      delayMs?: number;
    }
  ): Promise<SweepResult[]> {
    const results: SweepResult[] = [];
    const batchSize = options?.batchSize || 5;
    const delayMs = options?.delayMs || 1000;

    for (let i = 0; i < walletKeys.length; i += batchSize) {
      const batch = walletKeys.slice(i, i + batchSize);
      
      const batchResults = await Promise.all(
        batch.map((key) => this.sweepWallet(key, destination, tokens))
      );
      
      results.push(...batchResults);

      // Delay between batches to avoid rate limiting
      if (i + batchSize < walletKeys.length) {
        await new Promise((resolve) => setTimeout(resolve, delayMs));
      }
    }

    return results;
  }

  /**
   * Track transaction status
   */
  async trackTransaction(txHash: Hash): Promise<{
    status: 'pending' | 'confirmed' | 'failed';
    confirmations: number;
    gasUsed?: bigint;
  }> {
    try {
      const receipt = await this.publicClient.getTransactionReceipt({ hash: txHash });
      const block = await this.publicClient.getBlockNumber();
      
      return {
        status: receipt.status === 'success' ? 'confirmed' : 'failed',
        confirmations: Number(block - receipt.blockNumber),
        gasUsed: receipt.gasUsed,
      };
    } catch {
      return {
        status: 'pending',
        confirmations: 0,
      };
    }
  }

  private getChainById(chainId: number): Chain {
    const chains: Record<number, Chain> = {
      1: mainnet,
      8453: base,
      42161: arbitrum,
      10: optimism,
      137: polygon,
    };
    return chains[chainId] || mainnet;
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// Quote Generation
// ═══════════════════════════════════════════════════════════════════════════

export interface SweepQuote {
  sourceWallets: Address[];
  destination: Address;
  estimatedGas: bigint;
  estimatedGasPrice: bigint;
  estimatedCostUsd: number;
  tokens: Array<{
    address: Address;
    symbol: string;
    amount: bigint;
    valueUsd: number;
  }>;
  totalValueUsd: number;
  netValueUsd: number;
}

export async function generateSweepQuote(
  chainId: number,
  sourceWallets: Address[],
  destination: Address,
  tokens: Address[]
): Promise<SweepQuote> {
  const service = new SweepService(chainId);
  const plan = await service.planConsolidation(sourceWallets, destination, tokens);

  // In production, fetch actual prices
  const mockPriceUsd = 1.0;

  const tokenDetails = plan.tokens.map((t) => ({
    address: t.address,
    symbol: t.symbol,
    amount: t.totalAmount,
    valueUsd: Number(formatUnits(t.totalAmount, 18)) * mockPriceUsd,
  }));

  const totalValueUsd = tokenDetails.reduce((sum, t) => sum + t.valueUsd, 0);
  const estimatedGasPrice = parseUnits('30', 9); // 30 gwei
  const estimatedCostUsd = Number(formatUnits(plan.estimatedGas * estimatedGasPrice, 18)) * 2500; // ETH price

  return {
    sourceWallets,
    destination,
    estimatedGas: plan.estimatedGas,
    estimatedGasPrice,
    estimatedCostUsd,
    tokens: tokenDetails,
    totalValueUsd,
    netValueUsd: totalValueUsd - estimatedCostUsd,
  };
}

// ═══════════════════════════════════════════════════════════════════════════
// Exports
// ═══════════════════════════════════════════════════════════════════════════

export default SweepService;
IMPL

  success "Created sweep logic implementation"
}

# ─────────────────────────────────────────────────────────────────────────────
# Main Execution
# ─────────────────────────────────────────────────────────────────────────────

main() {
  echo ""
  echo "══════════════════════════════════════════════════════════════════"
  echo "  Universal Crypto MCP - Automated TODO Implementation"
  echo "  Generating full implementations for all critical TODOs"
  echo "══════════════════════════════════════════════════════════════════"
  echo ""

  # Run all implementations
  implement_signature_verification
  implement_refund_logic
  implement_price_aggregator
  implement_database_init
  implement_sweep_logic

  echo ""
  log "Running additional implementation scripts..."
  
  # Run the security implementations
  if [[ -f "$SCRIPT_DIR/implement-security.sh" ]]; then
    bash "$SCRIPT_DIR/implement-security.sh"
  fi

  # Run the API implementations
  if [[ -f "$SCRIPT_DIR/implement-api.sh" ]]; then
    bash "$SCRIPT_DIR/implement-api.sh"
  fi

  echo ""
  echo "══════════════════════════════════════════════════════════════════"
  success "All implementations generated!"
  echo "══════════════════════════════════════════════════════════════════"
  echo ""
  echo "Generated files:"
  find "$GENERATED_DIR" -name "*.ts" 2>/dev/null | head -20
  find "$ROOT_DIR/packages/shared" -name "*.ts" -newer "$LOG_FILE" 2>/dev/null | head -20
}

main "$@"
