#!/usr/bin/env node
/**
 * Test Generator
 * 
 * Automatically generates test stubs for all exported functions and classes.
 * Uses vendor code patterns to create meaningful test cases.
 * 
 * Usage: node scripts/generate-tests.mjs [--package <name>] [--overwrite]
 */

import { readdirSync, readFileSync, existsSync, writeFileSync, mkdirSync } from 'fs';
import { join, dirname, basename, relative } from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const ROOT_DIR = dirname(__dirname);
const PACKAGES_DIR = join(ROOT_DIR, 'packages');

const args = process.argv.slice(2);
const PACKAGE_FILTER = args.includes('--package') ? args[args.indexOf('--package') + 1] : null;
const OVERWRITE = args.includes('--overwrite');

// ============================================================
// Code Extraction
// ============================================================

function extractExports(filePath) {
  try {
    const content = readFileSync(filePath, 'utf-8');
    const exports = [];
    
    // Export functions
    const funcRegex = /export\s+(?:async\s+)?function\s+(\w+)\s*(?:<[^>]+>)?\s*\(([^)]*)\)/g;
    let match;
    while ((match = funcRegex.exec(content)) !== null) {
      exports.push({
        type: 'function',
        name: match[1],
        params: match[2].split(',').map(p => p.trim()).filter(Boolean),
      });
    }
    
    // Export classes
    const classRegex = /export\s+(?:abstract\s+)?class\s+(\w+)/g;
    while ((match = classRegex.exec(content)) !== null) {
      exports.push({
        type: 'class',
        name: match[1],
      });
    }
    
    // Export const (arrow functions)
    const constRegex = /export\s+const\s+(\w+)\s*=\s*(?:async\s*)?\([^)]*\)\s*(?::\s*[^=]+)?\s*=>/g;
    while ((match = constRegex.exec(content)) !== null) {
      exports.push({
        type: 'function',
        name: match[1],
      });
    }
    
    return exports;
  } catch (e) {
    return [];
  }
}

// ============================================================
// Test Generation
// ============================================================

function generateTestFile(sourceFile, exports) {
  const relativePath = relative(PACKAGES_DIR, sourceFile);
  const parts = relativePath.split('/');
  const packageName = parts[0];
  const modulePath = parts.slice(1).join('/').replace(/\.ts$/, '');
  
  const lines = [
    `/**`,
    ` * Tests for ${modulePath}`,
    ` * `,
    ` * Auto-generated by generate-tests.mjs`,
    ` */`,
    ``,
    `import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';`,
    ``,
  ];
  
  // Generate imports
  const functionExports = exports.filter(e => e.type === 'function').map(e => e.name);
  const classExports = exports.filter(e => e.type === 'class').map(e => e.name);
  
  if (functionExports.length > 0 || classExports.length > 0) {
    const allExports = [...functionExports, ...classExports];
    lines.push(`import { ${allExports.join(', ')} } from '../${modulePath}';`);
    lines.push(``);
  }
  
  // Generate function tests
  for (const exp of exports.filter(e => e.type === 'function')) {
    lines.push(`describe('${exp.name}', () => {`);
    lines.push(`  it('should be defined', () => {`);
    lines.push(`    expect(${exp.name}).toBeDefined();`);
    lines.push(`  });`);
    lines.push(``);
    lines.push(`  it('should be a function', () => {`);
    lines.push(`    expect(typeof ${exp.name}).toBe('function');`);
    lines.push(`  });`);
    lines.push(``);
    
    // Add parameter-based tests if we have params
    if (exp.params && exp.params.length > 0) {
      lines.push(`  it('should handle valid input', () => {`);
      lines.push(`    // TODO: Add test with valid parameters`);
      lines.push(`    // Parameters: ${exp.params.join(', ')}`);
      lines.push(`  });`);
      lines.push(``);
      lines.push(`  it('should handle invalid input', () => {`);
      lines.push(`    // TODO: Add test with invalid parameters`);
      lines.push(`  });`);
      lines.push(``);
    }
    
    lines.push(`  it('should return expected result', async () => {`);
    lines.push(`    // TODO: Implement actual test`);
    lines.push(`    // const result = await ${exp.name}(...args);`);
    lines.push(`    // expect(result).toEqual(expected);`);
    lines.push(`  });`);
    lines.push(`});`);
    lines.push(``);
  }
  
  // Generate class tests
  for (const exp of exports.filter(e => e.type === 'class')) {
    lines.push(`describe('${exp.name}', () => {`);
    lines.push(`  let instance: ${exp.name};`);
    lines.push(``);
    lines.push(`  beforeEach(() => {`);
    lines.push(`    // TODO: Initialize instance with required params`);
    lines.push(`    // instance = new ${exp.name}(...args);`);
    lines.push(`  });`);
    lines.push(``);
    lines.push(`  afterEach(() => {`);
    lines.push(`    // Cleanup if needed`);
    lines.push(`  });`);
    lines.push(``);
    lines.push(`  it('should be defined', () => {`);
    lines.push(`    expect(${exp.name}).toBeDefined();`);
    lines.push(`  });`);
    lines.push(``);
    lines.push(`  it('should be a constructor', () => {`);
    lines.push(`    expect(typeof ${exp.name}).toBe('function');`);
    lines.push(`  });`);
    lines.push(``);
    lines.push(`  // TODO: Add tests for class methods`);
    lines.push(`});`);
    lines.push(``);
  }
  
  return lines.join('\n');
}

function getTestPath(sourceFile) {
  const dir = dirname(sourceFile);
  const base = basename(sourceFile, '.ts');
  
  // Check for existing test directory patterns
  const testDir = join(dir, '__tests__');
  if (existsSync(testDir)) {
    return join(testDir, `${base}.test.ts`);
  }
  
  // Default to same directory
  return join(dir, `${base}.test.ts`);
}

// ============================================================
// File Discovery
// ============================================================

function findSourceFiles(dir, maxDepth = 6) {
  const files = [];
  
  function walk(currentDir, depth) {
    if (depth > maxDepth) return;
    if (!existsSync(currentDir)) return;
    
    try {
      const entries = readdirSync(currentDir, { withFileTypes: true });
      
      for (const entry of entries) {
        const fullPath = join(currentDir, entry.name);
        
        if (entry.isDirectory()) {
          if (['node_modules', '.git', 'dist', 'build', '__tests__', 'test', 'tests'].includes(entry.name)) {
            continue;
          }
          walk(fullPath, depth + 1);
        } else if (entry.isFile()) {
          if (entry.name.endsWith('.ts') && 
              !entry.name.endsWith('.test.ts') && 
              !entry.name.endsWith('.spec.ts') &&
              !entry.name.endsWith('.d.ts')) {
            files.push(fullPath);
          }
        }
      }
    } catch (e) {
      // Skip
    }
  }
  
  walk(dir, 0);
  return files;
}

// ============================================================
// Main
// ============================================================

async function main() {
  console.log('ğŸ§ª Generating test files...\n');
  
  let packagesDir = PACKAGES_DIR;
  if (PACKAGE_FILTER) {
    packagesDir = join(PACKAGES_DIR, PACKAGE_FILTER);
    if (!existsSync(packagesDir)) {
      console.error(`âŒ Package not found: ${PACKAGE_FILTER}`);
      process.exit(1);
    }
  }
  
  const sourceFiles = findSourceFiles(packagesDir);
  console.log(`ğŸ“ Found ${sourceFiles.length} source files`);
  
  let created = 0;
  let skipped = 0;
  
  for (const sourceFile of sourceFiles) {
    const exports = extractExports(sourceFile);
    
    if (exports.length === 0) {
      continue;
    }
    
    const testPath = getTestPath(sourceFile);
    
    if (existsSync(testPath) && !OVERWRITE) {
      skipped++;
      continue;
    }
    
    const testContent = generateTestFile(sourceFile, exports);
    
    // Ensure directory exists
    mkdirSync(dirname(testPath), { recursive: true });
    
    writeFileSync(testPath, testContent);
    console.log(`   âœ… ${relative(ROOT_DIR, testPath)}`);
    created++;
  }
  
  console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  console.log(`ğŸ“Š Summary:`);
  console.log(`   Created: ${created} test files`);
  console.log(`   Skipped: ${skipped} (already exist)`);
  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
}

main().catch(console.error);
