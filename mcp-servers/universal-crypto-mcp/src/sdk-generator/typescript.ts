/**
 * TypeScript/JavaScript SDK Generator
 * Generates client SDKs for x402-enabled APIs
 *
 * @author nich
 * @github github.com/nirholas
 * @license Apache-2.0
 */

import {
  SDKConfig,
  SDKGenerationResult,
  toPascalCase,
  toCamelCase,
  extractPathParams,
} from './types.js';

/**
 * Generate route method name from HTTP method and path
 */
function routeToMethodName(method: string, path: string): string {
  const parts = path.split('/').filter(p => p && !p.startsWith(':'));
  const name = parts.map(p => toPascalCase(p)).join('');
  return method.toLowerCase() + (name.charAt(0).toUpperCase() + name.slice(1));
}

/**
 * Generate TypeScript route methods
 */
function generateRouteMethodsTS(routes: Record<string, string>): string {
  const methods: string[] = [];

  for (const [route, price] of Object.entries(routes)) {
    const [method, path] = route.split(' ');
    const methodName = routeToMethodName(method, path);
    const params = extractPathParams(path);

    const paramList = params.length > 0
      ? params.map(p => `${p}: string`).join(', ') + ', '
      : '';

    const bodyParam = ['POST', 'PUT', 'PATCH'].includes(method) ? 'body?: any' : '';
    const fullParams = paramList + bodyParam;

    const pathWithParams = params.reduce(
      (p, param) => p.replace(`:${param}`, `\${${param}}`),
      path
    );

    methods.push(`
  /**
   * ${method} ${path}
   * Price: $${price}
   */
  async ${methodName}(${fullParams}): Promise<any> {
    return this.makeRequest(
      '${method}',
      \`${pathWithParams}\`,
      '${price}'${bodyParam ? ', body' : ''}
    );
  }`.trim());
  }

  return methods.join('\n\n  ');
}

/**
 * Generate a TypeScript/JavaScript SDK for the given configuration
 */
export function generateTypeScriptSDK(config: SDKConfig): SDKGenerationResult {
  const clientName = toPascalCase(config.apiName);
  const instanceName = toCamelCase(config.apiName);

  const code = `/**
 * ${config.apiName} TypeScript SDK
 * Auto-generated by x402-deploy
 *
 * @see https://x402.org
 */

import { createPublicClient, http } from 'viem';
import { base } from 'viem/chains';

export interface ${clientName}Options {
  /** Custom facilitator URL */
  facilitatorUrl?: string;
  /** Payer private key for automatic payments */
  payerPrivateKey?: \`0x\${string}\`;
}

export interface PaymentProof {
  /** Cryptographic signature */
  signature: string;
  /** Timestamp of the payment */
  timestamp: number;
  /** Amount paid in USD */
  amount: string;
  /** Network identifier (e.g., "eip155:8453") */
  network: string;
}

export interface APIResponse<T = any> {
  /** Response data */
  data: T;
  /** Request metadata */
  meta?: {
    requestId: string;
    timestamp: string;
  };
}

export class ${clientName}Client {
  private apiUrl: string;
  private facilitatorUrl: string;
  private payerPrivateKey?: \`0x\${string}\`;
  private wallet: \`0x\${string}\`;

  constructor(options: ${clientName}Options = {}) {
    this.apiUrl = '${config.apiUrl}';
    this.facilitatorUrl = options.facilitatorUrl || '${config.facilitator}';
    this.payerPrivateKey = options.payerPrivateKey;
    this.wallet = '${config.wallet}';
  }

  /**
   * Get payment proof from facilitator
   */
  private async getPaymentProof(route: string, price: string): Promise<string> {
    const response = await fetch(\`\${this.facilitatorUrl}/create-payment\`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        recipient: this.wallet,
        amount: price,
        network: 'eip155:8453',
        route,
        ...(this.payerPrivateKey && { payerKey: this.payerPrivateKey })
      })
    });

    if (!response.ok) {
      throw new Error(\`Failed to get payment proof: \${response.status} \${await response.text()}\`);
    }

    const { proof } = await response.json();
    return proof;
  }

  /**
   * Make an authenticated request to the API
   */
  private async makeRequest(
    method: string,
    path: string,
    price: string,
    body?: any
  ): Promise<any> {
    const proof = await this.getPaymentProof(\`\${method} \${path}\`, price);

    const response = await fetch(\`\${this.apiUrl}\${path}\`, {
      method,
      headers: {
        'Content-Type': 'application/json',
        'x-payment': proof
      },
      ...(body && { body: JSON.stringify(body) })
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(\`API error: \${response.status} \${errorText}\`);
    }

    return response.json();
  }

  /**
   * Get the x402 discovery document
   */
  async getDiscovery(): Promise<any> {
    const response = await fetch(\`\${this.apiUrl}/.well-known/x402\`);
    return response.json();
  }

  ${generateRouteMethodsTS(config.routes)}
}

// Export default client instance
export const ${instanceName} = new ${clientName}Client();

// Export types
export type { ${clientName}Options, PaymentProof, APIResponse };
`;

  return {
    language: 'typescript',
    code,
    extension: 'ts',
    directory: 'typescript'
  };
}
