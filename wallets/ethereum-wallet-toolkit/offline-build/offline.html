<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ethereum Wallet Toolkit - Offline</title>
<style>
:root { --bg: #000; --fg: #fff; --border: #333; --muted: #888; --warn: #fa0; }
@media (prefers-color-scheme: light) { :root { --bg: #fff; --fg: #000; --border: #ccc; --muted: #666; } }
* { box-sizing: border-box; margin: 0; padding: 0; }
body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace; background: var(--bg); color: var(--fg); min-height: 100vh; padding: 1rem; line-height: 1.5; }
.container { max-width: 900px; margin: 0 auto; }
h1 { font-size: 1.5rem; margin-bottom: 0.5rem; font-weight: 600; }
.subtitle { color: var(--muted); font-size: 0.85rem; margin-bottom: 1rem; }
.security-banner { background: var(--bg); border: 2px solid var(--fg); padding: 1rem; margin-bottom: 1rem; font-size: 0.8rem; }
.security-banner .status { display: flex; flex-wrap: wrap; gap: 1rem; margin-top: 0.5rem; }
.security-banner .check { display: flex; align-items: center; gap: 0.25rem; }
.security-banner .check.pass::before { content: '✓'; color: #0f0; }
.security-banner .check.fail::before { content: '✗'; color: #f00; }
.security-banner .check.pending::before { content: '○'; color: var(--muted); }
.tabs { display: flex; flex-wrap: wrap; gap: 0.25rem; margin-bottom: 1rem; border-bottom: 1px solid var(--border); padding-bottom: 0.5rem; }
.tab { background: transparent; border: 1px solid var(--border); color: var(--fg); padding: 0.5rem 1rem; cursor: pointer; font-size: 0.85rem; transition: all 0.2s; }
.tab:hover { background: var(--fg); color: var(--bg); }
.tab.active { background: var(--fg); color: var(--bg); }
.panel { display: none; padding: 1rem 0; }
.panel.active { display: block; }
.section { margin-bottom: 1.5rem; padding: 1rem; border: 1px solid var(--border); }
.section-title { font-size: 1rem; font-weight: 600; margin-bottom: 1rem; padding-bottom: 0.5rem; border-bottom: 1px solid var(--border); }
.form-group { margin-bottom: 1rem; }
label { display: block; font-size: 0.85rem; margin-bottom: 0.25rem; color: var(--muted); }
input, textarea, select { width: 100%; padding: 0.75rem; background: var(--bg); border: 1px solid var(--border); color: var(--fg); font-family: monospace; font-size: 0.9rem; }
input:focus, textarea:focus, select:focus { outline: none; border-color: var(--fg); }
textarea { min-height: 100px; resize: vertical; }
.btn { display: inline-block; padding: 0.75rem 1.5rem; background: var(--fg); color: var(--bg); border: none; cursor: pointer; font-size: 0.9rem; font-weight: 500; transition: opacity 0.2s; }
.btn:hover { opacity: 0.8; }
.btn:disabled { opacity: 0.5; cursor: not-allowed; }
.btn-secondary { background: transparent; color: var(--fg); border: 1px solid var(--fg); }
.btn-small { padding: 0.5rem 1rem; font-size: 0.8rem; }
.result { margin-top: 1rem; padding: 1rem; border: 1px solid var(--border); background: var(--bg); }
.result-title { font-size: 0.75rem; color: var(--muted); margin-bottom: 0.25rem; text-transform: uppercase; }
.result-value { font-family: monospace; word-break: break-all; margin-bottom: 1rem; }
.result-value:last-child { margin-bottom: 0; }
.result-value.blurred { filter: blur(5px); cursor: pointer; transition: filter 0.2s; user-select: none; }
.result-value.blurred:hover { filter: blur(3px); }
.result-value.blurred.revealed { filter: none; user-select: text; }
.error { color: #f00; }
.success { color: #0f0; }
.warning { color: var(--warn); }
.row { display: flex; gap: 1rem; flex-wrap: wrap; }
.row > * { flex: 1; min-width: 200px; }
.checkbox-group { display: flex; align-items: center; gap: 0.5rem; }
.checkbox-group input { width: auto; }
.hidden { display: none; }
.key-warning { background: var(--bg); border: 1px solid var(--warn); color: var(--warn); padding: 0.5rem; margin-top: 0.5rem; font-size: 0.75rem; }
@media (max-width: 600px) { .tabs { gap: 0.5rem; } .tab { padding: 0.4rem 0.6rem; font-size: 0.75rem; } }
</style>
</head>
<body>
<div class="container">
<h1>Ethereum Wallet Toolkit</h1>
<p class="subtitle">Offline • Official ethereumjs Libraries • Air-gap Recommended</p>

<div class="security-banner">
<strong>Security Verification</strong>
<div class="status">
<span class="check pending" id="check-offline">Offline Status</span>
<span class="check pending" id="check-crypto">Crypto API</span>
<span class="check pending" id="check-vectors">Test Vectors</span>
<span class="check pending" id="check-entropy">Entropy Quality</span>
</div>
<div style="margin-top:0.5rem;font-size:0.75rem;color:var(--muted);">
File Hash: <code id="file-hash">Calculating...</code>
</div>
</div>

<div class="tabs">
<button class="tab active" data-tab="generate">Generate</button>
<button class="tab" data-tab="mnemonic">Mnemonic</button>
<button class="tab" data-tab="vanity">Vanity</button>
<button class="tab" data-tab="sign">Sign</button>
<button class="tab" data-tab="verify">Verify</button>
<button class="tab" data-tab="validate">Validate</button>
<button class="tab" data-tab="keystore">Keystore</button>
<button class="tab" data-tab="transaction">Transaction</button>
<button class="tab" data-tab="typed">EIP-712</button>
</div>

<!-- Generate Panel -->
<div class="panel active" id="panel-generate">
<div class="section">
<div class="section-title">Generate New Wallet</div>
<p style="color:var(--muted);font-size:0.85rem;margin-bottom:1rem;">Uses cryptographically secure random number generator (CSPRNG). For maximum security, use on an air-gapped machine.</p>
<div class="checkbox-group" style="margin-bottom:1rem;">
<input type="checkbox" id="gen-verify" checked>
<label for="gen-verify">Double-verify derivation (recommended)</label>
</div>
<button class="btn" onclick="generateWallet()">Generate Random Wallet</button>
<div id="generate-result" class="result hidden"></div>
</div>
<div class="section">
<div class="section-title">Import Private Key</div>
<div class="form-group">
<label>Private Key (with or without 0x prefix)</label>
<input type="password" id="import-key" placeholder="Enter private key...">
</div>
<button class="btn" onclick="importWallet()">Import</button>
<div id="import-result" class="result hidden"></div>
</div>
</div>

<!-- Mnemonic Panel -->
<div class="panel" id="panel-mnemonic">
<div class="section">
<div class="section-title">Generate New Mnemonic</div>
<div class="form-group">
<label>Word Count</label>
<select id="mnemonic-words">
<option value="12">12 words</option>
<option value="15">15 words</option>
<option value="18">18 words</option>
<option value="21">21 words</option>
<option value="24" selected>24 words</option>
</select>
</div>
<button class="btn" onclick="generateMnemonic()">Generate Mnemonic</button>
<div id="mnemonic-generate-result" class="result hidden"></div>
</div>
<div class="section">
<div class="section-title">Recover from Mnemonic</div>
<div class="form-group">
<label>Mnemonic Phrase</label>
<textarea id="mnemonic-phrase" placeholder="Enter 12, 15, 18, 21, or 24 word mnemonic..."></textarea>
</div>
<div class="form-group">
<label>Passphrase (BIP39 - HIGHLY RECOMMENDED for high-value wallets)</label>
<input type="password" id="mnemonic-passphrase" placeholder="Adds extra security + plausible deniability">
<div style="font-size:0.75rem;color:var(--warn);margin-top:0.25rem;">⚠ A passphrase creates a completely different wallet. Same mnemonic + different passphrase = different addresses. Provides plausible deniability.</div>
</div>
<div class="row">
<div class="form-group">
<label>Derivation Path</label>
<input type="text" id="mnemonic-path" value="m/44'/60'/0'/0" placeholder="m/44'/60'/0'/0">
</div>
<div class="form-group">
<label>Number of Accounts</label>
<input type="number" id="mnemonic-count" value="5" min="1" max="100">
</div>
</div>
<button class="btn" onclick="recoverMnemonic()">Recover Accounts</button>
<div id="mnemonic-recover-result" class="result hidden"></div>
</div>
</div>

<!-- Vanity Panel -->
<div class="panel" id="panel-vanity">
<div class="section">
<div class="section-title">Vanity Address Generator</div>
<p style="color: var(--muted); font-size: 0.85rem; margin-bottom: 1rem;">Generate addresses matching a pattern. Longer patterns take exponentially longer.</p>
<div class="row">
<div class="form-group">
<label>Prefix (after 0x)</label>
<input type="text" id="vanity-prefix" placeholder="e.g., dead" maxlength="10">
</div>
<div class="form-group">
<label>Suffix</label>
<input type="text" id="vanity-suffix" placeholder="e.g., beef" maxlength="10">
</div>
</div>
<div class="row">
<div class="form-group">
<label>Contains</label>
<input type="text" id="vanity-contains" placeholder="Address must contain this">
</div>
<div class="form-group">
<label>Regex Pattern</label>
<input type="text" id="vanity-regex" placeholder="e.g., ^dead.*beef$">
</div>
</div>
<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:0.5rem;margin:1rem 0;">
<div class="checkbox-group"><input type="checkbox" id="vanity-case"><label for="vanity-case">Case-sensitive (EIP-55)</label></div>
<div class="checkbox-group"><input type="checkbox" id="vanity-letters"><label for="vanity-letters">Letters only (a-f)</label></div>
<div class="checkbox-group"><input type="checkbox" id="vanity-numbers"><label for="vanity-numbers">Numbers only (0-9)</label></div>
<div class="checkbox-group"><input type="checkbox" id="vanity-mirror"><label for="vanity-mirror">Mirror/Palindrome</label></div>
<div class="checkbox-group"><input type="checkbox" id="vanity-doubles"><label for="vanity-doubles">Leading doubles (aa, bb...)</label></div>
<div class="checkbox-group"><input type="checkbox" id="vanity-zeros"><label for="vanity-zeros">Many zeros (8+)</label></div>
<div class="checkbox-group"><input type="checkbox" id="vanity-contract"><label for="vanity-contract">Contract address</label></div>
</div>
<div class="row">
<div class="form-group">
<label>Leading Character</label>
<input type="text" id="vanity-leading" placeholder="e.g., 0" maxlength="1">
</div>
<div class="form-group">
<label>Leading Count</label>
<input type="number" id="vanity-leading-count" value="4" min="1" max="20">
</div>
</div>
<div class="row">
<div class="form-group">
<label>Find Count</label>
<input type="number" id="vanity-count" value="1" min="1" max="100">
</div>
<div class="form-group">
<label>Estimated Difficulty</label>
<input type="text" id="vanity-difficulty" readonly placeholder="Enter criteria above">
</div>
</div>
<button class="btn" onclick="startVanity()">Start Search</button>
<button class="btn btn-secondary" onclick="stopVanity()">Stop</button>
<button class="btn btn-secondary" onclick="exportVanityResults()" id="vanity-export-btn" disabled>Export Results</button>
<div id="vanity-result" class="result hidden"></div>
</div>
<div class="section">
<div class="section-title">Contract Address Calculator</div>
<div class="form-group">
<label>Deployer Address</label>
<input type="text" id="contract-deployer" placeholder="0x...">
</div>
<div class="form-group">
<label>Nonce</label>
<input type="number" id="contract-nonce" value="0" min="0">
</div>
<button class="btn" onclick="calculateContract()">Calculate</button>
<div id="contract-result" class="result hidden"></div>
</div>
</div>

<!-- Sign Panel -->
<div class="panel" id="panel-sign">
<div class="section">
<div class="section-title">Sign Message</div>
<div class="form-group">
<label>Message</label>
<textarea id="sign-message" placeholder="Enter message to sign..."></textarea>
</div>
<div class="form-group">
<label>Private Key</label>
<input type="password" id="sign-key" placeholder="Private key to sign with...">
</div>
<div class="checkbox-group" style="margin-bottom: 1rem;">
<input type="checkbox" id="sign-eth-prefix" checked>
<label for="sign-eth-prefix" style="margin: 0;">Use Ethereum Signed Message prefix (EIP-191)</label>
</div>
<button class="btn" onclick="signMessage()">Sign Message</button>
<div id="sign-result" class="result hidden"></div>
</div>
</div>

<!-- Verify Panel -->
<div class="panel" id="panel-verify">
<div class="section">
<div class="section-title">Verify Signature</div>
<div class="form-group">
<label>Message</label>
<textarea id="verify-message" placeholder="Enter the original message..."></textarea>
</div>
<div class="form-group">
<label>Signature</label>
<input type="text" id="verify-signature" placeholder="0x... signature">
</div>
<div class="form-group">
<label>Expected Address (optional)</label>
<input type="text" id="verify-address" placeholder="0x... address to verify against">
</div>
<div class="checkbox-group" style="margin-bottom: 1rem;">
<input type="checkbox" id="verify-eth-prefix" checked>
<label for="verify-eth-prefix" style="margin: 0;">Message has Ethereum prefix (EIP-191)</label>
</div>
<button class="btn" onclick="verifySignature()">Verify</button>
<div id="verify-result" class="result hidden"></div>
</div>
<div class="section">
<div class="section-title">Verify Address/Key Pair</div>
<div class="form-group">
<label>Address</label>
<input type="text" id="pair-address" placeholder="0x...">
</div>
<div class="form-group">
<label>Private Key</label>
<input type="password" id="pair-key" placeholder="Private key...">
</div>
<button class="btn" onclick="verifyPair()">Verify Pair</button>
<div id="pair-result" class="result hidden"></div>
</div>
</div>

<!-- Validate Panel -->
<div class="panel" id="panel-validate">
<div class="section">
<div class="section-title">Validate Address</div>
<div class="form-group">
<label>Address</label>
<input type="text" id="validate-address" placeholder="0x...">
</div>
<button class="btn" onclick="validateAddress()">Validate</button>
<div id="validate-address-result" class="result hidden"></div>
</div>
<div class="section">
<div class="section-title">Validate Private Key</div>
<div class="form-group">
<label>Private Key</label>
<input type="password" id="validate-key" placeholder="Private key...">
</div>
<button class="btn" onclick="validateKey()">Validate</button>
<div id="validate-key-result" class="result hidden"></div>
</div>
<div class="section">
<div class="section-title">Checksum Address</div>
<div class="form-group">
<label>Address</label>
<input type="text" id="checksum-address" placeholder="0x...">
</div>
<button class="btn" onclick="checksumAddress()">Convert to Checksum</button>
<div id="checksum-result" class="result hidden"></div>
</div>
</div>

<!-- Keystore Panel -->
<div class="panel" id="panel-keystore">
<div class="section">
<div class="section-title">Encrypt to Keystore (V3)</div>
<div class="form-group">
<label>Private Key</label>
<input type="password" id="keystore-encrypt-key" placeholder="Private key to encrypt...">
</div>
<div class="form-group">
<label>Password</label>
<input type="password" id="keystore-encrypt-password" placeholder="Encryption password (min 8 chars)...">
</div>
<div class="form-group">
<label>Confirm Password</label>
<input type="password" id="keystore-encrypt-confirm" placeholder="Confirm password...">
</div>
<button class="btn" onclick="encryptKeystore()">Encrypt</button>
<div id="keystore-encrypt-result" class="result hidden"></div>
</div>
<div class="section">
<div class="section-title">Decrypt Keystore</div>
<div class="form-group">
<label>Keystore JSON</label>
<textarea id="keystore-decrypt-json" placeholder="Paste keystore JSON..."></textarea>
</div>
<div class="form-group">
<label>Password</label>
<input type="password" id="keystore-decrypt-password" placeholder="Decryption password...">
</div>
<button class="btn" onclick="decryptKeystore()">Decrypt</button>
<div id="keystore-decrypt-result" class="result hidden"></div>
</div>
</div>

<!-- Transaction Panel -->
<div class="panel" id="panel-transaction">
<div class="section">
<div class="section-title">Sign Transaction</div>
<div class="row">
<div class="form-group">
<label>To Address</label>
<input type="text" id="tx-to" placeholder="0x...">
</div>
<div class="form-group">
<label>Value (wei)</label>
<input type="text" id="tx-value" placeholder="0" value="0">
</div>
</div>
<div class="row">
<div class="form-group">
<label>Nonce</label>
<input type="number" id="tx-nonce" value="0" min="0">
</div>
<div class="form-group">
<label>Gas Limit</label>
<input type="number" id="tx-gas" value="21000" min="21000">
</div>
<div class="form-group">
<label>Chain ID</label>
<input type="number" id="tx-chainid" value="1" min="1">
</div>
</div>
<div class="row">
<div class="form-group">
<label>Gas Price (wei) - Legacy</label>
<input type="text" id="tx-gasprice" placeholder="e.g., 20000000000">
</div>
<div class="form-group">
<label>Max Fee (wei) - EIP-1559</label>
<input type="text" id="tx-maxfee" placeholder="e.g., 30000000000">
</div>
<div class="form-group">
<label>Priority Fee (wei)</label>
<input type="text" id="tx-priorityfee" placeholder="e.g., 2000000000">
</div>
</div>
<div class="form-group">
<label>Data (hex)</label>
<input type="text" id="tx-data" placeholder="0x" value="0x">
</div>
<div class="form-group">
<label>Private Key</label>
<input type="password" id="tx-key" placeholder="Private key to sign with...">
</div>
<button class="btn" onclick="signTransaction()">Sign Transaction</button>
<div id="tx-result" class="result hidden"></div>
</div>
</div>

<!-- EIP-712 Panel -->
<div class="panel" id="panel-typed">
<div class="section">
<div class="section-title">Sign Typed Data (EIP-712)</div>
<div class="form-group">
<label>Typed Data JSON</label>
<textarea id="typed-data" rows="10" placeholder='{"types":{"EIP712Domain":[...],"Person":[...]},"primaryType":"Person","domain":{...},"message":{...}}'></textarea>
</div>
<div class="form-group">
<label>Private Key</label>
<input type="password" id="typed-key" placeholder="Private key to sign with...">
</div>
<button class="btn" onclick="signTypedData()">Sign</button>
<div id="typed-sign-result" class="result hidden"></div>
</div>
<div class="section">
<div class="section-title">Verify Typed Data Signature</div>
<div class="form-group">
<label>Typed Data JSON</label>
<textarea id="typed-verify-data" rows="10" placeholder="Same typed data JSON used for signing..."></textarea>
</div>
<div class="form-group">
<label>Signature</label>
<input type="text" id="typed-verify-sig" placeholder="0x... signature">
</div>
<div class="form-group">
<label>Expected Address (optional)</label>
<input type="text" id="typed-verify-address" placeholder="0x...">
</div>
<button class="btn" onclick="verifyTypedData()">Verify</button>
<div id="typed-verify-result" class="result hidden"></div>
</div>
</div>
</div>

<script>
var EthWallet = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod3) => function __require() {
    return mod3 || (0, cb[__getOwnPropNames(cb)[0]])((mod3 = { exports: {} }).exports, mod3), mod3.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod3, isNodeMode, target) => (target = mod3 != null ? __create(__getProtoOf(mod3)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod3 || !mod3.__esModule ? __defProp(target, "default", { value: mod3, enumerable: true }) : target,
    mod3
  ));
  var __toCommonJS = (mod3) => __copyProps(__defProp({}, "__esModule", { value: true }), mod3);

  // node_modules/events/events.js
  var require_events = __commonJS({
    "node_modules/events/events.js"(exports, module2) {
      "use strict";
      var R = typeof Reflect === "object" ? Reflect : null;
      var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
        return Function.prototype.apply.call(target, receiver, args);
      };
      var ReflectOwnKeys;
      if (R && typeof R.ownKeys === "function") {
        ReflectOwnKeys = R.ownKeys;
      } else if (Object.getOwnPropertySymbols) {
        ReflectOwnKeys = function ReflectOwnKeys2(target) {
          return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
        };
      } else {
        ReflectOwnKeys = function ReflectOwnKeys2(target) {
          return Object.getOwnPropertyNames(target);
        };
      }
      function ProcessEmitWarning(warning) {
        if (console && console.warn) console.warn(warning);
      }
      var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
        return value !== value;
      };
      function EventEmitter3() {
        EventEmitter3.init.call(this);
      }
      module2.exports = EventEmitter3;
      module2.exports.once = once;
      EventEmitter3.EventEmitter = EventEmitter3;
      EventEmitter3.prototype._events = void 0;
      EventEmitter3.prototype._eventsCount = 0;
      EventEmitter3.prototype._maxListeners = void 0;
      var defaultMaxListeners = 10;
      function checkListener(listener) {
        if (typeof listener !== "function") {
          throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
        }
      }
      Object.defineProperty(EventEmitter3, "defaultMaxListeners", {
        enumerable: true,
        get: function() {
          return defaultMaxListeners;
        },
        set: function(arg) {
          if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
          }
          defaultMaxListeners = arg;
        }
      });
      EventEmitter3.init = function() {
        if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        }
        this._maxListeners = this._maxListeners || void 0;
      };
      EventEmitter3.prototype.setMaxListeners = function setMaxListeners(n) {
        if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
          throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
        }
        this._maxListeners = n;
        return this;
      };
      function _getMaxListeners(that) {
        if (that._maxListeners === void 0)
          return EventEmitter3.defaultMaxListeners;
        return that._maxListeners;
      }
      EventEmitter3.prototype.getMaxListeners = function getMaxListeners() {
        return _getMaxListeners(this);
      };
      EventEmitter3.prototype.emit = function emit(type) {
        var args = [];
        for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
        var doError = type === "error";
        var events = this._events;
        if (events !== void 0)
          doError = doError && events.error === void 0;
        else if (!doError)
          return false;
        if (doError) {
          var er;
          if (args.length > 0)
            er = args[0];
          if (er instanceof Error) {
            throw er;
          }
          var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
          err.context = er;
          throw err;
        }
        var handler = events[type];
        if (handler === void 0)
          return false;
        if (typeof handler === "function") {
          ReflectApply(handler, this, args);
        } else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i)
            ReflectApply(listeners[i], this, args);
        }
        return true;
      };
      function _addListener(target, type, listener, prepend) {
        var m;
        var events;
        var existing;
        checkListener(listener);
        events = target._events;
        if (events === void 0) {
          events = target._events = /* @__PURE__ */ Object.create(null);
          target._eventsCount = 0;
        } else {
          if (events.newListener !== void 0) {
            target.emit(
              "newListener",
              type,
              listener.listener ? listener.listener : listener
            );
            events = target._events;
          }
          existing = events[type];
        }
        if (existing === void 0) {
          existing = events[type] = listener;
          ++target._eventsCount;
        } else {
          if (typeof existing === "function") {
            existing = events[type] = prepend ? [listener, existing] : [existing, listener];
          } else if (prepend) {
            existing.unshift(listener);
          } else {
            existing.push(listener);
          }
          m = _getMaxListeners(target);
          if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true;
            var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            w.name = "MaxListenersExceededWarning";
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            ProcessEmitWarning(w);
          }
        }
        return target;
      }
      EventEmitter3.prototype.addListener = function addListener(type, listener) {
        return _addListener(this, type, listener, false);
      };
      EventEmitter3.prototype.on = EventEmitter3.prototype.addListener;
      EventEmitter3.prototype.prependListener = function prependListener(type, listener) {
        return _addListener(this, type, listener, true);
      };
      function onceWrapper() {
        if (!this.fired) {
          this.target.removeListener(this.type, this.wrapFn);
          this.fired = true;
          if (arguments.length === 0)
            return this.listener.call(this.target);
          return this.listener.apply(this.target, arguments);
        }
      }
      function _onceWrap(target, type, listener) {
        var state = { fired: false, wrapFn: void 0, target, type, listener };
        var wrapped = onceWrapper.bind(state);
        wrapped.listener = listener;
        state.wrapFn = wrapped;
        return wrapped;
      }
      EventEmitter3.prototype.once = function once2(type, listener) {
        checkListener(listener);
        this.on(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter3.prototype.prependOnceListener = function prependOnceListener(type, listener) {
        checkListener(listener);
        this.prependListener(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter3.prototype.removeListener = function removeListener(type, listener) {
        var list, events, position, i, originalListener;
        checkListener(listener);
        events = this._events;
        if (events === void 0)
          return this;
        list = events[type];
        if (list === void 0)
          return this;
        if (list === listener || list.listener === listener) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else {
            delete events[type];
            if (events.removeListener)
              this.emit("removeListener", type, list.listener || listener);
          }
        } else if (typeof list !== "function") {
          position = -1;
          for (i = list.length - 1; i >= 0; i--) {
            if (list[i] === listener || list[i].listener === listener) {
              originalListener = list[i].listener;
              position = i;
              break;
            }
          }
          if (position < 0)
            return this;
          if (position === 0)
            list.shift();
          else {
            spliceOne(list, position);
          }
          if (list.length === 1)
            events[type] = list[0];
          if (events.removeListener !== void 0)
            this.emit("removeListener", type, originalListener || listener);
        }
        return this;
      };
      EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
      EventEmitter3.prototype.removeAllListeners = function removeAllListeners(type) {
        var listeners, events, i;
        events = this._events;
        if (events === void 0)
          return this;
        if (events.removeListener === void 0) {
          if (arguments.length === 0) {
            this._events = /* @__PURE__ */ Object.create(null);
            this._eventsCount = 0;
          } else if (events[type] !== void 0) {
            if (--this._eventsCount === 0)
              this._events = /* @__PURE__ */ Object.create(null);
            else
              delete events[type];
          }
          return this;
        }
        if (arguments.length === 0) {
          var keys = Object.keys(events);
          var key;
          for (i = 0; i < keys.length; ++i) {
            key = keys[i];
            if (key === "removeListener") continue;
            this.removeAllListeners(key);
          }
          this.removeAllListeners("removeListener");
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
          return this;
        }
        listeners = events[type];
        if (typeof listeners === "function") {
          this.removeListener(type, listeners);
        } else if (listeners !== void 0) {
          for (i = listeners.length - 1; i >= 0; i--) {
            this.removeListener(type, listeners[i]);
          }
        }
        return this;
      };
      function _listeners(target, type, unwrap) {
        var events = target._events;
        if (events === void 0)
          return [];
        var evlistener = events[type];
        if (evlistener === void 0)
          return [];
        if (typeof evlistener === "function")
          return unwrap ? [evlistener.listener || evlistener] : [evlistener];
        return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
      }
      EventEmitter3.prototype.listeners = function listeners(type) {
        return _listeners(this, type, true);
      };
      EventEmitter3.prototype.rawListeners = function rawListeners(type) {
        return _listeners(this, type, false);
      };
      EventEmitter3.listenerCount = function(emitter, type) {
        if (typeof emitter.listenerCount === "function") {
          return emitter.listenerCount(type);
        } else {
          return listenerCount.call(emitter, type);
        }
      };
      EventEmitter3.prototype.listenerCount = listenerCount;
      function listenerCount(type) {
        var events = this._events;
        if (events !== void 0) {
          var evlistener = events[type];
          if (typeof evlistener === "function") {
            return 1;
          } else if (evlistener !== void 0) {
            return evlistener.length;
          }
        }
        return 0;
      }
      EventEmitter3.prototype.eventNames = function eventNames() {
        return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
      };
      function arrayClone(arr, n) {
        var copy = new Array(n);
        for (var i = 0; i < n; ++i)
          copy[i] = arr[i];
        return copy;
      }
      function spliceOne(list, index) {
        for (; index + 1 < list.length; index++)
          list[index] = list[index + 1];
        list.pop();
      }
      function unwrapListeners(arr) {
        var ret = new Array(arr.length);
        for (var i = 0; i < ret.length; ++i) {
          ret[i] = arr[i].listener || arr[i];
        }
        return ret;
      }
      function once(emitter, name) {
        return new Promise(function(resolve, reject) {
          function errorListener(err) {
            emitter.removeListener(name, resolver);
            reject(err);
          }
          function resolver() {
            if (typeof emitter.removeListener === "function") {
              emitter.removeListener("error", errorListener);
            }
            resolve([].slice.call(arguments));
          }
          ;
          eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
          if (name !== "error") {
            addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
          }
        });
      }
      function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
        if (typeof emitter.on === "function") {
          eventTargetAgnosticAddListener(emitter, "error", handler, flags);
        }
      }
      function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
        if (typeof emitter.on === "function") {
          if (flags.once) {
            emitter.once(name, listener);
          } else {
            emitter.on(name, listener);
          }
        } else if (typeof emitter.addEventListener === "function") {
          emitter.addEventListener(name, function wrapListener(arg) {
            if (flags.once) {
              emitter.removeEventListener(name, wrapListener);
            }
            listener(arg);
          });
        } else {
          throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
        }
      }
    }
  });

  // src/wallet.js
  var wallet_exports = {};
  __export(wallet_exports, {
    bytesToHex: () => bytesToHex,
    calculateContractAddress: () => calculateContractAddress,
    checkVanityMatch: () => checkVanityMatch,
    createMnemonic: () => createMnemonic,
    decryptKeystore: () => decryptKeystore,
    deriveAccounts: () => deriveAccounts,
    encryptKeystore: () => encryptKeystore,
    generateWallet: () => generateWallet,
    hexToBytes: () => hexToBytes2,
    keccak256: () => keccak256,
    mnemonicToWallet: () => mnemonicToWallet,
    privateKeyToWallet: () => privateKeyToWallet,
    signMessage: () => signMessage,
    signTransaction: () => signTransaction,
    signTypedData: () => signTypedData,
    toChecksumAddress: () => toChecksumAddress,
    utf8ToBytes: () => utf8ToBytes,
    validateAddress: () => validateAddress,
    validateKeyAddressPair: () => validateKeyAddressPair,
    validateMnemonicPhrase: () => validateMnemonicPhrase,
    validatePrivateKey: () => validatePrivateKey,
    verifyMessage: () => verifyMessage,
    verifyTypedData: () => verifyTypedData
  });

  // node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/_assert.js
  function number(n) {
    if (!Number.isSafeInteger(n) || n < 0)
      throw new Error(`positive integer expected, not ${n}`);
  }
  function bool(b) {
    if (typeof b !== "boolean")
      throw new Error(`boolean expected, not ${b}`);
  }
  function isBytes(a) {
    return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
  }
  function bytes(b, ...lengths) {
    if (!isBytes(b))
      throw new Error("Uint8Array expected");
    if (lengths.length > 0 && !lengths.includes(b.length))
      throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
  }
  function hash(h) {
    if (typeof h !== "function" || typeof h.create !== "function")
      throw new Error("Hash should be wrapped by utils.wrapConstructor");
    number(h.outputLen);
    number(h.blockLen);
  }
  function exists(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
  }
  var assert = { number, bool, bytes, hash, exists, output };
  var assert_default = assert;

  // node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/_u64.js
  var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
  var _32n = /* @__PURE__ */ BigInt(32);
  function fromBig(n, le = false) {
    if (le)
      return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
    return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
  }
  function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
      const { h, l } = fromBig(lst[i], le);
      [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
  }
  var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
  var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
  var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
  var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;

  // node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/crypto.js
  var crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

  // node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/utils.js
  var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
  var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  var rotr = (word, shift) => word << 32 - shift | word >>> shift;
  var rotl = (word, shift) => word << shift | word >>> 32 - shift >>> 0;
  var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  var byteSwap = (word) => word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
  function byteSwap32(arr) {
    for (let i = 0; i < arr.length; i++) {
      arr[i] = byteSwap(arr[i]);
    }
  }
  var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
  function bytesToHex(bytes2) {
    bytes(bytes2);
    let hex = "";
    for (let i = 0; i < bytes2.length; i++) {
      hex += hexes[bytes2[i]];
    }
    return hex;
  }
  var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
  function asciiToBase16(char) {
    if (char >= asciis._0 && char <= asciis._9)
      return char - asciis._0;
    if (char >= asciis._A && char <= asciis._F)
      return char - (asciis._A - 10);
    if (char >= asciis._a && char <= asciis._f)
      return char - (asciis._a - 10);
    return;
  }
  function hexToBytes(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2)
      throw new Error("padded hex string expected, got unpadded hex of length " + hl);
    const array = new Uint8Array(al);
    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
      const n1 = asciiToBase16(hex.charCodeAt(hi));
      const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
      if (n1 === void 0 || n2 === void 0) {
        const char = hex[hi] + hex[hi + 1];
        throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
      }
      array[ai] = n1 * 16 + n2;
    }
    return array;
  }
  var nextTick = async () => {
  };
  async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for (let i = 0; i < iters; i++) {
      cb(i);
      const diff = Date.now() - ts;
      if (diff >= 0 && diff < tick)
        continue;
      await nextTick();
      ts += diff;
    }
  }
  function utf8ToBytes(str) {
    if (typeof str !== "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str));
  }
  function toBytes(data) {
    if (typeof data === "string")
      data = utf8ToBytes(data);
    bytes(data);
    return data;
  }
  function concatBytes(...arrays) {
    let sum = 0;
    for (let i = 0; i < arrays.length; i++) {
      const a = arrays[i];
      bytes(a);
      sum += a.length;
    }
    const res = new Uint8Array(sum);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
      const a = arrays[i];
      res.set(a, pad);
      pad += a.length;
    }
    return res;
  }
  var Hash = class {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  };
  var toStr = {}.toString;
  function checkOpts(defaults, opts) {
    if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
      throw new Error("Options should be object or undefined");
    const merged = Object.assign(defaults, opts);
    return merged;
  }
  function wrapConstructor(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
  }
  function wrapXOFConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
  }
  function randomBytes(bytesLength = 32) {
    if (crypto2 && typeof crypto2.getRandomValues === "function") {
      return crypto2.getRandomValues(new Uint8Array(bytesLength));
    }
    throw new Error("crypto.getRandomValues must be defined");
  }

  // node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/sha3.js
  var SHA3_PI = [];
  var SHA3_ROTL = [];
  var _SHA3_IOTA = [];
  var _0n = /* @__PURE__ */ BigInt(0);
  var _1n = /* @__PURE__ */ BigInt(1);
  var _2n = /* @__PURE__ */ BigInt(2);
  var _7n = /* @__PURE__ */ BigInt(7);
  var _256n = /* @__PURE__ */ BigInt(256);
  var _0x71n = /* @__PURE__ */ BigInt(113);
  for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
    let t = _0n;
    for (let j = 0; j < 7; j++) {
      R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
      if (R & _2n)
        t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;
    }
    _SHA3_IOTA.push(t);
  }
  var [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);
  var rotlH = (h, l, s) => s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s);
  var rotlL = (h, l, s) => s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s);
  function keccakP(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    for (let round = 24 - rounds; round < 24; round++) {
      for (let x = 0; x < 10; x++)
        B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
      for (let x = 0; x < 10; x += 2) {
        const idx1 = (x + 8) % 10;
        const idx0 = (x + 2) % 10;
        const B0 = B[idx0];
        const B1 = B[idx0 + 1];
        const Th = rotlH(B0, B1, 1) ^ B[idx1];
        const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
        for (let y = 0; y < 50; y += 10) {
          s[x + y] ^= Th;
          s[x + y + 1] ^= Tl;
        }
      }
      let curH = s[2];
      let curL = s[3];
      for (let t = 0; t < 24; t++) {
        const shift = SHA3_ROTL[t];
        const Th = rotlH(curH, curL, shift);
        const Tl = rotlL(curH, curL, shift);
        const PI = SHA3_PI[t];
        curH = s[PI];
        curL = s[PI + 1];
        s[PI] = Th;
        s[PI + 1] = Tl;
      }
      for (let y = 0; y < 50; y += 10) {
        for (let x = 0; x < 10; x++)
          B[x] = s[y + x];
        for (let x = 0; x < 10; x++)
          s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
      }
      s[0] ^= SHA3_IOTA_H[round];
      s[1] ^= SHA3_IOTA_L[round];
    }
    B.fill(0);
  }
  var Keccak = class _Keccak extends Hash {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
      super();
      this.blockLen = blockLen;
      this.suffix = suffix;
      this.outputLen = outputLen;
      this.enableXOF = enableXOF;
      this.rounds = rounds;
      this.pos = 0;
      this.posOut = 0;
      this.finished = false;
      this.destroyed = false;
      number(outputLen);
      if (0 >= this.blockLen || this.blockLen >= 200)
        throw new Error("Sha3 supports only keccak-f1600 function");
      this.state = new Uint8Array(200);
      this.state32 = u32(this.state);
    }
    keccak() {
      if (!isLE)
        byteSwap32(this.state32);
      keccakP(this.state32, this.rounds);
      if (!isLE)
        byteSwap32(this.state32);
      this.posOut = 0;
      this.pos = 0;
    }
    update(data) {
      exists(this);
      const { blockLen, state } = this;
      data = toBytes(data);
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        for (let i = 0; i < take; i++)
          state[this.pos++] ^= data[pos++];
        if (this.pos === blockLen)
          this.keccak();
      }
      return this;
    }
    finish() {
      if (this.finished)
        return;
      this.finished = true;
      const { state, suffix, pos, blockLen } = this;
      state[pos] ^= suffix;
      if ((suffix & 128) !== 0 && pos === blockLen - 1)
        this.keccak();
      state[blockLen - 1] ^= 128;
      this.keccak();
    }
    writeInto(out) {
      exists(this, false);
      bytes(out);
      this.finish();
      const bufferOut = this.state;
      const { blockLen } = this;
      for (let pos = 0, len = out.length; pos < len; ) {
        if (this.posOut >= blockLen)
          this.keccak();
        const take = Math.min(blockLen - this.posOut, len - pos);
        out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
        this.posOut += take;
        pos += take;
      }
      return out;
    }
    xofInto(out) {
      if (!this.enableXOF)
        throw new Error("XOF is not possible for this instance");
      return this.writeInto(out);
    }
    xof(bytes2) {
      number(bytes2);
      return this.xofInto(new Uint8Array(bytes2));
    }
    digestInto(out) {
      output(out, this);
      if (this.finished)
        throw new Error("digest() was already called");
      this.writeInto(out);
      this.destroy();
      return out;
    }
    digest() {
      return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
      this.destroyed = true;
      this.state.fill(0);
    }
    _cloneInto(to) {
      const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
      to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
      to.state32.set(this.state32);
      to.pos = this.pos;
      to.posOut = this.posOut;
      to.finished = this.finished;
      to.rounds = rounds;
      to.suffix = suffix;
      to.outputLen = outputLen;
      to.enableXOF = enableXOF;
      to.destroyed = this.destroyed;
      return to;
    }
  };
  var gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
  var sha3_224 = /* @__PURE__ */ gen(6, 144, 224 / 8);
  var sha3_256 = /* @__PURE__ */ gen(6, 136, 256 / 8);
  var sha3_384 = /* @__PURE__ */ gen(6, 104, 384 / 8);
  var sha3_512 = /* @__PURE__ */ gen(6, 72, 512 / 8);
  var keccak_224 = /* @__PURE__ */ gen(1, 144, 224 / 8);
  var keccak_256 = /* @__PURE__ */ gen(1, 136, 256 / 8);
  var keccak_384 = /* @__PURE__ */ gen(1, 104, 384 / 8);
  var keccak_512 = /* @__PURE__ */ gen(1, 72, 512 / 8);
  var genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
  var shake128 = /* @__PURE__ */ genShake(31, 168, 128 / 8);
  var shake256 = /* @__PURE__ */ genShake(31, 136, 256 / 8);

  // node_modules/ethereum-cryptography/esm/utils.js
  var assertBool = assert_default.bool;
  var assertBytes = assert_default.bytes;
  function hexToBytes2(data) {
    const sliced = data.startsWith("0x") ? data.substring(2) : data;
    return hexToBytes(sliced);
  }
  function equalsBytes(a, b) {
    if (a.length !== b.length) {
      return false;
    }
    for (let i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }
  function wrapHash(hash3) {
    return (msg) => {
      assert_default.bytes(msg);
      return hash3(msg);
    };
  }
  var crypto3 = (() => {
    const webCrypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
    const nodeRequire = typeof module !== "undefined" && typeof module.require === "function" && module.require.bind(module);
    return {
      node: nodeRequire && !webCrypto ? nodeRequire("crypto") : void 0,
      web: webCrypto
    };
  })();

  // node_modules/ethereum-cryptography/esm/keccak.js
  var keccak224 = wrapHash(keccak_224);
  var keccak256 = (() => {
    const k = wrapHash(keccak_256);
    k.create = keccak_256.create;
    return k;
  })();
  var keccak384 = wrapHash(keccak_384);
  var keccak512 = wrapHash(keccak_512);

  // node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/_md.js
  function setBigUint64(view, byteOffset, value, isLE2) {
    if (typeof view.setBigUint64 === "function")
      return view.setBigUint64(byteOffset, value, isLE2);
    const _32n3 = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh = Number(value >> _32n3 & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE2 ? 4 : 0;
    const l = isLE2 ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE2);
    view.setUint32(byteOffset + l, wl, isLE2);
  }
  var Chi = (a, b, c) => a & b ^ ~a & c;
  var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
  var HashMD = class extends Hash {
    constructor(blockLen, outputLen, padOffset, isLE2) {
      super();
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.padOffset = padOffset;
      this.isLE = isLE2;
      this.finished = false;
      this.length = 0;
      this.pos = 0;
      this.destroyed = false;
      this.buffer = new Uint8Array(blockLen);
      this.view = createView(this.buffer);
    }
    update(data) {
      exists(this);
      const { view, buffer, blockLen } = this;
      data = toBytes(data);
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        if (take === blockLen) {
          const dataView = createView(data);
          for (; blockLen <= len - pos; pos += blockLen)
            this.process(dataView, pos);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      exists(this);
      output(out, this);
      this.finished = true;
      const { buffer, view, blockLen, isLE: isLE2 } = this;
      let { pos } = this;
      buffer[pos++] = 128;
      this.buffer.subarray(pos).fill(0);
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let i = pos; i < blockLen; i++)
        buffer[i] = 0;
      setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
      this.process(view, 0);
      const oview = createView(out);
      const len = this.outputLen;
      if (len % 4)
        throw new Error("_sha2: outputLen should be aligned to 32bit");
      const outLen = len / 4;
      const state = this.get();
      if (outLen > state.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let i = 0; i < outLen; i++)
        oview.setUint32(4 * i, state[i], isLE2);
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to) {
      to || (to = new this.constructor());
      to.set(...this.get());
      const { blockLen, buffer, length, finished, destroyed, pos } = this;
      to.length = length;
      to.pos = pos;
      to.finished = finished;
      to.destroyed = destroyed;
      if (length % blockLen)
        to.buffer.set(buffer);
      return to;
    }
  };

  // node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/sha256.js
  var SHA256_K = /* @__PURE__ */ new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  var SHA256_IV = /* @__PURE__ */ new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
  var SHA256 = class extends HashMD {
    constructor() {
      super(64, 32, 8, false);
      this.A = SHA256_IV[0] | 0;
      this.B = SHA256_IV[1] | 0;
      this.C = SHA256_IV[2] | 0;
      this.D = SHA256_IV[3] | 0;
      this.E = SHA256_IV[4] | 0;
      this.F = SHA256_IV[5] | 0;
      this.G = SHA256_IV[6] | 0;
      this.H = SHA256_IV[7] | 0;
    }
    get() {
      const { A, B, C, D, E, F, G, H } = this;
      return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D | 0;
      this.E = E | 0;
      this.F = F | 0;
      this.G = G | 0;
      this.H = H | 0;
    }
    process(view, offset) {
      for (let i = 0; i < 16; i++, offset += 4)
        SHA256_W[i] = view.getUint32(offset, false);
      for (let i = 16; i < 64; i++) {
        const W15 = SHA256_W[i - 15];
        const W2 = SHA256_W[i - 2];
        const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
        const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
        SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
      }
      let { A, B, C, D, E, F, G, H } = this;
      for (let i = 0; i < 64; i++) {
        const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
        const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
        const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
        const T2 = sigma0 + Maj(A, B, C) | 0;
        H = G;
        G = F;
        F = E;
        E = D + T1 | 0;
        D = C;
        C = B;
        B = A;
        A = T1 + T2 | 0;
      }
      A = A + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D = D + this.D | 0;
      E = E + this.E | 0;
      F = F + this.F | 0;
      G = G + this.G | 0;
      H = H + this.H | 0;
      this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
      SHA256_W.fill(0);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      this.buffer.fill(0);
    }
  };
  var sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());

  // node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/hmac.js
  var HMAC = class extends Hash {
    constructor(hash3, _key) {
      super();
      this.finished = false;
      this.destroyed = false;
      hash(hash3);
      const key = toBytes(_key);
      this.iHash = hash3.create();
      if (typeof this.iHash.update !== "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen;
      this.outputLen = this.iHash.outputLen;
      const blockLen = this.blockLen;
      const pad = new Uint8Array(blockLen);
      pad.set(key.length > blockLen ? hash3.create().update(key).digest() : key);
      for (let i = 0; i < pad.length; i++)
        pad[i] ^= 54;
      this.iHash.update(pad);
      this.oHash = hash3.create();
      for (let i = 0; i < pad.length; i++)
        pad[i] ^= 54 ^ 92;
      this.oHash.update(pad);
      pad.fill(0);
    }
    update(buf) {
      exists(this);
      this.iHash.update(buf);
      return this;
    }
    digestInto(out) {
      exists(this);
      bytes(out, this.outputLen);
      this.finished = true;
      this.iHash.digestInto(out);
      this.oHash.update(out);
      this.oHash.digestInto(out);
      this.destroy();
    }
    digest() {
      const out = new Uint8Array(this.oHash.outputLen);
      this.digestInto(out);
      return out;
    }
    _cloneInto(to) {
      to || (to = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
      to = to;
      to.finished = finished;
      to.destroyed = destroyed;
      to.blockLen = blockLen;
      to.outputLen = outputLen;
      to.oHash = oHash._cloneInto(to.oHash);
      to.iHash = iHash._cloneInto(to.iHash);
      return to;
    }
    destroy() {
      this.destroyed = true;
      this.oHash.destroy();
      this.iHash.destroy();
    }
  };
  var hmac = (hash3, key, message) => new HMAC(hash3, key).update(message).digest();
  hmac.create = (hash3, key) => new HMAC(hash3, key);

  // node_modules/ethereum-cryptography/node_modules/@noble/curves/esm/abstract/utils.js
  var utils_exports = {};
  __export(utils_exports, {
    abytes: () => abytes,
    bitGet: () => bitGet,
    bitLen: () => bitLen,
    bitMask: () => bitMask,
    bitSet: () => bitSet,
    bytesToHex: () => bytesToHex2,
    bytesToNumberBE: () => bytesToNumberBE,
    bytesToNumberLE: () => bytesToNumberLE,
    concatBytes: () => concatBytes2,
    createHmacDrbg: () => createHmacDrbg,
    ensureBytes: () => ensureBytes,
    equalBytes: () => equalBytes,
    hexToBytes: () => hexToBytes3,
    hexToNumber: () => hexToNumber,
    isBytes: () => isBytes2,
    numberToBytesBE: () => numberToBytesBE,
    numberToBytesLE: () => numberToBytesLE,
    numberToHexUnpadded: () => numberToHexUnpadded,
    numberToVarBytesBE: () => numberToVarBytesBE,
    utf8ToBytes: () => utf8ToBytes2,
    validateObject: () => validateObject
  });
  var _0n2 = /* @__PURE__ */ BigInt(0);
  var _1n2 = /* @__PURE__ */ BigInt(1);
  var _2n2 = /* @__PURE__ */ BigInt(2);
  function isBytes2(a) {
    return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
  }
  function abytes(item) {
    if (!isBytes2(item))
      throw new Error("Uint8Array expected");
  }
  var hexes2 = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
  function bytesToHex2(bytes2) {
    abytes(bytes2);
    let hex = "";
    for (let i = 0; i < bytes2.length; i++) {
      hex += hexes2[bytes2[i]];
    }
    return hex;
  }
  function numberToHexUnpadded(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? `0${hex}` : hex;
  }
  function hexToNumber(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    return BigInt(hex === "" ? "0" : `0x${hex}`);
  }
  var asciis2 = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
  function asciiToBase162(char) {
    if (char >= asciis2._0 && char <= asciis2._9)
      return char - asciis2._0;
    if (char >= asciis2._A && char <= asciis2._F)
      return char - (asciis2._A - 10);
    if (char >= asciis2._a && char <= asciis2._f)
      return char - (asciis2._a - 10);
    return;
  }
  function hexToBytes3(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2)
      throw new Error("padded hex string expected, got unpadded hex of length " + hl);
    const array = new Uint8Array(al);
    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
      const n1 = asciiToBase162(hex.charCodeAt(hi));
      const n2 = asciiToBase162(hex.charCodeAt(hi + 1));
      if (n1 === void 0 || n2 === void 0) {
        const char = hex[hi] + hex[hi + 1];
        throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
      }
      array[ai] = n1 * 16 + n2;
    }
    return array;
  }
  function bytesToNumberBE(bytes2) {
    return hexToNumber(bytesToHex2(bytes2));
  }
  function bytesToNumberLE(bytes2) {
    abytes(bytes2);
    return hexToNumber(bytesToHex2(Uint8Array.from(bytes2).reverse()));
  }
  function numberToBytesBE(n, len) {
    return hexToBytes3(n.toString(16).padStart(len * 2, "0"));
  }
  function numberToBytesLE(n, len) {
    return numberToBytesBE(n, len).reverse();
  }
  function numberToVarBytesBE(n) {
    return hexToBytes3(numberToHexUnpadded(n));
  }
  function ensureBytes(title, hex, expectedLength) {
    let res;
    if (typeof hex === "string") {
      try {
        res = hexToBytes3(hex);
      } catch (e) {
        throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
      }
    } else if (isBytes2(hex)) {
      res = Uint8Array.from(hex);
    } else {
      throw new Error(`${title} must be hex string or Uint8Array`);
    }
    const len = res.length;
    if (typeof expectedLength === "number" && len !== expectedLength)
      throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
    return res;
  }
  function concatBytes2(...arrays) {
    let sum = 0;
    for (let i = 0; i < arrays.length; i++) {
      const a = arrays[i];
      abytes(a);
      sum += a.length;
    }
    const res = new Uint8Array(sum);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
      const a = arrays[i];
      res.set(a, pad);
      pad += a.length;
    }
    return res;
  }
  function equalBytes(a, b) {
    if (a.length !== b.length)
      return false;
    let diff = 0;
    for (let i = 0; i < a.length; i++)
      diff |= a[i] ^ b[i];
    return diff === 0;
  }
  function utf8ToBytes2(str) {
    if (typeof str !== "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str));
  }
  function bitLen(n) {
    let len;
    for (len = 0; n > _0n2; n >>= _1n2, len += 1)
      ;
    return len;
  }
  function bitGet(n, pos) {
    return n >> BigInt(pos) & _1n2;
  }
  function bitSet(n, pos, value) {
    return n | (value ? _1n2 : _0n2) << BigInt(pos);
  }
  var bitMask = (n) => (_2n2 << BigInt(n - 1)) - _1n2;
  var u8n = (data) => new Uint8Array(data);
  var u8fr = (arr) => Uint8Array.from(arr);
  function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== "number" || hashLen < 2)
      throw new Error("hashLen must be a number");
    if (typeof qByteLen !== "number" || qByteLen < 2)
      throw new Error("qByteLen must be a number");
    if (typeof hmacFn !== "function")
      throw new Error("hmacFn must be a function");
    let v = u8n(hashLen);
    let k = u8n(hashLen);
    let i = 0;
    const reset = () => {
      v.fill(1);
      k.fill(0);
      i = 0;
    };
    const h = (...b) => hmacFn(k, v, ...b);
    const reseed = (seed = u8n()) => {
      k = h(u8fr([0]), seed);
      v = h();
      if (seed.length === 0)
        return;
      k = h(u8fr([1]), seed);
      v = h();
    };
    const gen2 = () => {
      if (i++ >= 1e3)
        throw new Error("drbg: tried 1000 values");
      let len = 0;
      const out = [];
      while (len < qByteLen) {
        v = h();
        const sl = v.slice();
        out.push(sl);
        len += v.length;
      }
      return concatBytes2(...out);
    };
    const genUntil = (seed, pred) => {
      reset();
      reseed(seed);
      let res = void 0;
      while (!(res = pred(gen2())))
        reseed();
      reset();
      return res;
    };
    return genUntil;
  }
  var validatorFns = {
    bigint: (val) => typeof val === "bigint",
    function: (val) => typeof val === "function",
    boolean: (val) => typeof val === "boolean",
    string: (val) => typeof val === "string",
    stringOrUint8Array: (val) => typeof val === "string" || isBytes2(val),
    isSafeInteger: (val) => Number.isSafeInteger(val),
    array: (val) => Array.isArray(val),
    field: (val, object) => object.Fp.isValid(val),
    hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
  };
  function validateObject(object, validators, optValidators = {}) {
    const checkField = (fieldName, type, isOptional) => {
      const checkVal = validatorFns[type];
      if (typeof checkVal !== "function")
        throw new Error(`Invalid validator "${type}", expected function`);
      const val = object[fieldName];
      if (isOptional && val === void 0)
        return;
      if (!checkVal(val, object)) {
        throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
      }
    };
    for (const [fieldName, type] of Object.entries(validators))
      checkField(fieldName, type, false);
    for (const [fieldName, type] of Object.entries(optValidators))
      checkField(fieldName, type, true);
    return object;
  }

  // node_modules/ethereum-cryptography/node_modules/@noble/curves/esm/abstract/modular.js
  var _0n3 = BigInt(0);
  var _1n3 = BigInt(1);
  var _2n3 = BigInt(2);
  var _3n = BigInt(3);
  var _4n = BigInt(4);
  var _5n = BigInt(5);
  var _8n = BigInt(8);
  var _9n = BigInt(9);
  var _16n = BigInt(16);
  function mod(a, b) {
    const result = a % b;
    return result >= _0n3 ? result : b + result;
  }
  function pow(num, power, modulo) {
    if (modulo <= _0n3 || power < _0n3)
      throw new Error("Expected power/modulo > 0");
    if (modulo === _1n3)
      return _0n3;
    let res = _1n3;
    while (power > _0n3) {
      if (power & _1n3)
        res = res * num % modulo;
      num = num * num % modulo;
      power >>= _1n3;
    }
    return res;
  }
  function pow2(x, power, modulo) {
    let res = x;
    while (power-- > _0n3) {
      res *= res;
      res %= modulo;
    }
    return res;
  }
  function invert(number2, modulo) {
    if (number2 === _0n3 || modulo <= _0n3) {
      throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
    }
    let a = mod(number2, modulo);
    let b = modulo;
    let x = _0n3, y = _1n3, u = _1n3, v = _0n3;
    while (a !== _0n3) {
      const q = b / a;
      const r = b % a;
      const m = x - u * q;
      const n = y - v * q;
      b = a, a = r, x = u, y = v, u = m, v = n;
    }
    const gcd2 = b;
    if (gcd2 !== _1n3)
      throw new Error("invert: does not exist");
    return mod(x, modulo);
  }
  function tonelliShanks(P) {
    const legendreC = (P - _1n3) / _2n3;
    let Q, S, Z;
    for (Q = P - _1n3, S = 0; Q % _2n3 === _0n3; Q /= _2n3, S++)
      ;
    for (Z = _2n3; Z < P && pow(Z, legendreC, P) !== P - _1n3; Z++)
      ;
    if (S === 1) {
      const p1div4 = (P + _1n3) / _4n;
      return function tonelliFast(Fp2, n) {
        const root = Fp2.pow(n, p1div4);
        if (!Fp2.eql(Fp2.sqr(root), n))
          throw new Error("Cannot find square root");
        return root;
      };
    }
    const Q1div2 = (Q + _1n3) / _2n3;
    return function tonelliSlow(Fp2, n) {
      if (Fp2.pow(n, legendreC) === Fp2.neg(Fp2.ONE))
        throw new Error("Cannot find square root");
      let r = S;
      let g = Fp2.pow(Fp2.mul(Fp2.ONE, Z), Q);
      let x = Fp2.pow(n, Q1div2);
      let b = Fp2.pow(n, Q);
      while (!Fp2.eql(b, Fp2.ONE)) {
        if (Fp2.eql(b, Fp2.ZERO))
          return Fp2.ZERO;
        let m = 1;
        for (let t2 = Fp2.sqr(b); m < r; m++) {
          if (Fp2.eql(t2, Fp2.ONE))
            break;
          t2 = Fp2.sqr(t2);
        }
        const ge = Fp2.pow(g, _1n3 << BigInt(r - m - 1));
        g = Fp2.sqr(ge);
        x = Fp2.mul(x, ge);
        b = Fp2.mul(b, g);
        r = m;
      }
      return x;
    };
  }
  function FpSqrt(P) {
    if (P % _4n === _3n) {
      const p1div4 = (P + _1n3) / _4n;
      return function sqrt3mod42(Fp2, n) {
        const root = Fp2.pow(n, p1div4);
        if (!Fp2.eql(Fp2.sqr(root), n))
          throw new Error("Cannot find square root");
        return root;
      };
    }
    if (P % _8n === _5n) {
      const c1 = (P - _5n) / _8n;
      return function sqrt5mod82(Fp2, n) {
        const n2 = Fp2.mul(n, _2n3);
        const v = Fp2.pow(n2, c1);
        const nv = Fp2.mul(n, v);
        const i = Fp2.mul(Fp2.mul(nv, _2n3), v);
        const root = Fp2.mul(nv, Fp2.sub(i, Fp2.ONE));
        if (!Fp2.eql(Fp2.sqr(root), n))
          throw new Error("Cannot find square root");
        return root;
      };
    }
    if (P % _16n === _9n) {
    }
    return tonelliShanks(P);
  }
  var FIELD_FIELDS = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
  ];
  function validateField(field) {
    const initial = {
      ORDER: "bigint",
      MASK: "bigint",
      BYTES: "isSafeInteger",
      BITS: "isSafeInteger"
    };
    const opts = FIELD_FIELDS.reduce((map, val) => {
      map[val] = "function";
      return map;
    }, initial);
    return validateObject(field, opts);
  }
  function FpPow(f, num, power) {
    if (power < _0n3)
      throw new Error("Expected power > 0");
    if (power === _0n3)
      return f.ONE;
    if (power === _1n3)
      return num;
    let p = f.ONE;
    let d = num;
    while (power > _0n3) {
      if (power & _1n3)
        p = f.mul(p, d);
      d = f.sqr(d);
      power >>= _1n3;
    }
    return p;
  }
  function FpInvertBatch(f, nums) {
    const tmp = new Array(nums.length);
    const lastMultiplied = nums.reduce((acc, num, i) => {
      if (f.is0(num))
        return acc;
      tmp[i] = acc;
      return f.mul(acc, num);
    }, f.ONE);
    const inverted = f.inv(lastMultiplied);
    nums.reduceRight((acc, num, i) => {
      if (f.is0(num))
        return acc;
      tmp[i] = f.mul(acc, tmp[i]);
      return f.mul(acc, num);
    }, inverted);
    return tmp;
  }
  function nLength(n, nBitLength) {
    const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return { nBitLength: _nBitLength, nByteLength };
  }
  function Field(ORDER, bitLen3, isLE2 = false, redef = {}) {
    if (ORDER <= _0n3)
      throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen3);
    if (BYTES > 2048)
      throw new Error("Field lengths over 2048 bytes are not supported");
    const sqrtP = FpSqrt(ORDER);
    const f = Object.freeze({
      ORDER,
      BITS,
      BYTES,
      MASK: bitMask(BITS),
      ZERO: _0n3,
      ONE: _1n3,
      create: (num) => mod(num, ORDER),
      isValid: (num) => {
        if (typeof num !== "bigint")
          throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
        return _0n3 <= num && num < ORDER;
      },
      is0: (num) => num === _0n3,
      isOdd: (num) => (num & _1n3) === _1n3,
      neg: (num) => mod(-num, ORDER),
      eql: (lhs, rhs) => lhs === rhs,
      sqr: (num) => mod(num * num, ORDER),
      add: (lhs, rhs) => mod(lhs + rhs, ORDER),
      sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
      mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
      pow: (num, power) => FpPow(f, num, power),
      div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
      // Same as above, but doesn't normalize
      sqrN: (num) => num * num,
      addN: (lhs, rhs) => lhs + rhs,
      subN: (lhs, rhs) => lhs - rhs,
      mulN: (lhs, rhs) => lhs * rhs,
      inv: (num) => invert(num, ORDER),
      sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
      invertBatch: (lst) => FpInvertBatch(f, lst),
      // TODO: do we really need constant cmov?
      // We don't have const-time bigints anyway, so probably will be not very useful
      cmov: (a, b, c) => c ? b : a,
      toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
      fromBytes: (bytes2) => {
        if (bytes2.length !== BYTES)
          throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes2.length}`);
        return isLE2 ? bytesToNumberLE(bytes2) : bytesToNumberBE(bytes2);
      }
    });
    return Object.freeze(f);
  }
  function getFieldBytesLength(fieldOrder) {
    if (typeof fieldOrder !== "bigint")
      throw new Error("field order must be bigint");
    const bitLength = fieldOrder.toString(2).length;
    return Math.ceil(bitLength / 8);
  }
  function getMinHashLength(fieldOrder) {
    const length = getFieldBytesLength(fieldOrder);
    return length + Math.ceil(length / 2);
  }
  function mapHashToField(key, fieldOrder, isLE2 = false) {
    const len = key.length;
    const fieldLen = getFieldBytesLength(fieldOrder);
    const minLen = getMinHashLength(fieldOrder);
    if (len < 16 || len < minLen || len > 1024)
      throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
    const num = isLE2 ? bytesToNumberBE(key) : bytesToNumberLE(key);
    const reduced = mod(num, fieldOrder - _1n3) + _1n3;
    return isLE2 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
  }

  // node_modules/ethereum-cryptography/node_modules/@noble/curves/esm/abstract/curve.js
  var _0n4 = BigInt(0);
  var _1n4 = BigInt(1);
  function wNAF(c, bits) {
    const constTimeNegate = (condition, item) => {
      const neg = item.negate();
      return condition ? neg : item;
    };
    const opts = (W) => {
      const windows = Math.ceil(bits / W) + 1;
      const windowSize = 2 ** (W - 1);
      return { windows, windowSize };
    };
    return {
      constTimeNegate,
      // non-const time multiplication ladder
      unsafeLadder(elm, n) {
        let p = c.ZERO;
        let d = elm;
        while (n > _0n4) {
          if (n & _1n4)
            p = p.add(d);
          d = d.double();
          n >>= _1n4;
        }
        return p;
      },
      /**
       * Creates a wNAF precomputation window. Used for caching.
       * Default window size is set by `utils.precompute()` and is equal to 8.
       * Number of precomputed points depends on the curve size:
       * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
       * - 𝑊 is the window size
       * - 𝑛 is the bitlength of the curve order.
       * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
       * @returns precomputed point tables flattened to a single array
       */
      precomputeWindow(elm, W) {
        const { windows, windowSize } = opts(W);
        const points = [];
        let p = elm;
        let base = p;
        for (let window = 0; window < windows; window++) {
          base = p;
          points.push(base);
          for (let i = 1; i < windowSize; i++) {
            base = base.add(p);
            points.push(base);
          }
          p = base.double();
        }
        return points;
      },
      /**
       * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
       * @param W window size
       * @param precomputes precomputed tables
       * @param n scalar (we don't check here, but should be less than curve order)
       * @returns real and fake (for const-time) points
       */
      wNAF(W, precomputes, n) {
        const { windows, windowSize } = opts(W);
        let p = c.ZERO;
        let f = c.BASE;
        const mask = BigInt(2 ** W - 1);
        const maxNumber = 2 ** W;
        const shiftBy = BigInt(W);
        for (let window = 0; window < windows; window++) {
          const offset = window * windowSize;
          let wbits = Number(n & mask);
          n >>= shiftBy;
          if (wbits > windowSize) {
            wbits -= maxNumber;
            n += _1n4;
          }
          const offset1 = offset;
          const offset2 = offset + Math.abs(wbits) - 1;
          const cond1 = window % 2 !== 0;
          const cond2 = wbits < 0;
          if (wbits === 0) {
            f = f.add(constTimeNegate(cond1, precomputes[offset1]));
          } else {
            p = p.add(constTimeNegate(cond2, precomputes[offset2]));
          }
        }
        return { p, f };
      },
      wNAFCached(P, precomputesMap, n, transform) {
        const W = P._WINDOW_SIZE || 1;
        let comp = precomputesMap.get(P);
        if (!comp) {
          comp = this.precomputeWindow(P, W);
          if (W !== 1) {
            precomputesMap.set(P, transform(comp));
          }
        }
        return this.wNAF(W, comp, n);
      }
    };
  }
  function validateBasic(curve) {
    validateField(curve.Fp);
    validateObject(curve, {
      n: "bigint",
      h: "bigint",
      Gx: "field",
      Gy: "field"
    }, {
      nBitLength: "isSafeInteger",
      nByteLength: "isSafeInteger"
    });
    return Object.freeze({
      ...nLength(curve.n, curve.nBitLength),
      ...curve,
      ...{ p: curve.Fp.ORDER }
    });
  }

  // node_modules/ethereum-cryptography/node_modules/@noble/curves/esm/abstract/weierstrass.js
  function validatePointOpts(curve) {
    const opts = validateBasic(curve);
    validateObject(opts, {
      a: "field",
      b: "field"
    }, {
      allowedPrivateKeyLengths: "array",
      wrapPrivateKey: "boolean",
      isTorsionFree: "function",
      clearCofactor: "function",
      allowInfinityPoint: "boolean",
      fromBytes: "function",
      toBytes: "function"
    });
    const { endo, Fp: Fp2, a } = opts;
    if (endo) {
      if (!Fp2.eql(a, Fp2.ZERO)) {
        throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
      }
      if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
        throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
      }
    }
    return Object.freeze({ ...opts });
  }
  var { bytesToNumberBE: b2n, hexToBytes: h2b } = utils_exports;
  var DER = {
    // asn.1 DER encoding utils
    Err: class DERErr extends Error {
      constructor(m = "") {
        super(m);
      }
    },
    _parseInt(data) {
      const { Err: E } = DER;
      if (data.length < 2 || data[0] !== 2)
        throw new E("Invalid signature integer tag");
      const len = data[1];
      const res = data.subarray(2, len + 2);
      if (!len || res.length !== len)
        throw new E("Invalid signature integer: wrong length");
      if (res[0] & 128)
        throw new E("Invalid signature integer: negative");
      if (res[0] === 0 && !(res[1] & 128))
        throw new E("Invalid signature integer: unnecessary leading zero");
      return { d: b2n(res), l: data.subarray(len + 2) };
    },
    toSig(hex) {
      const { Err: E } = DER;
      const data = typeof hex === "string" ? h2b(hex) : hex;
      abytes(data);
      let l = data.length;
      if (l < 2 || data[0] != 48)
        throw new E("Invalid signature tag");
      if (data[1] !== l - 2)
        throw new E("Invalid signature: incorrect length");
      const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));
      const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);
      if (rBytesLeft.length)
        throw new E("Invalid signature: left bytes after parsing");
      return { r, s };
    },
    hexFromSig(sig) {
      const slice = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
      const h = (num) => {
        const hex = num.toString(16);
        return hex.length & 1 ? `0${hex}` : hex;
      };
      const s = slice(h(sig.s));
      const r = slice(h(sig.r));
      const shl = s.length / 2;
      const rhl = r.length / 2;
      const sl = h(shl);
      const rl = h(rhl);
      return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
    }
  };
  var _0n5 = BigInt(0);
  var _1n5 = BigInt(1);
  var _2n4 = BigInt(2);
  var _3n2 = BigInt(3);
  var _4n2 = BigInt(4);
  function weierstrassPoints(opts) {
    const CURVE = validatePointOpts(opts);
    const { Fp: Fp2 } = CURVE;
    const toBytes5 = CURVE.toBytes || ((_c, point, _isCompressed) => {
      const a = point.toAffine();
      return concatBytes2(Uint8Array.from([4]), Fp2.toBytes(a.x), Fp2.toBytes(a.y));
    });
    const fromBytes = CURVE.fromBytes || ((bytes2) => {
      const tail = bytes2.subarray(1);
      const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
      const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
      return { x, y };
    });
    function weierstrassEquation(x) {
      const { a, b } = CURVE;
      const x2 = Fp2.sqr(x);
      const x3 = Fp2.mul(x2, x);
      return Fp2.add(Fp2.add(x3, Fp2.mul(x, a)), b);
    }
    if (!Fp2.eql(Fp2.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
      throw new Error("bad generator point: equation left != right");
    function isWithinCurveOrder(num) {
      return typeof num === "bigint" && _0n5 < num && num < CURVE.n;
    }
    function assertGE(num) {
      if (!isWithinCurveOrder(num))
        throw new Error("Expected valid bigint: 0 < bigint < curve.n");
    }
    function normPrivateKeyToScalar(key) {
      const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
      if (lengths && typeof key !== "bigint") {
        if (isBytes2(key))
          key = bytesToHex2(key);
        if (typeof key !== "string" || !lengths.includes(key.length))
          throw new Error("Invalid key");
        key = key.padStart(nByteLength * 2, "0");
      }
      let num;
      try {
        num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
      } catch (error) {
        throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
      }
      if (wrapPrivateKey)
        num = mod(num, n);
      assertGE(num);
      return num;
    }
    const pointPrecomputes2 = /* @__PURE__ */ new Map();
    function assertPrjPoint(other) {
      if (!(other instanceof Point3))
        throw new Error("ProjectivePoint expected");
    }
    class Point3 {
      constructor(px, py, pz) {
        this.px = px;
        this.py = py;
        this.pz = pz;
        if (px == null || !Fp2.isValid(px))
          throw new Error("x required");
        if (py == null || !Fp2.isValid(py))
          throw new Error("y required");
        if (pz == null || !Fp2.isValid(pz))
          throw new Error("z required");
      }
      // Does not validate if the point is on-curve.
      // Use fromHex instead, or call assertValidity() later.
      static fromAffine(p) {
        const { x, y } = p || {};
        if (!p || !Fp2.isValid(x) || !Fp2.isValid(y))
          throw new Error("invalid affine point");
        if (p instanceof Point3)
          throw new Error("projective point not allowed");
        const is0 = (i) => Fp2.eql(i, Fp2.ZERO);
        if (is0(x) && is0(y))
          return Point3.ZERO;
        return new Point3(x, y, Fp2.ONE);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      /**
       * Takes a bunch of Projective Points but executes only one
       * inversion on all of them. Inversion is very slow operation,
       * so this improves performance massively.
       * Optimization: converts a list of projective points to a list of identical points with Z=1.
       */
      static normalizeZ(points) {
        const toInv = Fp2.invertBatch(points.map((p) => p.pz));
        return points.map((p, i) => p.toAffine(toInv[i])).map(Point3.fromAffine);
      }
      /**
       * Converts hash string or Uint8Array to Point.
       * @param hex short/long ECDSA hex
       */
      static fromHex(hex) {
        const P = Point3.fromAffine(fromBytes(ensureBytes("pointHex", hex)));
        P.assertValidity();
        return P;
      }
      // Multiplies generator point by privateKey.
      static fromPrivateKey(privateKey) {
        return Point3.BASE.multiply(normPrivateKeyToScalar(privateKey));
      }
      // "Private method", don't use it directly
      _setWindowSize(windowSize) {
        this._WINDOW_SIZE = windowSize;
        pointPrecomputes2.delete(this);
      }
      // A point on curve is valid if it conforms to equation.
      assertValidity() {
        if (this.is0()) {
          if (CURVE.allowInfinityPoint && !Fp2.is0(this.py))
            return;
          throw new Error("bad point: ZERO");
        }
        const { x, y } = this.toAffine();
        if (!Fp2.isValid(x) || !Fp2.isValid(y))
          throw new Error("bad point: x or y not FE");
        const left = Fp2.sqr(y);
        const right = weierstrassEquation(x);
        if (!Fp2.eql(left, right))
          throw new Error("bad point: equation left != right");
        if (!this.isTorsionFree())
          throw new Error("bad point: not in prime-order subgroup");
      }
      hasEvenY() {
        const { y } = this.toAffine();
        if (Fp2.isOdd)
          return !Fp2.isOdd(y);
        throw new Error("Field doesn't support isOdd");
      }
      /**
       * Compare one point to another.
       */
      equals(other) {
        assertPrjPoint(other);
        const { px: X1, py: Y1, pz: Z1 } = this;
        const { px: X2, py: Y2, pz: Z2 } = other;
        const U1 = Fp2.eql(Fp2.mul(X1, Z2), Fp2.mul(X2, Z1));
        const U2 = Fp2.eql(Fp2.mul(Y1, Z2), Fp2.mul(Y2, Z1));
        return U1 && U2;
      }
      /**
       * Flips point to one corresponding to (x, -y) in Affine coordinates.
       */
      negate() {
        return new Point3(this.px, Fp2.neg(this.py), this.pz);
      }
      // Renes-Costello-Batina exception-free doubling formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 3
      // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
      double() {
        const { a, b } = CURVE;
        const b3 = Fp2.mul(b, _3n2);
        const { px: X1, py: Y1, pz: Z1 } = this;
        let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
        let t0 = Fp2.mul(X1, X1);
        let t1 = Fp2.mul(Y1, Y1);
        let t2 = Fp2.mul(Z1, Z1);
        let t3 = Fp2.mul(X1, Y1);
        t3 = Fp2.add(t3, t3);
        Z3 = Fp2.mul(X1, Z1);
        Z3 = Fp2.add(Z3, Z3);
        X3 = Fp2.mul(a, Z3);
        Y3 = Fp2.mul(b3, t2);
        Y3 = Fp2.add(X3, Y3);
        X3 = Fp2.sub(t1, Y3);
        Y3 = Fp2.add(t1, Y3);
        Y3 = Fp2.mul(X3, Y3);
        X3 = Fp2.mul(t3, X3);
        Z3 = Fp2.mul(b3, Z3);
        t2 = Fp2.mul(a, t2);
        t3 = Fp2.sub(t0, t2);
        t3 = Fp2.mul(a, t3);
        t3 = Fp2.add(t3, Z3);
        Z3 = Fp2.add(t0, t0);
        t0 = Fp2.add(Z3, t0);
        t0 = Fp2.add(t0, t2);
        t0 = Fp2.mul(t0, t3);
        Y3 = Fp2.add(Y3, t0);
        t2 = Fp2.mul(Y1, Z1);
        t2 = Fp2.add(t2, t2);
        t0 = Fp2.mul(t2, t3);
        X3 = Fp2.sub(X3, t0);
        Z3 = Fp2.mul(t2, t1);
        Z3 = Fp2.add(Z3, Z3);
        Z3 = Fp2.add(Z3, Z3);
        return new Point3(X3, Y3, Z3);
      }
      // Renes-Costello-Batina exception-free addition formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 1
      // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
      add(other) {
        assertPrjPoint(other);
        const { px: X1, py: Y1, pz: Z1 } = this;
        const { px: X2, py: Y2, pz: Z2 } = other;
        let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
        const a = CURVE.a;
        const b3 = Fp2.mul(CURVE.b, _3n2);
        let t0 = Fp2.mul(X1, X2);
        let t1 = Fp2.mul(Y1, Y2);
        let t2 = Fp2.mul(Z1, Z2);
        let t3 = Fp2.add(X1, Y1);
        let t4 = Fp2.add(X2, Y2);
        t3 = Fp2.mul(t3, t4);
        t4 = Fp2.add(t0, t1);
        t3 = Fp2.sub(t3, t4);
        t4 = Fp2.add(X1, Z1);
        let t5 = Fp2.add(X2, Z2);
        t4 = Fp2.mul(t4, t5);
        t5 = Fp2.add(t0, t2);
        t4 = Fp2.sub(t4, t5);
        t5 = Fp2.add(Y1, Z1);
        X3 = Fp2.add(Y2, Z2);
        t5 = Fp2.mul(t5, X3);
        X3 = Fp2.add(t1, t2);
        t5 = Fp2.sub(t5, X3);
        Z3 = Fp2.mul(a, t4);
        X3 = Fp2.mul(b3, t2);
        Z3 = Fp2.add(X3, Z3);
        X3 = Fp2.sub(t1, Z3);
        Z3 = Fp2.add(t1, Z3);
        Y3 = Fp2.mul(X3, Z3);
        t1 = Fp2.add(t0, t0);
        t1 = Fp2.add(t1, t0);
        t2 = Fp2.mul(a, t2);
        t4 = Fp2.mul(b3, t4);
        t1 = Fp2.add(t1, t2);
        t2 = Fp2.sub(t0, t2);
        t2 = Fp2.mul(a, t2);
        t4 = Fp2.add(t4, t2);
        t0 = Fp2.mul(t1, t4);
        Y3 = Fp2.add(Y3, t0);
        t0 = Fp2.mul(t5, t4);
        X3 = Fp2.mul(t3, X3);
        X3 = Fp2.sub(X3, t0);
        t0 = Fp2.mul(t3, t1);
        Z3 = Fp2.mul(t5, Z3);
        Z3 = Fp2.add(Z3, t0);
        return new Point3(X3, Y3, Z3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      is0() {
        return this.equals(Point3.ZERO);
      }
      wNAF(n) {
        return wnaf.wNAFCached(this, pointPrecomputes2, n, (comp) => {
          const toInv = Fp2.invertBatch(comp.map((p) => p.pz));
          return comp.map((p, i) => p.toAffine(toInv[i])).map(Point3.fromAffine);
        });
      }
      /**
       * Non-constant-time multiplication. Uses double-and-add algorithm.
       * It's faster, but should only be used when you don't care about
       * an exposed private key e.g. sig verification, which works over *public* keys.
       */
      multiplyUnsafe(n) {
        const I = Point3.ZERO;
        if (n === _0n5)
          return I;
        assertGE(n);
        if (n === _1n5)
          return this;
        const { endo } = CURVE;
        if (!endo)
          return wnaf.unsafeLadder(this, n);
        let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
        let k1p = I;
        let k2p = I;
        let d = this;
        while (k1 > _0n5 || k2 > _0n5) {
          if (k1 & _1n5)
            k1p = k1p.add(d);
          if (k2 & _1n5)
            k2p = k2p.add(d);
          d = d.double();
          k1 >>= _1n5;
          k2 >>= _1n5;
        }
        if (k1neg)
          k1p = k1p.negate();
        if (k2neg)
          k2p = k2p.negate();
        k2p = new Point3(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        return k1p.add(k2p);
      }
      /**
       * Constant time multiplication.
       * Uses wNAF method. Windowed method may be 10% faster,
       * but takes 2x longer to generate and consumes 2x memory.
       * Uses precomputes when available.
       * Uses endomorphism for Koblitz curves.
       * @param scalar by which the point would be multiplied
       * @returns New point
       */
      multiply(scalar) {
        assertGE(scalar);
        let n = scalar;
        let point, fake;
        const { endo } = CURVE;
        if (endo) {
          const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
          let { p: k1p, f: f1p } = this.wNAF(k1);
          let { p: k2p, f: f2p } = this.wNAF(k2);
          k1p = wnaf.constTimeNegate(k1neg, k1p);
          k2p = wnaf.constTimeNegate(k2neg, k2p);
          k2p = new Point3(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
          point = k1p.add(k2p);
          fake = f1p.add(f2p);
        } else {
          const { p, f } = this.wNAF(n);
          point = p;
          fake = f;
        }
        return Point3.normalizeZ([point, fake])[0];
      }
      /**
       * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
       * Not using Strauss-Shamir trick: precomputation tables are faster.
       * The trick could be useful if both P and Q are not G (not in our case).
       * @returns non-zero affine point
       */
      multiplyAndAddUnsafe(Q, a, b) {
        const G = Point3.BASE;
        const mul = (P, a2) => a2 === _0n5 || a2 === _1n5 || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
        const sum = mul(this, a).add(mul(Q, b));
        return sum.is0() ? void 0 : sum;
      }
      // Converts Projective point to affine (x, y) coordinates.
      // Can accept precomputed Z^-1 - for example, from invertBatch.
      // (x, y, z) ∋ (x=x/z, y=y/z)
      toAffine(iz) {
        const { px: x, py: y, pz: z } = this;
        const is0 = this.is0();
        if (iz == null)
          iz = is0 ? Fp2.ONE : Fp2.inv(z);
        const ax = Fp2.mul(x, iz);
        const ay = Fp2.mul(y, iz);
        const zz = Fp2.mul(z, iz);
        if (is0)
          return { x: Fp2.ZERO, y: Fp2.ZERO };
        if (!Fp2.eql(zz, Fp2.ONE))
          throw new Error("invZ was invalid");
        return { x: ax, y: ay };
      }
      isTorsionFree() {
        const { h: cofactor, isTorsionFree } = CURVE;
        if (cofactor === _1n5)
          return true;
        if (isTorsionFree)
          return isTorsionFree(Point3, this);
        throw new Error("isTorsionFree() has not been declared for the elliptic curve");
      }
      clearCofactor() {
        const { h: cofactor, clearCofactor } = CURVE;
        if (cofactor === _1n5)
          return this;
        if (clearCofactor)
          return clearCofactor(Point3, this);
        return this.multiplyUnsafe(CURVE.h);
      }
      toRawBytes(isCompressed = true) {
        this.assertValidity();
        return toBytes5(Point3, this, isCompressed);
      }
      toHex(isCompressed = true) {
        return bytesToHex2(this.toRawBytes(isCompressed));
      }
    }
    Point3.BASE = new Point3(CURVE.Gx, CURVE.Gy, Fp2.ONE);
    Point3.ZERO = new Point3(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
    const _bits = CURVE.nBitLength;
    const wnaf = wNAF(Point3, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
    return {
      CURVE,
      ProjectivePoint: Point3,
      normPrivateKeyToScalar,
      weierstrassEquation,
      isWithinCurveOrder
    };
  }
  function validateOpts(curve) {
    const opts = validateBasic(curve);
    validateObject(opts, {
      hash: "hash",
      hmac: "function",
      randomBytes: "function"
    }, {
      bits2int: "function",
      bits2int_modN: "function",
      lowS: "boolean"
    });
    return Object.freeze({ lowS: true, ...opts });
  }
  function weierstrass(curveDef) {
    const CURVE = validateOpts(curveDef);
    const { Fp: Fp2, n: CURVE_ORDER } = CURVE;
    const compressedLen = Fp2.BYTES + 1;
    const uncompressedLen = 2 * Fp2.BYTES + 1;
    function isValidFieldElement(num) {
      return _0n5 < num && num < Fp2.ORDER;
    }
    function modN(a) {
      return mod(a, CURVE_ORDER);
    }
    function invN(a) {
      return invert(a, CURVE_ORDER);
    }
    const { ProjectivePoint: Point3, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
      ...CURVE,
      toBytes(_c, point, isCompressed) {
        const a = point.toAffine();
        const x = Fp2.toBytes(a.x);
        const cat = concatBytes2;
        if (isCompressed) {
          return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
        } else {
          return cat(Uint8Array.from([4]), x, Fp2.toBytes(a.y));
        }
      },
      fromBytes(bytes2) {
        const len = bytes2.length;
        const head = bytes2[0];
        const tail = bytes2.subarray(1);
        if (len === compressedLen && (head === 2 || head === 3)) {
          const x = bytesToNumberBE(tail);
          if (!isValidFieldElement(x))
            throw new Error("Point is not on curve");
          const y2 = weierstrassEquation(x);
          let y;
          try {
            y = Fp2.sqrt(y2);
          } catch (sqrtError) {
            const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
            throw new Error("Point is not on curve" + suffix);
          }
          const isYOdd = (y & _1n5) === _1n5;
          const isHeadOdd = (head & 1) === 1;
          if (isHeadOdd !== isYOdd)
            y = Fp2.neg(y);
          return { x, y };
        } else if (len === uncompressedLen && head === 4) {
          const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
          const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
          return { x, y };
        } else {
          throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
        }
      }
    });
    const numToNByteStr = (num) => bytesToHex2(numberToBytesBE(num, CURVE.nByteLength));
    function isBiggerThanHalfOrder(number2) {
      const HALF = CURVE_ORDER >> _1n5;
      return number2 > HALF;
    }
    function normalizeS(s) {
      return isBiggerThanHalfOrder(s) ? modN(-s) : s;
    }
    const slcNum = (b, from, to) => bytesToNumberBE(b.slice(from, to));
    class Signature {
      constructor(r, s, recovery) {
        this.r = r;
        this.s = s;
        this.recovery = recovery;
        this.assertValidity();
      }
      // pair (bytes of r, bytes of s)
      static fromCompact(hex) {
        const l = CURVE.nByteLength;
        hex = ensureBytes("compactSignature", hex, l * 2);
        return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
      }
      // DER encoded ECDSA signature
      // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
      static fromDER(hex) {
        const { r, s } = DER.toSig(ensureBytes("DER", hex));
        return new Signature(r, s);
      }
      assertValidity() {
        if (!isWithinCurveOrder(this.r))
          throw new Error("r must be 0 < r < CURVE.n");
        if (!isWithinCurveOrder(this.s))
          throw new Error("s must be 0 < s < CURVE.n");
      }
      addRecoveryBit(recovery) {
        return new Signature(this.r, this.s, recovery);
      }
      recoverPublicKey(msgHash) {
        const { r, s, recovery: rec } = this;
        const h = bits2int_modN(ensureBytes("msgHash", msgHash));
        if (rec == null || ![0, 1, 2, 3].includes(rec))
          throw new Error("recovery id invalid");
        const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
        if (radj >= Fp2.ORDER)
          throw new Error("recovery id 2 or 3 invalid");
        const prefix = (rec & 1) === 0 ? "02" : "03";
        const R = Point3.fromHex(prefix + numToNByteStr(radj));
        const ir = invN(radj);
        const u1 = modN(-h * ir);
        const u2 = modN(s * ir);
        const Q = Point3.BASE.multiplyAndAddUnsafe(R, u1, u2);
        if (!Q)
          throw new Error("point at infinify");
        Q.assertValidity();
        return Q;
      }
      // Signatures should be low-s, to prevent malleability.
      hasHighS() {
        return isBiggerThanHalfOrder(this.s);
      }
      normalizeS() {
        return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
      }
      // DER-encoded
      toDERRawBytes() {
        return hexToBytes3(this.toDERHex());
      }
      toDERHex() {
        return DER.hexFromSig({ r: this.r, s: this.s });
      }
      // padded bytes of r, then padded bytes of s
      toCompactRawBytes() {
        return hexToBytes3(this.toCompactHex());
      }
      toCompactHex() {
        return numToNByteStr(this.r) + numToNByteStr(this.s);
      }
    }
    const utils2 = {
      isValidPrivateKey(privateKey) {
        try {
          normPrivateKeyToScalar(privateKey);
          return true;
        } catch (error) {
          return false;
        }
      },
      normPrivateKeyToScalar,
      /**
       * Produces cryptographically secure private key from random of size
       * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
       */
      randomPrivateKey: () => {
        const length = getMinHashLength(CURVE.n);
        return mapHashToField(CURVE.randomBytes(length), CURVE.n);
      },
      /**
       * Creates precompute table for an arbitrary EC point. Makes point "cached".
       * Allows to massively speed-up `point.multiply(scalar)`.
       * @returns cached point
       * @example
       * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
       * fast.multiply(privKey); // much faster ECDH now
       */
      precompute(windowSize = 8, point = Point3.BASE) {
        point._setWindowSize(windowSize);
        point.multiply(BigInt(3));
        return point;
      }
    };
    function getPublicKey(privateKey, isCompressed = true) {
      return Point3.fromPrivateKey(privateKey).toRawBytes(isCompressed);
    }
    function isProbPub(item) {
      const arr = isBytes2(item);
      const str = typeof item === "string";
      const len = (arr || str) && item.length;
      if (arr)
        return len === compressedLen || len === uncompressedLen;
      if (str)
        return len === 2 * compressedLen || len === 2 * uncompressedLen;
      if (item instanceof Point3)
        return true;
      return false;
    }
    function getSharedSecret(privateA, publicB, isCompressed = true) {
      if (isProbPub(privateA))
        throw new Error("first arg must be private key");
      if (!isProbPub(publicB))
        throw new Error("second arg must be public key");
      const b = Point3.fromHex(publicB);
      return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
    }
    const bits2int = CURVE.bits2int || function(bytes2) {
      const num = bytesToNumberBE(bytes2);
      const delta = bytes2.length * 8 - CURVE.nBitLength;
      return delta > 0 ? num >> BigInt(delta) : num;
    };
    const bits2int_modN = CURVE.bits2int_modN || function(bytes2) {
      return modN(bits2int(bytes2));
    };
    const ORDER_MASK = bitMask(CURVE.nBitLength);
    function int2octets(num) {
      if (typeof num !== "bigint")
        throw new Error("bigint expected");
      if (!(_0n5 <= num && num < ORDER_MASK))
        throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
      return numberToBytesBE(num, CURVE.nByteLength);
    }
    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
      if (["recovered", "canonical"].some((k) => k in opts))
        throw new Error("sign() legacy options not supported");
      const { hash: hash3, randomBytes: randomBytes3 } = CURVE;
      let { lowS, prehash, extraEntropy: ent } = opts;
      if (lowS == null)
        lowS = true;
      msgHash = ensureBytes("msgHash", msgHash);
      if (prehash)
        msgHash = ensureBytes("prehashed msgHash", hash3(msgHash));
      const h1int = bits2int_modN(msgHash);
      const d = normPrivateKeyToScalar(privateKey);
      const seedArgs = [int2octets(d), int2octets(h1int)];
      if (ent != null && ent !== false) {
        const e = ent === true ? randomBytes3(Fp2.BYTES) : ent;
        seedArgs.push(ensureBytes("extraEntropy", e));
      }
      const seed = concatBytes2(...seedArgs);
      const m = h1int;
      function k2sig(kBytes) {
        const k = bits2int(kBytes);
        if (!isWithinCurveOrder(k))
          return;
        const ik = invN(k);
        const q = Point3.BASE.multiply(k).toAffine();
        const r = modN(q.x);
        if (r === _0n5)
          return;
        const s = modN(ik * modN(m + r * d));
        if (s === _0n5)
          return;
        let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n5);
        let normS = s;
        if (lowS && isBiggerThanHalfOrder(s)) {
          normS = normalizeS(s);
          recovery ^= 1;
        }
        return new Signature(r, normS, recovery);
      }
      return { seed, k2sig };
    }
    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
    function sign(msgHash, privKey, opts = defaultSigOpts) {
      const { seed, k2sig } = prepSig(msgHash, privKey, opts);
      const C = CURVE;
      const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
      return drbg(seed, k2sig);
    }
    Point3.BASE._setWindowSize(8);
    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
      const sg = signature;
      msgHash = ensureBytes("msgHash", msgHash);
      publicKey = ensureBytes("publicKey", publicKey);
      if ("strict" in opts)
        throw new Error("options.strict was renamed to lowS");
      const { lowS, prehash } = opts;
      let _sig = void 0;
      let P;
      try {
        if (typeof sg === "string" || isBytes2(sg)) {
          try {
            _sig = Signature.fromDER(sg);
          } catch (derError) {
            if (!(derError instanceof DER.Err))
              throw derError;
            _sig = Signature.fromCompact(sg);
          }
        } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
          const { r: r2, s: s2 } = sg;
          _sig = new Signature(r2, s2);
        } else {
          throw new Error("PARSE");
        }
        P = Point3.fromHex(publicKey);
      } catch (error) {
        if (error.message === "PARSE")
          throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
        return false;
      }
      if (lowS && _sig.hasHighS())
        return false;
      if (prehash)
        msgHash = CURVE.hash(msgHash);
      const { r, s } = _sig;
      const h = bits2int_modN(msgHash);
      const is = invN(s);
      const u1 = modN(h * is);
      const u2 = modN(r * is);
      const R = Point3.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();
      if (!R)
        return false;
      const v = modN(R.x);
      return v === r;
    }
    return {
      CURVE,
      getPublicKey,
      getSharedSecret,
      sign,
      verify,
      ProjectivePoint: Point3,
      Signature,
      utils: utils2
    };
  }

  // node_modules/ethereum-cryptography/node_modules/@noble/curves/esm/_shortw_utils.js
  function getHash(hash3) {
    return {
      hash: hash3,
      hmac: (key, ...msgs) => hmac(hash3, key, concatBytes(...msgs)),
      randomBytes
    };
  }
  function createCurve(curveDef, defHash) {
    const create = (hash3) => weierstrass({ ...curveDef, ...getHash(hash3) });
    return Object.freeze({ ...create(defHash), create });
  }

  // node_modules/ethereum-cryptography/node_modules/@noble/curves/esm/secp256k1.js
  var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
  var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
  var _1n6 = BigInt(1);
  var _2n5 = BigInt(2);
  var divNearest = (a, b) => (a + b / _2n5) / b;
  function sqrtMod(y) {
    const P = secp256k1P;
    const _3n5 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    const b2 = y * y * y % P;
    const b3 = b2 * b2 * y % P;
    const b6 = pow2(b3, _3n5, P) * b3 % P;
    const b9 = pow2(b6, _3n5, P) * b3 % P;
    const b11 = pow2(b9, _2n5, P) * b2 % P;
    const b22 = pow2(b11, _11n, P) * b11 % P;
    const b44 = pow2(b22, _22n, P) * b22 % P;
    const b88 = pow2(b44, _44n, P) * b44 % P;
    const b176 = pow2(b88, _88n, P) * b88 % P;
    const b220 = pow2(b176, _44n, P) * b44 % P;
    const b223 = pow2(b220, _3n5, P) * b3 % P;
    const t1 = pow2(b223, _23n, P) * b22 % P;
    const t2 = pow2(t1, _6n, P) * b2 % P;
    const root = pow2(t2, _2n5, P);
    if (!Fp.eql(Fp.sqr(root), y))
      throw new Error("Cannot find square root");
    return root;
  }
  var Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
  var secp256k1 = createCurve({
    a: BigInt(0),
    // equation params: a, b
    b: BigInt(7),
    // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
    Fp,
    // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
    n: secp256k1N,
    // Curve order, total count of valid points in the field
    // Base point (x, y) aka generator point
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    h: BigInt(1),
    // Cofactor
    lowS: true,
    // Allow only low-S signatures by default in sign() and verify()
    /**
     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
     */
    endo: {
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
      splitScalar: (k) => {
        const n = secp256k1N;
        const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
        const b1 = -_1n6 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
        const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
        const b2 = a1;
        const POW_2_128 = BigInt("0x100000000000000000000000000000000");
        const c1 = divNearest(b2 * k, n);
        const c2 = divNearest(-b1 * k, n);
        let k1 = mod(k - c1 * a1 - c2 * a2, n);
        let k2 = mod(-c1 * b1 - c2 * b2, n);
        const k1neg = k1 > POW_2_128;
        const k2neg = k2 > POW_2_128;
        if (k1neg)
          k1 = n - k1;
        if (k2neg)
          k2 = n - k2;
        if (k1 > POW_2_128 || k2 > POW_2_128) {
          throw new Error("splitScalar: Endomorphism failed, k=" + k);
        }
        return { k1neg, k1, k2neg, k2 };
      }
    }
  }, sha256);
  var _0n6 = BigInt(0);
  var Point = secp256k1.ProjectivePoint;

  // node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/pbkdf2.js
  function pbkdf2Init(hash3, _password, _salt, _opts) {
    hash(hash3);
    const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
    const { c, dkLen, asyncTick } = opts;
    number(c);
    number(dkLen);
    number(asyncTick);
    if (c < 1)
      throw new Error("PBKDF2: iterations (c) should be >= 1");
    const password = toBytes(_password);
    const salt = toBytes(_salt);
    const DK = new Uint8Array(dkLen);
    const PRF = hmac.create(hash3, password);
    const PRFSalt = PRF._cloneInto().update(salt);
    return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
  }
  function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
    PRF.destroy();
    PRFSalt.destroy();
    if (prfW)
      prfW.destroy();
    u.fill(0);
    return DK;
  }
  function pbkdf2(hash3, password, salt, opts) {
    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash3, password, salt, opts);
    let prfW;
    const arr = new Uint8Array(4);
    const view = createView(arr);
    const u = new Uint8Array(PRF.outputLen);
    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
      const Ti = DK.subarray(pos, pos + PRF.outputLen);
      view.setInt32(0, ti, false);
      (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
      Ti.set(u.subarray(0, Ti.length));
      for (let ui = 1; ui < c; ui++) {
        PRF._cloneInto(prfW).update(u).digestInto(u);
        for (let i = 0; i < Ti.length; i++)
          Ti[i] ^= u[i];
      }
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
  }

  // node_modules/ethereum-cryptography/node_modules/@noble/hashes/esm/scrypt.js
  function XorAndSalsa(prev, pi, input, ii, out, oi) {
    let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];
    let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];
    let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];
    let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];
    let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];
    let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];
    let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];
    let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];
    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
    for (let i = 0; i < 8; i += 2) {
      x04 ^= rotl(x00 + x12 | 0, 7);
      x08 ^= rotl(x04 + x00 | 0, 9);
      x12 ^= rotl(x08 + x04 | 0, 13);
      x00 ^= rotl(x12 + x08 | 0, 18);
      x09 ^= rotl(x05 + x01 | 0, 7);
      x13 ^= rotl(x09 + x05 | 0, 9);
      x01 ^= rotl(x13 + x09 | 0, 13);
      x05 ^= rotl(x01 + x13 | 0, 18);
      x14 ^= rotl(x10 + x06 | 0, 7);
      x02 ^= rotl(x14 + x10 | 0, 9);
      x06 ^= rotl(x02 + x14 | 0, 13);
      x10 ^= rotl(x06 + x02 | 0, 18);
      x03 ^= rotl(x15 + x11 | 0, 7);
      x07 ^= rotl(x03 + x15 | 0, 9);
      x11 ^= rotl(x07 + x03 | 0, 13);
      x15 ^= rotl(x11 + x07 | 0, 18);
      x01 ^= rotl(x00 + x03 | 0, 7);
      x02 ^= rotl(x01 + x00 | 0, 9);
      x03 ^= rotl(x02 + x01 | 0, 13);
      x00 ^= rotl(x03 + x02 | 0, 18);
      x06 ^= rotl(x05 + x04 | 0, 7);
      x07 ^= rotl(x06 + x05 | 0, 9);
      x04 ^= rotl(x07 + x06 | 0, 13);
      x05 ^= rotl(x04 + x07 | 0, 18);
      x11 ^= rotl(x10 + x09 | 0, 7);
      x08 ^= rotl(x11 + x10 | 0, 9);
      x09 ^= rotl(x08 + x11 | 0, 13);
      x10 ^= rotl(x09 + x08 | 0, 18);
      x12 ^= rotl(x15 + x14 | 0, 7);
      x13 ^= rotl(x12 + x15 | 0, 9);
      x14 ^= rotl(x13 + x12 | 0, 13);
      x15 ^= rotl(x14 + x13 | 0, 18);
    }
    out[oi++] = y00 + x00 | 0;
    out[oi++] = y01 + x01 | 0;
    out[oi++] = y02 + x02 | 0;
    out[oi++] = y03 + x03 | 0;
    out[oi++] = y04 + x04 | 0;
    out[oi++] = y05 + x05 | 0;
    out[oi++] = y06 + x06 | 0;
    out[oi++] = y07 + x07 | 0;
    out[oi++] = y08 + x08 | 0;
    out[oi++] = y09 + x09 | 0;
    out[oi++] = y10 + x10 | 0;
    out[oi++] = y11 + x11 | 0;
    out[oi++] = y12 + x12 | 0;
    out[oi++] = y13 + x13 | 0;
    out[oi++] = y14 + x14 | 0;
    out[oi++] = y15 + x15 | 0;
  }
  function BlockMix(input, ii, out, oi, r) {
    let head = oi + 0;
    let tail = oi + 16 * r;
    for (let i = 0; i < 16; i++)
      out[tail + i] = input[ii + (2 * r - 1) * 16 + i];
    for (let i = 0; i < r; i++, head += 16, ii += 16) {
      XorAndSalsa(out, tail, input, ii, out, head);
      if (i > 0)
        tail += 16;
      XorAndSalsa(out, head, input, ii += 16, out, tail);
    }
  }
  function scryptInit(password, salt, _opts) {
    const opts = checkOpts({
      dkLen: 32,
      asyncTick: 10,
      maxmem: 1024 ** 3 + 1024
    }, _opts);
    const { N, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;
    number(N);
    number(r);
    number(p);
    number(dkLen);
    number(asyncTick);
    number(maxmem);
    if (onProgress !== void 0 && typeof onProgress !== "function")
      throw new Error("progressCb should be function");
    const blockSize = 128 * r;
    const blockSize32 = blockSize / 4;
    if (N <= 1 || (N & N - 1) !== 0 || N >= 2 ** (blockSize / 8) || N > 2 ** 32) {
      throw new Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32");
    }
    if (p < 0 || p > (2 ** 32 - 1) * 32 / blockSize) {
      throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
    }
    if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {
      throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
    }
    const memUsed = blockSize * (N + p);
    if (memUsed > maxmem) {
      throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`);
    }
    const B = pbkdf2(sha256, password, salt, { c: 1, dkLen: blockSize * p });
    const B32 = u32(B);
    const V = u32(new Uint8Array(blockSize * N));
    const tmp = u32(new Uint8Array(blockSize));
    let blockMixCb = () => {
    };
    if (onProgress) {
      const totalBlockMix = 2 * N * p;
      const callbackPer = Math.max(Math.floor(totalBlockMix / 1e4), 1);
      let blockMixCnt = 0;
      blockMixCb = () => {
        blockMixCnt++;
        if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))
          onProgress(blockMixCnt / totalBlockMix);
      };
    }
    return { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };
  }
  function scryptOutput(password, dkLen, B, V, tmp) {
    const res = pbkdf2(sha256, password, B, { c: 1, dkLen });
    B.fill(0);
    V.fill(0);
    tmp.fill(0);
    return res;
  }
  async function scryptAsync(password, salt, opts) {
    const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick } = scryptInit(password, salt, opts);
    if (!isLE)
      byteSwap32(B32);
    for (let pi = 0; pi < p; pi++) {
      const Pi = blockSize32 * pi;
      for (let i = 0; i < blockSize32; i++)
        V[i] = B32[Pi + i];
      let pos = 0;
      await asyncLoop(N - 1, asyncTick, () => {
        BlockMix(V, pos, V, pos += blockSize32, r);
        blockMixCb();
      });
      BlockMix(V, (N - 1) * blockSize32, B32, Pi, r);
      blockMixCb();
      await asyncLoop(N, asyncTick, () => {
        const j = B32[Pi + blockSize32 - 16] % N;
        for (let k = 0; k < blockSize32; k++)
          tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k];
        BlockMix(tmp, 0, B32, Pi, r);
        blockMixCb();
      });
    }
    if (!isLE)
      byteSwap32(B32);
    return scryptOutput(password, dkLen, B, V, tmp);
  }

  // node_modules/ethereum-cryptography/esm/scrypt.js
  async function scrypt2(password, salt, n, p, r, dkLen, onProgress) {
    assertBytes(password);
    assertBytes(salt);
    return scryptAsync(password, salt, { N: n, r, p, dkLen, onProgress });
  }

  // node_modules/ethereum-cryptography/esm/random.js
  function getRandomBytesSync(bytes2) {
    return randomBytes(bytes2);
  }

  // node_modules/@noble/hashes/esm/crypto.js
  var crypto4 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

  // node_modules/@noble/hashes/esm/utils.js
  function isBytes3(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
  }
  function anumber(n) {
    if (!Number.isSafeInteger(n) || n < 0)
      throw new Error("positive integer expected, got " + n);
  }
  function abytes2(b, ...lengths) {
    if (!isBytes3(b))
      throw new Error("Uint8Array expected");
    if (lengths.length > 0 && !lengths.includes(b.length))
      throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
  }
  function ahash(h) {
    if (typeof h !== "function" || typeof h.create !== "function")
      throw new Error("Hash should be wrapped by utils.createHasher");
    anumber(h.outputLen);
    anumber(h.blockLen);
  }
  function aexists(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function aoutput(out, instance) {
    abytes2(out);
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error("digestInto() expects output buffer of length at least " + min);
    }
  }
  function clean(...arrays) {
    for (let i = 0; i < arrays.length; i++) {
      arrays[i].fill(0);
    }
  }
  function createView2(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  }
  function rotr2(word, shift) {
    return word << 32 - shift | word >>> shift;
  }
  function rotl2(word, shift) {
    return word << shift | word >>> 32 - shift >>> 0;
  }
  var hasHexBuiltin = /* @__PURE__ */ (() => (
    // @ts-ignore
    typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
  ))();
  var hexes3 = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
  function bytesToHex3(bytes2) {
    abytes2(bytes2);
    if (hasHexBuiltin)
      return bytes2.toHex();
    let hex = "";
    for (let i = 0; i < bytes2.length; i++) {
      hex += hexes3[bytes2[i]];
    }
    return hex;
  }
  var asciis3 = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
  function asciiToBase163(ch) {
    if (ch >= asciis3._0 && ch <= asciis3._9)
      return ch - asciis3._0;
    if (ch >= asciis3.A && ch <= asciis3.F)
      return ch - (asciis3.A - 10);
    if (ch >= asciis3.a && ch <= asciis3.f)
      return ch - (asciis3.a - 10);
    return;
  }
  function hexToBytes4(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    if (hasHexBuiltin)
      return Uint8Array.fromHex(hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2)
      throw new Error("hex string expected, got unpadded hex of length " + hl);
    const array = new Uint8Array(al);
    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
      const n1 = asciiToBase163(hex.charCodeAt(hi));
      const n2 = asciiToBase163(hex.charCodeAt(hi + 1));
      if (n1 === void 0 || n2 === void 0) {
        const char = hex[hi] + hex[hi + 1];
        throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
      }
      array[ai] = n1 * 16 + n2;
    }
    return array;
  }
  function utf8ToBytes3(str) {
    if (typeof str !== "string")
      throw new Error("string expected");
    return new Uint8Array(new TextEncoder().encode(str));
  }
  function toBytes2(data) {
    if (typeof data === "string")
      data = utf8ToBytes3(data);
    abytes2(data);
    return data;
  }
  function kdfInputToBytes(data) {
    if (typeof data === "string")
      data = utf8ToBytes3(data);
    abytes2(data);
    return data;
  }
  function concatBytes3(...arrays) {
    let sum = 0;
    for (let i = 0; i < arrays.length; i++) {
      const a = arrays[i];
      abytes2(a);
      sum += a.length;
    }
    const res = new Uint8Array(sum);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
      const a = arrays[i];
      res.set(a, pad);
      pad += a.length;
    }
    return res;
  }
  function checkOpts2(defaults, opts) {
    if (opts !== void 0 && {}.toString.call(opts) !== "[object Object]")
      throw new Error("options should be object or undefined");
    const merged = Object.assign(defaults, opts);
    return merged;
  }
  var Hash2 = class {
  };
  function createHasher(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes2(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
  }
  function randomBytes2(bytesLength = 32) {
    if (crypto4 && typeof crypto4.getRandomValues === "function") {
      return crypto4.getRandomValues(new Uint8Array(bytesLength));
    }
    if (crypto4 && typeof crypto4.randomBytes === "function") {
      return Uint8Array.from(crypto4.randomBytes(bytesLength));
    }
    throw new Error("crypto.getRandomValues must be defined");
  }

  // node_modules/@noble/hashes/esm/hmac.js
  var HMAC2 = class extends Hash2 {
    constructor(hash3, _key) {
      super();
      this.finished = false;
      this.destroyed = false;
      ahash(hash3);
      const key = toBytes2(_key);
      this.iHash = hash3.create();
      if (typeof this.iHash.update !== "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen;
      this.outputLen = this.iHash.outputLen;
      const blockLen = this.blockLen;
      const pad = new Uint8Array(blockLen);
      pad.set(key.length > blockLen ? hash3.create().update(key).digest() : key);
      for (let i = 0; i < pad.length; i++)
        pad[i] ^= 54;
      this.iHash.update(pad);
      this.oHash = hash3.create();
      for (let i = 0; i < pad.length; i++)
        pad[i] ^= 54 ^ 92;
      this.oHash.update(pad);
      clean(pad);
    }
    update(buf) {
      aexists(this);
      this.iHash.update(buf);
      return this;
    }
    digestInto(out) {
      aexists(this);
      abytes2(out, this.outputLen);
      this.finished = true;
      this.iHash.digestInto(out);
      this.oHash.update(out);
      this.oHash.digestInto(out);
      this.destroy();
    }
    digest() {
      const out = new Uint8Array(this.oHash.outputLen);
      this.digestInto(out);
      return out;
    }
    _cloneInto(to) {
      to || (to = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
      to = to;
      to.finished = finished;
      to.destroyed = destroyed;
      to.blockLen = blockLen;
      to.outputLen = outputLen;
      to.oHash = oHash._cloneInto(to.oHash);
      to.iHash = iHash._cloneInto(to.iHash);
      return to;
    }
    clone() {
      return this._cloneInto();
    }
    destroy() {
      this.destroyed = true;
      this.oHash.destroy();
      this.iHash.destroy();
    }
  };
  var hmac2 = (hash3, key, message) => new HMAC2(hash3, key).update(message).digest();
  hmac2.create = (hash3, key) => new HMAC2(hash3, key);

  // node_modules/@noble/hashes/esm/pbkdf2.js
  function pbkdf2Init2(hash3, _password, _salt, _opts) {
    ahash(hash3);
    const opts = checkOpts2({ dkLen: 32, asyncTick: 10 }, _opts);
    const { c, dkLen, asyncTick } = opts;
    anumber(c);
    anumber(dkLen);
    anumber(asyncTick);
    if (c < 1)
      throw new Error("iterations (c) should be >= 1");
    const password = kdfInputToBytes(_password);
    const salt = kdfInputToBytes(_salt);
    const DK = new Uint8Array(dkLen);
    const PRF = hmac2.create(hash3, password);
    const PRFSalt = PRF._cloneInto().update(salt);
    return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
  }
  function pbkdf2Output2(PRF, PRFSalt, DK, prfW, u) {
    PRF.destroy();
    PRFSalt.destroy();
    if (prfW)
      prfW.destroy();
    clean(u);
    return DK;
  }
  function pbkdf22(hash3, password, salt, opts) {
    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init2(hash3, password, salt, opts);
    let prfW;
    const arr = new Uint8Array(4);
    const view = createView2(arr);
    const u = new Uint8Array(PRF.outputLen);
    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
      const Ti = DK.subarray(pos, pos + PRF.outputLen);
      view.setInt32(0, ti, false);
      (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
      Ti.set(u.subarray(0, Ti.length));
      for (let ui = 1; ui < c; ui++) {
        PRF._cloneInto(prfW).update(u).digestInto(u);
        for (let i = 0; i < Ti.length; i++)
          Ti[i] ^= u[i];
      }
    }
    return pbkdf2Output2(PRF, PRFSalt, DK, prfW, u);
  }

  // node_modules/@noble/hashes/esm/_md.js
  function setBigUint642(view, byteOffset, value, isLE2) {
    if (typeof view.setBigUint64 === "function")
      return view.setBigUint64(byteOffset, value, isLE2);
    const _32n3 = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh = Number(value >> _32n3 & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE2 ? 4 : 0;
    const l = isLE2 ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE2);
    view.setUint32(byteOffset + l, wl, isLE2);
  }
  function Chi2(a, b, c) {
    return a & b ^ ~a & c;
  }
  function Maj2(a, b, c) {
    return a & b ^ a & c ^ b & c;
  }
  var HashMD2 = class extends Hash2 {
    constructor(blockLen, outputLen, padOffset, isLE2) {
      super();
      this.finished = false;
      this.length = 0;
      this.pos = 0;
      this.destroyed = false;
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.padOffset = padOffset;
      this.isLE = isLE2;
      this.buffer = new Uint8Array(blockLen);
      this.view = createView2(this.buffer);
    }
    update(data) {
      aexists(this);
      data = toBytes2(data);
      abytes2(data);
      const { view, buffer, blockLen } = this;
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        if (take === blockLen) {
          const dataView = createView2(data);
          for (; blockLen <= len - pos; pos += blockLen)
            this.process(dataView, pos);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      aexists(this);
      aoutput(out, this);
      this.finished = true;
      const { buffer, view, blockLen, isLE: isLE2 } = this;
      let { pos } = this;
      buffer[pos++] = 128;
      clean(this.buffer.subarray(pos));
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let i = pos; i < blockLen; i++)
        buffer[i] = 0;
      setBigUint642(view, blockLen - 8, BigInt(this.length * 8), isLE2);
      this.process(view, 0);
      const oview = createView2(out);
      const len = this.outputLen;
      if (len % 4)
        throw new Error("_sha2: outputLen should be aligned to 32bit");
      const outLen = len / 4;
      const state = this.get();
      if (outLen > state.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let i = 0; i < outLen; i++)
        oview.setUint32(4 * i, state[i], isLE2);
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to) {
      to || (to = new this.constructor());
      to.set(...this.get());
      const { blockLen, buffer, length, finished, destroyed, pos } = this;
      to.destroyed = destroyed;
      to.finished = finished;
      to.length = length;
      to.pos = pos;
      if (length % blockLen)
        to.buffer.set(buffer);
      return to;
    }
    clone() {
      return this._cloneInto();
    }
  };
  var SHA256_IV2 = /* @__PURE__ */ Uint32Array.from([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  var SHA512_IV = /* @__PURE__ */ Uint32Array.from([
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ]);

  // node_modules/@noble/hashes/esm/_u64.js
  var U32_MASK642 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
  var _32n2 = /* @__PURE__ */ BigInt(32);
  function fromBig2(n, le = false) {
    if (le)
      return { h: Number(n & U32_MASK642), l: Number(n >> _32n2 & U32_MASK642) };
    return { h: Number(n >> _32n2 & U32_MASK642) | 0, l: Number(n & U32_MASK642) | 0 };
  }
  function split2(lst, le = false) {
    const len = lst.length;
    let Ah = new Uint32Array(len);
    let Al = new Uint32Array(len);
    for (let i = 0; i < len; i++) {
      const { h, l } = fromBig2(lst[i], le);
      [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
  }
  var shrSH = (h, _l, s) => h >>> s;
  var shrSL = (h, l, s) => h << 32 - s | l >>> s;
  var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
  var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
  var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
  var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
  function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
  }
  var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
  var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
  var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
  var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
  var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
  var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;

  // node_modules/@noble/hashes/esm/sha2.js
  var SHA256_K2 = /* @__PURE__ */ Uint32Array.from([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  var SHA256_W2 = /* @__PURE__ */ new Uint32Array(64);
  var SHA2562 = class extends HashMD2 {
    constructor(outputLen = 32) {
      super(64, outputLen, 8, false);
      this.A = SHA256_IV2[0] | 0;
      this.B = SHA256_IV2[1] | 0;
      this.C = SHA256_IV2[2] | 0;
      this.D = SHA256_IV2[3] | 0;
      this.E = SHA256_IV2[4] | 0;
      this.F = SHA256_IV2[5] | 0;
      this.G = SHA256_IV2[6] | 0;
      this.H = SHA256_IV2[7] | 0;
    }
    get() {
      const { A, B, C, D, E, F, G, H } = this;
      return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D | 0;
      this.E = E | 0;
      this.F = F | 0;
      this.G = G | 0;
      this.H = H | 0;
    }
    process(view, offset) {
      for (let i = 0; i < 16; i++, offset += 4)
        SHA256_W2[i] = view.getUint32(offset, false);
      for (let i = 16; i < 64; i++) {
        const W15 = SHA256_W2[i - 15];
        const W2 = SHA256_W2[i - 2];
        const s0 = rotr2(W15, 7) ^ rotr2(W15, 18) ^ W15 >>> 3;
        const s1 = rotr2(W2, 17) ^ rotr2(W2, 19) ^ W2 >>> 10;
        SHA256_W2[i] = s1 + SHA256_W2[i - 7] + s0 + SHA256_W2[i - 16] | 0;
      }
      let { A, B, C, D, E, F, G, H } = this;
      for (let i = 0; i < 64; i++) {
        const sigma1 = rotr2(E, 6) ^ rotr2(E, 11) ^ rotr2(E, 25);
        const T1 = H + sigma1 + Chi2(E, F, G) + SHA256_K2[i] + SHA256_W2[i] | 0;
        const sigma0 = rotr2(A, 2) ^ rotr2(A, 13) ^ rotr2(A, 22);
        const T2 = sigma0 + Maj2(A, B, C) | 0;
        H = G;
        G = F;
        F = E;
        E = D + T1 | 0;
        D = C;
        C = B;
        B = A;
        A = T1 + T2 | 0;
      }
      A = A + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D = D + this.D | 0;
      E = E + this.E | 0;
      F = F + this.F | 0;
      G = G + this.G | 0;
      H = H + this.H | 0;
      this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
      clean(SHA256_W2);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      clean(this.buffer);
    }
  };
  var K512 = /* @__PURE__ */ (() => split2([
    "0x428a2f98d728ae22",
    "0x7137449123ef65cd",
    "0xb5c0fbcfec4d3b2f",
    "0xe9b5dba58189dbbc",
    "0x3956c25bf348b538",
    "0x59f111f1b605d019",
    "0x923f82a4af194f9b",
    "0xab1c5ed5da6d8118",
    "0xd807aa98a3030242",
    "0x12835b0145706fbe",
    "0x243185be4ee4b28c",
    "0x550c7dc3d5ffb4e2",
    "0x72be5d74f27b896f",
    "0x80deb1fe3b1696b1",
    "0x9bdc06a725c71235",
    "0xc19bf174cf692694",
    "0xe49b69c19ef14ad2",
    "0xefbe4786384f25e3",
    "0x0fc19dc68b8cd5b5",
    "0x240ca1cc77ac9c65",
    "0x2de92c6f592b0275",
    "0x4a7484aa6ea6e483",
    "0x5cb0a9dcbd41fbd4",
    "0x76f988da831153b5",
    "0x983e5152ee66dfab",
    "0xa831c66d2db43210",
    "0xb00327c898fb213f",
    "0xbf597fc7beef0ee4",
    "0xc6e00bf33da88fc2",
    "0xd5a79147930aa725",
    "0x06ca6351e003826f",
    "0x142929670a0e6e70",
    "0x27b70a8546d22ffc",
    "0x2e1b21385c26c926",
    "0x4d2c6dfc5ac42aed",
    "0x53380d139d95b3df",
    "0x650a73548baf63de",
    "0x766a0abb3c77b2a8",
    "0x81c2c92e47edaee6",
    "0x92722c851482353b",
    "0xa2bfe8a14cf10364",
    "0xa81a664bbc423001",
    "0xc24b8b70d0f89791",
    "0xc76c51a30654be30",
    "0xd192e819d6ef5218",
    "0xd69906245565a910",
    "0xf40e35855771202a",
    "0x106aa07032bbd1b8",
    "0x19a4c116b8d2d0c8",
    "0x1e376c085141ab53",
    "0x2748774cdf8eeb99",
    "0x34b0bcb5e19b48a8",
    "0x391c0cb3c5c95a63",
    "0x4ed8aa4ae3418acb",
    "0x5b9cca4f7763e373",
    "0x682e6ff3d6b2b8a3",
    "0x748f82ee5defb2fc",
    "0x78a5636f43172f60",
    "0x84c87814a1f0ab72",
    "0x8cc702081a6439ec",
    "0x90befffa23631e28",
    "0xa4506cebde82bde9",
    "0xbef9a3f7b2c67915",
    "0xc67178f2e372532b",
    "0xca273eceea26619c",
    "0xd186b8c721c0c207",
    "0xeada7dd6cde0eb1e",
    "0xf57d4f7fee6ed178",
    "0x06f067aa72176fba",
    "0x0a637dc5a2c898a6",
    "0x113f9804bef90dae",
    "0x1b710b35131c471b",
    "0x28db77f523047d84",
    "0x32caab7b40c72493",
    "0x3c9ebe0a15c9bebc",
    "0x431d67c49c100d4c",
    "0x4cc5d4becb3e42b6",
    "0x597f299cfc657e2a",
    "0x5fcb6fab3ad6faec",
    "0x6c44198c4a475817"
  ].map((n) => BigInt(n))))();
  var SHA512_Kh = /* @__PURE__ */ (() => K512[0])();
  var SHA512_Kl = /* @__PURE__ */ (() => K512[1])();
  var SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
  var SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
  var SHA512 = class extends HashMD2 {
    constructor(outputLen = 64) {
      super(128, outputLen, 16, false);
      this.Ah = SHA512_IV[0] | 0;
      this.Al = SHA512_IV[1] | 0;
      this.Bh = SHA512_IV[2] | 0;
      this.Bl = SHA512_IV[3] | 0;
      this.Ch = SHA512_IV[4] | 0;
      this.Cl = SHA512_IV[5] | 0;
      this.Dh = SHA512_IV[6] | 0;
      this.Dl = SHA512_IV[7] | 0;
      this.Eh = SHA512_IV[8] | 0;
      this.El = SHA512_IV[9] | 0;
      this.Fh = SHA512_IV[10] | 0;
      this.Fl = SHA512_IV[11] | 0;
      this.Gh = SHA512_IV[12] | 0;
      this.Gl = SHA512_IV[13] | 0;
      this.Hh = SHA512_IV[14] | 0;
      this.Hl = SHA512_IV[15] | 0;
    }
    // prettier-ignore
    get() {
      const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
    }
    // prettier-ignore
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
      this.Ah = Ah | 0;
      this.Al = Al | 0;
      this.Bh = Bh | 0;
      this.Bl = Bl | 0;
      this.Ch = Ch | 0;
      this.Cl = Cl | 0;
      this.Dh = Dh | 0;
      this.Dl = Dl | 0;
      this.Eh = Eh | 0;
      this.El = El | 0;
      this.Fh = Fh | 0;
      this.Fl = Fl | 0;
      this.Gh = Gh | 0;
      this.Gl = Gl | 0;
      this.Hh = Hh | 0;
      this.Hl = Hl | 0;
    }
    process(view, offset) {
      for (let i = 0; i < 16; i++, offset += 4) {
        SHA512_W_H[i] = view.getUint32(offset);
        SHA512_W_L[i] = view.getUint32(offset += 4);
      }
      for (let i = 16; i < 80; i++) {
        const W15h = SHA512_W_H[i - 15] | 0;
        const W15l = SHA512_W_L[i - 15] | 0;
        const s0h = rotrSH(W15h, W15l, 1) ^ rotrSH(W15h, W15l, 8) ^ shrSH(W15h, W15l, 7);
        const s0l = rotrSL(W15h, W15l, 1) ^ rotrSL(W15h, W15l, 8) ^ shrSL(W15h, W15l, 7);
        const W2h = SHA512_W_H[i - 2] | 0;
        const W2l = SHA512_W_L[i - 2] | 0;
        const s1h = rotrSH(W2h, W2l, 19) ^ rotrBH(W2h, W2l, 61) ^ shrSH(W2h, W2l, 6);
        const s1l = rotrSL(W2h, W2l, 19) ^ rotrBL(W2h, W2l, 61) ^ shrSL(W2h, W2l, 6);
        const SUMl = add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
        const SUMh = add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
        SHA512_W_H[i] = SUMh | 0;
        SHA512_W_L[i] = SUMl | 0;
      }
      let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      for (let i = 0; i < 80; i++) {
        const sigma1h = rotrSH(Eh, El, 14) ^ rotrSH(Eh, El, 18) ^ rotrBH(Eh, El, 41);
        const sigma1l = rotrSL(Eh, El, 14) ^ rotrSL(Eh, El, 18) ^ rotrBL(Eh, El, 41);
        const CHIh = Eh & Fh ^ ~Eh & Gh;
        const CHIl = El & Fl ^ ~El & Gl;
        const T1ll = add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
        const T1h = add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
        const T1l = T1ll | 0;
        const sigma0h = rotrSH(Ah, Al, 28) ^ rotrBH(Ah, Al, 34) ^ rotrBH(Ah, Al, 39);
        const sigma0l = rotrSL(Ah, Al, 28) ^ rotrBL(Ah, Al, 34) ^ rotrBL(Ah, Al, 39);
        const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
        const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
        Hh = Gh | 0;
        Hl = Gl | 0;
        Gh = Fh | 0;
        Gl = Fl | 0;
        Fh = Eh | 0;
        Fl = El | 0;
        ({ h: Eh, l: El } = add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
        Dh = Ch | 0;
        Dl = Cl | 0;
        Ch = Bh | 0;
        Cl = Bl | 0;
        Bh = Ah | 0;
        Bl = Al | 0;
        const All = add3L(T1l, sigma0l, MAJl);
        Ah = add3H(All, T1h, sigma0h, MAJh);
        Al = All | 0;
      }
      ({ h: Ah, l: Al } = add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
      ({ h: Bh, l: Bl } = add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
      ({ h: Ch, l: Cl } = add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
      ({ h: Dh, l: Dl } = add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
      ({ h: Eh, l: El } = add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
      ({ h: Fh, l: Fl } = add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
      ({ h: Gh, l: Gl } = add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
      ({ h: Hh, l: Hl } = add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
      this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
      clean(SHA512_W_H, SHA512_W_L);
    }
    destroy() {
      clean(this.buffer);
      this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  };
  var sha2562 = /* @__PURE__ */ createHasher(() => new SHA2562());
  var sha512 = /* @__PURE__ */ createHasher(() => new SHA512());

  // node_modules/@scure/base/lib/esm/index.js
  function isBytes4(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
  }
  function isArrayOf(isString, arr) {
    if (!Array.isArray(arr))
      return false;
    if (arr.length === 0)
      return true;
    if (isString) {
      return arr.every((item) => typeof item === "string");
    } else {
      return arr.every((item) => Number.isSafeInteger(item));
    }
  }
  function afn(input) {
    if (typeof input !== "function")
      throw new Error("function expected");
    return true;
  }
  function astr(label, input) {
    if (typeof input !== "string")
      throw new Error(`${label}: string expected`);
    return true;
  }
  function anumber2(n) {
    if (!Number.isSafeInteger(n))
      throw new Error(`invalid integer: ${n}`);
  }
  function aArr(input) {
    if (!Array.isArray(input))
      throw new Error("array expected");
  }
  function astrArr(label, input) {
    if (!isArrayOf(true, input))
      throw new Error(`${label}: array of strings expected`);
  }
  function anumArr(label, input) {
    if (!isArrayOf(false, input))
      throw new Error(`${label}: array of numbers expected`);
  }
  // @__NO_SIDE_EFFECTS__
  function chain(...args) {
    const id = (a) => a;
    const wrap = (a, b) => (c) => a(b(c));
    const encode2 = args.map((x) => x.encode).reduceRight(wrap, id);
    const decode2 = args.map((x) => x.decode).reduce(wrap, id);
    return { encode: encode2, decode: decode2 };
  }
  // @__NO_SIDE_EFFECTS__
  function alphabet(letters) {
    const lettersA = typeof letters === "string" ? letters.split("") : letters;
    const len = lettersA.length;
    astrArr("alphabet", lettersA);
    const indexes = new Map(lettersA.map((l, i) => [l, i]));
    return {
      encode: (digits) => {
        aArr(digits);
        return digits.map((i) => {
          if (!Number.isSafeInteger(i) || i < 0 || i >= len)
            throw new Error(`alphabet.encode: digit index outside alphabet "${i}". Allowed: ${letters}`);
          return lettersA[i];
        });
      },
      decode: (input) => {
        aArr(input);
        return input.map((letter) => {
          astr("alphabet.decode", letter);
          const i = indexes.get(letter);
          if (i === void 0)
            throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
          return i;
        });
      }
    };
  }
  // @__NO_SIDE_EFFECTS__
  function join(separator = "") {
    astr("join", separator);
    return {
      encode: (from) => {
        astrArr("join.decode", from);
        return from.join(separator);
      },
      decode: (to) => {
        astr("join.decode", to);
        return to.split(separator);
      }
    };
  }
  // @__NO_SIDE_EFFECTS__
  function padding(bits, chr = "=") {
    anumber2(bits);
    astr("padding", chr);
    return {
      encode(data) {
        astrArr("padding.encode", data);
        while (data.length * bits % 8)
          data.push(chr);
        return data;
      },
      decode(input) {
        astrArr("padding.decode", input);
        let end = input.length;
        if (end * bits % 8)
          throw new Error("padding: invalid, string should have whole number of bytes");
        for (; end > 0 && input[end - 1] === chr; end--) {
          const last = end - 1;
          const byte = last * bits;
          if (byte % 8 === 0)
            throw new Error("padding: invalid, string has too much padding");
        }
        return input.slice(0, end);
      }
    };
  }
  function convertRadix(data, from, to) {
    if (from < 2)
      throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);
    if (to < 2)
      throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);
    aArr(data);
    if (!data.length)
      return [];
    let pos = 0;
    const res = [];
    const digits = Array.from(data, (d) => {
      anumber2(d);
      if (d < 0 || d >= from)
        throw new Error(`invalid integer: ${d}`);
      return d;
    });
    const dlen = digits.length;
    while (true) {
      let carry = 0;
      let done = true;
      for (let i = pos; i < dlen; i++) {
        const digit = digits[i];
        const fromCarry = from * carry;
        const digitBase = fromCarry + digit;
        if (!Number.isSafeInteger(digitBase) || fromCarry / from !== carry || digitBase - digit !== fromCarry) {
          throw new Error("convertRadix: carry overflow");
        }
        const div = digitBase / to;
        carry = digitBase % to;
        const rounded = Math.floor(div);
        digits[i] = rounded;
        if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)
          throw new Error("convertRadix: carry overflow");
        if (!done)
          continue;
        else if (!rounded)
          pos = i;
        else
          done = false;
      }
      res.push(carry);
      if (done)
        break;
    }
    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)
      res.push(0);
    return res.reverse();
  }
  var gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
  var radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from, to) => from + (to - gcd(from, to));
  var powers = /* @__PURE__ */ (() => {
    let res = [];
    for (let i = 0; i < 40; i++)
      res.push(2 ** i);
    return res;
  })();
  function convertRadix2(data, from, to, padding2) {
    aArr(data);
    if (from <= 0 || from > 32)
      throw new Error(`convertRadix2: wrong from=${from}`);
    if (to <= 0 || to > 32)
      throw new Error(`convertRadix2: wrong to=${to}`);
    if (/* @__PURE__ */ radix2carry(from, to) > 32) {
      throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${/* @__PURE__ */ radix2carry(from, to)}`);
    }
    let carry = 0;
    let pos = 0;
    const max = powers[from];
    const mask = powers[to] - 1;
    const res = [];
    for (const n of data) {
      anumber2(n);
      if (n >= max)
        throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);
      carry = carry << from | n;
      if (pos + from > 32)
        throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
      pos += from;
      for (; pos >= to; pos -= to)
        res.push((carry >> pos - to & mask) >>> 0);
      const pow3 = powers[pos];
      if (pow3 === void 0)
        throw new Error("invalid carry");
      carry &= pow3 - 1;
    }
    carry = carry << to - pos & mask;
    if (!padding2 && pos >= from)
      throw new Error("Excess padding");
    if (!padding2 && carry > 0)
      throw new Error(`Non-zero padding: ${carry}`);
    if (padding2 && pos > 0)
      res.push(carry >>> 0);
    return res;
  }
  // @__NO_SIDE_EFFECTS__
  function radix(num) {
    anumber2(num);
    const _256 = 2 ** 8;
    return {
      encode: (bytes2) => {
        if (!isBytes4(bytes2))
          throw new Error("radix.encode input should be Uint8Array");
        return convertRadix(Array.from(bytes2), _256, num);
      },
      decode: (digits) => {
        anumArr("radix.decode", digits);
        return Uint8Array.from(convertRadix(digits, num, _256));
      }
    };
  }
  // @__NO_SIDE_EFFECTS__
  function radix2(bits, revPadding = false) {
    anumber2(bits);
    if (bits <= 0 || bits > 32)
      throw new Error("radix2: bits should be in (0..32]");
    if (/* @__PURE__ */ radix2carry(8, bits) > 32 || /* @__PURE__ */ radix2carry(bits, 8) > 32)
      throw new Error("radix2: carry overflow");
    return {
      encode: (bytes2) => {
        if (!isBytes4(bytes2))
          throw new Error("radix2.encode input should be Uint8Array");
        return convertRadix2(Array.from(bytes2), 8, bits, !revPadding);
      },
      decode: (digits) => {
        anumArr("radix2.decode", digits);
        return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
      }
    };
  }
  function checksum(len, fn) {
    anumber2(len);
    afn(fn);
    return {
      encode(data) {
        if (!isBytes4(data))
          throw new Error("checksum.encode: input should be Uint8Array");
        const sum = fn(data).slice(0, len);
        const res = new Uint8Array(data.length + len);
        res.set(data);
        res.set(sum, data.length);
        return res;
      },
      decode(data) {
        if (!isBytes4(data))
          throw new Error("checksum.decode: input should be Uint8Array");
        const payload = data.slice(0, -len);
        const oldChecksum = data.slice(-len);
        const newChecksum = fn(payload).slice(0, len);
        for (let i = 0; i < len; i++)
          if (newChecksum[i] !== oldChecksum[i])
            throw new Error("Invalid checksum");
        return payload;
      }
    };
  }
  var utils = {
    alphabet,
    chain,
    checksum,
    convertRadix,
    convertRadix2,
    radix,
    radix2,
    join,
    padding
  };
  var genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc) => /* @__PURE__ */ chain(/* @__PURE__ */ radix(58), /* @__PURE__ */ alphabet(abc), /* @__PURE__ */ join(""));
  var base58 = /* @__PURE__ */ genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
  var createBase58check = (sha2564) => /* @__PURE__ */ chain(checksum(4, (data) => sha2564(sha2564(data))), base58);

  // node_modules/@scure/bip39/esm/index.js
  var isJapanese = (wordlist2) => wordlist2[0] === "\u3042\u3044\u3053\u304F\u3057\u3093";
  function nfkd(str) {
    if (typeof str !== "string")
      throw new TypeError("invalid mnemonic type: " + typeof str);
    return str.normalize("NFKD");
  }
  function normalize(str) {
    const norm = nfkd(str);
    const words = norm.split(" ");
    if (![12, 15, 18, 21, 24].includes(words.length))
      throw new Error("Invalid mnemonic");
    return { nfkd: norm, words };
  }
  function aentropy(ent) {
    abytes2(ent, 16, 20, 24, 28, 32);
  }
  function generateMnemonic(wordlist2, strength = 128) {
    anumber(strength);
    if (strength % 32 !== 0 || strength > 256)
      throw new TypeError("Invalid entropy");
    return entropyToMnemonic(randomBytes2(strength / 8), wordlist2);
  }
  var calcChecksum = (entropy) => {
    const bitsLeft = 8 - entropy.length / 4;
    return new Uint8Array([sha2562(entropy)[0] >> bitsLeft << bitsLeft]);
  };
  function getCoder(wordlist2) {
    if (!Array.isArray(wordlist2) || wordlist2.length !== 2048 || typeof wordlist2[0] !== "string")
      throw new Error("Wordlist: expected array of 2048 strings");
    wordlist2.forEach((i) => {
      if (typeof i !== "string")
        throw new Error("wordlist: non-string element: " + i);
    });
    return utils.chain(utils.checksum(1, calcChecksum), utils.radix2(11, true), utils.alphabet(wordlist2));
  }
  function mnemonicToEntropy(mnemonic, wordlist2) {
    const { words } = normalize(mnemonic);
    const entropy = getCoder(wordlist2).decode(words);
    aentropy(entropy);
    return entropy;
  }
  function entropyToMnemonic(entropy, wordlist2) {
    aentropy(entropy);
    const words = getCoder(wordlist2).encode(entropy);
    return words.join(isJapanese(wordlist2) ? "\u3000" : " ");
  }
  function validateMnemonic(mnemonic, wordlist2) {
    try {
      mnemonicToEntropy(mnemonic, wordlist2);
    } catch (e) {
      return false;
    }
    return true;
  }
  var psalt = (passphrase) => nfkd("mnemonic" + passphrase);
  function mnemonicToSeedSync(mnemonic, passphrase = "") {
    return pbkdf22(sha512, normalize(mnemonic).nfkd, psalt(passphrase), { c: 2048, dkLen: 64 });
  }

  // node_modules/@scure/bip39/esm/wordlists/english.js
  var wordlist = `abandon
ability
able
about
above
absent
absorb
abstract
absurd
abuse
access
accident
account
accuse
achieve
acid
acoustic
acquire
across
act
action
actor
actress
actual
adapt
add
addict
address
adjust
admit
adult
advance
advice
aerobic
affair
afford
afraid
again
age
agent
agree
ahead
aim
air
airport
aisle
alarm
album
alcohol
alert
alien
all
alley
allow
almost
alone
alpha
already
also
alter
always
amateur
amazing
among
amount
amused
analyst
anchor
ancient
anger
angle
angry
animal
ankle
announce
annual
another
answer
antenna
antique
anxiety
any
apart
apology
appear
apple
approve
april
arch
arctic
area
arena
argue
arm
armed
armor
army
around
arrange
arrest
arrive
arrow
art
artefact
artist
artwork
ask
aspect
assault
asset
assist
assume
asthma
athlete
atom
attack
attend
attitude
attract
auction
audit
august
aunt
author
auto
autumn
average
avocado
avoid
awake
aware
away
awesome
awful
awkward
axis
baby
bachelor
bacon
badge
bag
balance
balcony
ball
bamboo
banana
banner
bar
barely
bargain
barrel
base
basic
basket
battle
beach
bean
beauty
because
become
beef
before
begin
behave
behind
believe
below
belt
bench
benefit
best
betray
better
between
beyond
bicycle
bid
bike
bind
biology
bird
birth
bitter
black
blade
blame
blanket
blast
bleak
bless
blind
blood
blossom
blouse
blue
blur
blush
board
boat
body
boil
bomb
bone
bonus
book
boost
border
boring
borrow
boss
bottom
bounce
box
boy
bracket
brain
brand
brass
brave
bread
breeze
brick
bridge
brief
bright
bring
brisk
broccoli
broken
bronze
broom
brother
brown
brush
bubble
buddy
budget
buffalo
build
bulb
bulk
bullet
bundle
bunker
burden
burger
burst
bus
business
busy
butter
buyer
buzz
cabbage
cabin
cable
cactus
cage
cake
call
calm
camera
camp
can
canal
cancel
candy
cannon
canoe
canvas
canyon
capable
capital
captain
car
carbon
card
cargo
carpet
carry
cart
case
cash
casino
castle
casual
cat
catalog
catch
category
cattle
caught
cause
caution
cave
ceiling
celery
cement
census
century
cereal
certain
chair
chalk
champion
change
chaos
chapter
charge
chase
chat
cheap
check
cheese
chef
cherry
chest
chicken
chief
child
chimney
choice
choose
chronic
chuckle
chunk
churn
cigar
cinnamon
circle
citizen
city
civil
claim
clap
clarify
claw
clay
clean
clerk
clever
click
client
cliff
climb
clinic
clip
clock
clog
close
cloth
cloud
clown
club
clump
cluster
clutch
coach
coast
coconut
code
coffee
coil
coin
collect
color
column
combine
come
comfort
comic
common
company
concert
conduct
confirm
congress
connect
consider
control
convince
cook
cool
copper
copy
coral
core
corn
correct
cost
cotton
couch
country
couple
course
cousin
cover
coyote
crack
cradle
craft
cram
crane
crash
crater
crawl
crazy
cream
credit
creek
crew
cricket
crime
crisp
critic
crop
cross
crouch
crowd
crucial
cruel
cruise
crumble
crunch
crush
cry
crystal
cube
culture
cup
cupboard
curious
current
curtain
curve
cushion
custom
cute
cycle
dad
damage
damp
dance
danger
daring
dash
daughter
dawn
day
deal
debate
debris
decade
december
decide
decline
decorate
decrease
deer
defense
define
defy
degree
delay
deliver
demand
demise
denial
dentist
deny
depart
depend
deposit
depth
deputy
derive
describe
desert
design
desk
despair
destroy
detail
detect
develop
device
devote
diagram
dial
diamond
diary
dice
diesel
diet
differ
digital
dignity
dilemma
dinner
dinosaur
direct
dirt
disagree
discover
disease
dish
dismiss
disorder
display
distance
divert
divide
divorce
dizzy
doctor
document
dog
doll
dolphin
domain
donate
donkey
donor
door
dose
double
dove
draft
dragon
drama
drastic
draw
dream
dress
drift
drill
drink
drip
drive
drop
drum
dry
duck
dumb
dune
during
dust
dutch
duty
dwarf
dynamic
eager
eagle
early
earn
earth
easily
east
easy
echo
ecology
economy
edge
edit
educate
effort
egg
eight
either
elbow
elder
electric
elegant
element
elephant
elevator
elite
else
embark
embody
embrace
emerge
emotion
employ
empower
empty
enable
enact
end
endless
endorse
enemy
energy
enforce
engage
engine
enhance
enjoy
enlist
enough
enrich
enroll
ensure
enter
entire
entry
envelope
episode
equal
equip
era
erase
erode
erosion
error
erupt
escape
essay
essence
estate
eternal
ethics
evidence
evil
evoke
evolve
exact
example
excess
exchange
excite
exclude
excuse
execute
exercise
exhaust
exhibit
exile
exist
exit
exotic
expand
expect
expire
explain
expose
express
extend
extra
eye
eyebrow
fabric
face
faculty
fade
faint
faith
fall
false
fame
family
famous
fan
fancy
fantasy
farm
fashion
fat
fatal
father
fatigue
fault
favorite
feature
february
federal
fee
feed
feel
female
fence
festival
fetch
fever
few
fiber
fiction
field
figure
file
film
filter
final
find
fine
finger
finish
fire
firm
first
fiscal
fish
fit
fitness
fix
flag
flame
flash
flat
flavor
flee
flight
flip
float
flock
floor
flower
fluid
flush
fly
foam
focus
fog
foil
fold
follow
food
foot
force
forest
forget
fork
fortune
forum
forward
fossil
foster
found
fox
fragile
frame
frequent
fresh
friend
fringe
frog
front
frost
frown
frozen
fruit
fuel
fun
funny
furnace
fury
future
gadget
gain
galaxy
gallery
game
gap
garage
garbage
garden
garlic
garment
gas
gasp
gate
gather
gauge
gaze
general
genius
genre
gentle
genuine
gesture
ghost
giant
gift
giggle
ginger
giraffe
girl
give
glad
glance
glare
glass
glide
glimpse
globe
gloom
glory
glove
glow
glue
goat
goddess
gold
good
goose
gorilla
gospel
gossip
govern
gown
grab
grace
grain
grant
grape
grass
gravity
great
green
grid
grief
grit
grocery
group
grow
grunt
guard
guess
guide
guilt
guitar
gun
gym
habit
hair
half
hammer
hamster
hand
happy
harbor
hard
harsh
harvest
hat
have
hawk
hazard
head
health
heart
heavy
hedgehog
height
hello
helmet
help
hen
hero
hidden
high
hill
hint
hip
hire
history
hobby
hockey
hold
hole
holiday
hollow
home
honey
hood
hope
horn
horror
horse
hospital
host
hotel
hour
hover
hub
huge
human
humble
humor
hundred
hungry
hunt
hurdle
hurry
hurt
husband
hybrid
ice
icon
idea
identify
idle
ignore
ill
illegal
illness
image
imitate
immense
immune
impact
impose
improve
impulse
inch
include
income
increase
index
indicate
indoor
industry
infant
inflict
inform
inhale
inherit
initial
inject
injury
inmate
inner
innocent
input
inquiry
insane
insect
inside
inspire
install
intact
interest
into
invest
invite
involve
iron
island
isolate
issue
item
ivory
jacket
jaguar
jar
jazz
jealous
jeans
jelly
jewel
job
join
joke
journey
joy
judge
juice
jump
jungle
junior
junk
just
kangaroo
keen
keep
ketchup
key
kick
kid
kidney
kind
kingdom
kiss
kit
kitchen
kite
kitten
kiwi
knee
knife
knock
know
lab
label
labor
ladder
lady
lake
lamp
language
laptop
large
later
latin
laugh
laundry
lava
law
lawn
lawsuit
layer
lazy
leader
leaf
learn
leave
lecture
left
leg
legal
legend
leisure
lemon
lend
length
lens
leopard
lesson
letter
level
liar
liberty
library
license
life
lift
light
like
limb
limit
link
lion
liquid
list
little
live
lizard
load
loan
lobster
local
lock
logic
lonely
long
loop
lottery
loud
lounge
love
loyal
lucky
luggage
lumber
lunar
lunch
luxury
lyrics
machine
mad
magic
magnet
maid
mail
main
major
make
mammal
man
manage
mandate
mango
mansion
manual
maple
marble
march
margin
marine
market
marriage
mask
mass
master
match
material
math
matrix
matter
maximum
maze
meadow
mean
measure
meat
mechanic
medal
media
melody
melt
member
memory
mention
menu
mercy
merge
merit
merry
mesh
message
metal
method
middle
midnight
milk
million
mimic
mind
minimum
minor
minute
miracle
mirror
misery
miss
mistake
mix
mixed
mixture
mobile
model
modify
mom
moment
monitor
monkey
monster
month
moon
moral
more
morning
mosquito
mother
motion
motor
mountain
mouse
move
movie
much
muffin
mule
multiply
muscle
museum
mushroom
music
must
mutual
myself
mystery
myth
naive
name
napkin
narrow
nasty
nation
nature
near
neck
need
negative
neglect
neither
nephew
nerve
nest
net
network
neutral
never
news
next
nice
night
noble
noise
nominee
noodle
normal
north
nose
notable
note
nothing
notice
novel
now
nuclear
number
nurse
nut
oak
obey
object
oblige
obscure
observe
obtain
obvious
occur
ocean
october
odor
off
offer
office
often
oil
okay
old
olive
olympic
omit
once
one
onion
online
only
open
opera
opinion
oppose
option
orange
orbit
orchard
order
ordinary
organ
orient
original
orphan
ostrich
other
outdoor
outer
output
outside
oval
oven
over
own
owner
oxygen
oyster
ozone
pact
paddle
page
pair
palace
palm
panda
panel
panic
panther
paper
parade
parent
park
parrot
party
pass
patch
path
patient
patrol
pattern
pause
pave
payment
peace
peanut
pear
peasant
pelican
pen
penalty
pencil
people
pepper
perfect
permit
person
pet
phone
photo
phrase
physical
piano
picnic
picture
piece
pig
pigeon
pill
pilot
pink
pioneer
pipe
pistol
pitch
pizza
place
planet
plastic
plate
play
please
pledge
pluck
plug
plunge
poem
poet
point
polar
pole
police
pond
pony
pool
popular
portion
position
possible
post
potato
pottery
poverty
powder
power
practice
praise
predict
prefer
prepare
present
pretty
prevent
price
pride
primary
print
priority
prison
private
prize
problem
process
produce
profit
program
project
promote
proof
property
prosper
protect
proud
provide
public
pudding
pull
pulp
pulse
pumpkin
punch
pupil
puppy
purchase
purity
purpose
purse
push
put
puzzle
pyramid
quality
quantum
quarter
question
quick
quit
quiz
quote
rabbit
raccoon
race
rack
radar
radio
rail
rain
raise
rally
ramp
ranch
random
range
rapid
rare
rate
rather
raven
raw
razor
ready
real
reason
rebel
rebuild
recall
receive
recipe
record
recycle
reduce
reflect
reform
refuse
region
regret
regular
reject
relax
release
relief
rely
remain
remember
remind
remove
render
renew
rent
reopen
repair
repeat
replace
report
require
rescue
resemble
resist
resource
response
result
retire
retreat
return
reunion
reveal
review
reward
rhythm
rib
ribbon
rice
rich
ride
ridge
rifle
right
rigid
ring
riot
ripple
risk
ritual
rival
river
road
roast
robot
robust
rocket
romance
roof
rookie
room
rose
rotate
rough
round
route
royal
rubber
rude
rug
rule
run
runway
rural
sad
saddle
sadness
safe
sail
salad
salmon
salon
salt
salute
same
sample
sand
satisfy
satoshi
sauce
sausage
save
say
scale
scan
scare
scatter
scene
scheme
school
science
scissors
scorpion
scout
scrap
screen
script
scrub
sea
search
season
seat
second
secret
section
security
seed
seek
segment
select
sell
seminar
senior
sense
sentence
series
service
session
settle
setup
seven
shadow
shaft
shallow
share
shed
shell
sheriff
shield
shift
shine
ship
shiver
shock
shoe
shoot
shop
short
shoulder
shove
shrimp
shrug
shuffle
shy
sibling
sick
side
siege
sight
sign
silent
silk
silly
silver
similar
simple
since
sing
siren
sister
situate
six
size
skate
sketch
ski
skill
skin
skirt
skull
slab
slam
sleep
slender
slice
slide
slight
slim
slogan
slot
slow
slush
small
smart
smile
smoke
smooth
snack
snake
snap
sniff
snow
soap
soccer
social
sock
soda
soft
solar
soldier
solid
solution
solve
someone
song
soon
sorry
sort
soul
sound
soup
source
south
space
spare
spatial
spawn
speak
special
speed
spell
spend
sphere
spice
spider
spike
spin
spirit
split
spoil
sponsor
spoon
sport
spot
spray
spread
spring
spy
square
squeeze
squirrel
stable
stadium
staff
stage
stairs
stamp
stand
start
state
stay
steak
steel
stem
step
stereo
stick
still
sting
stock
stomach
stone
stool
story
stove
strategy
street
strike
strong
struggle
student
stuff
stumble
style
subject
submit
subway
success
such
sudden
suffer
sugar
suggest
suit
summer
sun
sunny
sunset
super
supply
supreme
sure
surface
surge
surprise
surround
survey
suspect
sustain
swallow
swamp
swap
swarm
swear
sweet
swift
swim
swing
switch
sword
symbol
symptom
syrup
system
table
tackle
tag
tail
talent
talk
tank
tape
target
task
taste
tattoo
taxi
teach
team
tell
ten
tenant
tennis
tent
term
test
text
thank
that
theme
then
theory
there
they
thing
this
thought
three
thrive
throw
thumb
thunder
ticket
tide
tiger
tilt
timber
time
tiny
tip
tired
tissue
title
toast
tobacco
today
toddler
toe
together
toilet
token
tomato
tomorrow
tone
tongue
tonight
tool
tooth
top
topic
topple
torch
tornado
tortoise
toss
total
tourist
toward
tower
town
toy
track
trade
traffic
tragic
train
transfer
trap
trash
travel
tray
treat
tree
trend
trial
tribe
trick
trigger
trim
trip
trophy
trouble
truck
true
truly
trumpet
trust
truth
try
tube
tuition
tumble
tuna
tunnel
turkey
turn
turtle
twelve
twenty
twice
twin
twist
two
type
typical
ugly
umbrella
unable
unaware
uncle
uncover
under
undo
unfair
unfold
unhappy
uniform
unique
unit
universe
unknown
unlock
until
unusual
unveil
update
upgrade
uphold
upon
upper
upset
urban
urge
usage
use
used
useful
useless
usual
utility
vacant
vacuum
vague
valid
valley
valve
van
vanish
vapor
various
vast
vault
vehicle
velvet
vendor
venture
venue
verb
verify
version
very
vessel
veteran
viable
vibrant
vicious
victory
video
view
village
vintage
violin
virtual
virus
visa
visit
visual
vital
vivid
vocal
voice
void
volcano
volume
vote
voyage
wage
wagon
wait
walk
wall
walnut
want
warfare
warm
warrior
wash
wasp
waste
water
wave
way
wealth
weapon
wear
weasel
weather
web
wedding
weekend
weird
welcome
west
wet
whale
what
wheat
wheel
when
where
whip
whisper
wide
width
wife
wild
will
win
window
wine
wing
wink
winner
winter
wire
wisdom
wise
wish
witness
wolf
woman
wonder
wood
wool
word
work
world
worry
worth
wrap
wreck
wrestle
wrist
write
wrong
yard
year
yellow
you
young
youth
zebra
zero
zone
zoo`.split("\n");

  // node_modules/@noble/curves/esm/utils.js
  var _0n7 = /* @__PURE__ */ BigInt(0);
  var _1n7 = /* @__PURE__ */ BigInt(1);
  function _abool2(value, title = "") {
    if (typeof value !== "boolean") {
      const prefix = title && `"${title}"`;
      throw new Error(prefix + "expected boolean, got type=" + typeof value);
    }
    return value;
  }
  function _abytes2(value, length, title = "") {
    const bytes2 = isBytes3(value);
    const len = value?.length;
    const needsLen = length !== void 0;
    if (!bytes2 || needsLen && len !== length) {
      const prefix = title && `"${title}" `;
      const ofLen = needsLen ? ` of length ${length}` : "";
      const got = bytes2 ? `length=${len}` : `type=${typeof value}`;
      throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
    }
    return value;
  }
  function numberToHexUnpadded2(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? "0" + hex : hex;
  }
  function hexToNumber2(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    return hex === "" ? _0n7 : BigInt("0x" + hex);
  }
  function bytesToNumberBE2(bytes2) {
    return hexToNumber2(bytesToHex3(bytes2));
  }
  function bytesToNumberLE2(bytes2) {
    abytes2(bytes2);
    return hexToNumber2(bytesToHex3(Uint8Array.from(bytes2).reverse()));
  }
  function numberToBytesBE2(n, len) {
    return hexToBytes4(n.toString(16).padStart(len * 2, "0"));
  }
  function numberToBytesLE2(n, len) {
    return numberToBytesBE2(n, len).reverse();
  }
  function ensureBytes2(title, hex, expectedLength) {
    let res;
    if (typeof hex === "string") {
      try {
        res = hexToBytes4(hex);
      } catch (e) {
        throw new Error(title + " must be hex string or Uint8Array, cause: " + e);
      }
    } else if (isBytes3(hex)) {
      res = Uint8Array.from(hex);
    } else {
      throw new Error(title + " must be hex string or Uint8Array");
    }
    const len = res.length;
    if (typeof expectedLength === "number" && len !== expectedLength)
      throw new Error(title + " of length " + expectedLength + " expected, got " + len);
    return res;
  }
  var isPosBig = (n) => typeof n === "bigint" && _0n7 <= n;
  function inRange(n, min, max) {
    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
  }
  function aInRange(title, n, min, max) {
    if (!inRange(n, min, max))
      throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n);
  }
  function bitLen2(n) {
    let len;
    for (len = 0; n > _0n7; n >>= _1n7, len += 1)
      ;
    return len;
  }
  var bitMask2 = (n) => (_1n7 << BigInt(n)) - _1n7;
  function createHmacDrbg2(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== "number" || hashLen < 2)
      throw new Error("hashLen must be a number");
    if (typeof qByteLen !== "number" || qByteLen < 2)
      throw new Error("qByteLen must be a number");
    if (typeof hmacFn !== "function")
      throw new Error("hmacFn must be a function");
    const u8n2 = (len) => new Uint8Array(len);
    const u8of = (byte) => Uint8Array.of(byte);
    let v = u8n2(hashLen);
    let k = u8n2(hashLen);
    let i = 0;
    const reset = () => {
      v.fill(1);
      k.fill(0);
      i = 0;
    };
    const h = (...b) => hmacFn(k, v, ...b);
    const reseed = (seed = u8n2(0)) => {
      k = h(u8of(0), seed);
      v = h();
      if (seed.length === 0)
        return;
      k = h(u8of(1), seed);
      v = h();
    };
    const gen2 = () => {
      if (i++ >= 1e3)
        throw new Error("drbg: tried 1000 values");
      let len = 0;
      const out = [];
      while (len < qByteLen) {
        v = h();
        const sl = v.slice();
        out.push(sl);
        len += v.length;
      }
      return concatBytes3(...out);
    };
    const genUntil = (seed, pred) => {
      reset();
      reseed(seed);
      let res = void 0;
      while (!(res = pred(gen2())))
        reseed();
      reset();
      return res;
    };
    return genUntil;
  }
  function _validateObject(object, fields, optFields = {}) {
    if (!object || typeof object !== "object")
      throw new Error("expected valid options object");
    function checkField(fieldName, expectedType, isOpt) {
      const val = object[fieldName];
      if (isOpt && val === void 0)
        return;
      const current = typeof val;
      if (current !== expectedType || val === null)
        throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
    }
    Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));
    Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));
  }
  function memoized(fn) {
    const map = /* @__PURE__ */ new WeakMap();
    return (arg, ...args) => {
      const val = map.get(arg);
      if (val !== void 0)
        return val;
      const computed = fn(arg, ...args);
      map.set(arg, computed);
      return computed;
    };
  }

  // node_modules/@noble/curves/esm/abstract/modular.js
  var _0n8 = BigInt(0);
  var _1n8 = BigInt(1);
  var _2n6 = /* @__PURE__ */ BigInt(2);
  var _3n3 = /* @__PURE__ */ BigInt(3);
  var _4n3 = /* @__PURE__ */ BigInt(4);
  var _5n2 = /* @__PURE__ */ BigInt(5);
  var _7n2 = /* @__PURE__ */ BigInt(7);
  var _8n2 = /* @__PURE__ */ BigInt(8);
  var _9n2 = /* @__PURE__ */ BigInt(9);
  var _16n2 = /* @__PURE__ */ BigInt(16);
  function mod2(a, b) {
    const result = a % b;
    return result >= _0n8 ? result : b + result;
  }
  function pow22(x, power, modulo) {
    let res = x;
    while (power-- > _0n8) {
      res *= res;
      res %= modulo;
    }
    return res;
  }
  function invert2(number2, modulo) {
    if (number2 === _0n8)
      throw new Error("invert: expected non-zero number");
    if (modulo <= _0n8)
      throw new Error("invert: expected positive modulus, got " + modulo);
    let a = mod2(number2, modulo);
    let b = modulo;
    let x = _0n8, y = _1n8, u = _1n8, v = _0n8;
    while (a !== _0n8) {
      const q = b / a;
      const r = b % a;
      const m = x - u * q;
      const n = y - v * q;
      b = a, a = r, x = u, y = v, u = m, v = n;
    }
    const gcd2 = b;
    if (gcd2 !== _1n8)
      throw new Error("invert: does not exist");
    return mod2(x, modulo);
  }
  function assertIsSquare(Fp2, root, n) {
    if (!Fp2.eql(Fp2.sqr(root), n))
      throw new Error("Cannot find square root");
  }
  function sqrt3mod4(Fp2, n) {
    const p1div4 = (Fp2.ORDER + _1n8) / _4n3;
    const root = Fp2.pow(n, p1div4);
    assertIsSquare(Fp2, root, n);
    return root;
  }
  function sqrt5mod8(Fp2, n) {
    const p5div8 = (Fp2.ORDER - _5n2) / _8n2;
    const n2 = Fp2.mul(n, _2n6);
    const v = Fp2.pow(n2, p5div8);
    const nv = Fp2.mul(n, v);
    const i = Fp2.mul(Fp2.mul(nv, _2n6), v);
    const root = Fp2.mul(nv, Fp2.sub(i, Fp2.ONE));
    assertIsSquare(Fp2, root, n);
    return root;
  }
  function sqrt9mod16(P) {
    const Fp_ = Field2(P);
    const tn = tonelliShanks2(P);
    const c1 = tn(Fp_, Fp_.neg(Fp_.ONE));
    const c2 = tn(Fp_, c1);
    const c3 = tn(Fp_, Fp_.neg(c1));
    const c4 = (P + _7n2) / _16n2;
    return (Fp2, n) => {
      let tv1 = Fp2.pow(n, c4);
      let tv2 = Fp2.mul(tv1, c1);
      const tv3 = Fp2.mul(tv1, c2);
      const tv4 = Fp2.mul(tv1, c3);
      const e1 = Fp2.eql(Fp2.sqr(tv2), n);
      const e2 = Fp2.eql(Fp2.sqr(tv3), n);
      tv1 = Fp2.cmov(tv1, tv2, e1);
      tv2 = Fp2.cmov(tv4, tv3, e2);
      const e3 = Fp2.eql(Fp2.sqr(tv2), n);
      const root = Fp2.cmov(tv1, tv2, e3);
      assertIsSquare(Fp2, root, n);
      return root;
    };
  }
  function tonelliShanks2(P) {
    if (P < _3n3)
      throw new Error("sqrt is not defined for small field");
    let Q = P - _1n8;
    let S = 0;
    while (Q % _2n6 === _0n8) {
      Q /= _2n6;
      S++;
    }
    let Z = _2n6;
    const _Fp = Field2(P);
    while (FpLegendre(_Fp, Z) === 1) {
      if (Z++ > 1e3)
        throw new Error("Cannot find square root: probably non-prime P");
    }
    if (S === 1)
      return sqrt3mod4;
    let cc = _Fp.pow(Z, Q);
    const Q1div2 = (Q + _1n8) / _2n6;
    return function tonelliSlow(Fp2, n) {
      if (Fp2.is0(n))
        return n;
      if (FpLegendre(Fp2, n) !== 1)
        throw new Error("Cannot find square root");
      let M = S;
      let c = Fp2.mul(Fp2.ONE, cc);
      let t = Fp2.pow(n, Q);
      let R = Fp2.pow(n, Q1div2);
      while (!Fp2.eql(t, Fp2.ONE)) {
        if (Fp2.is0(t))
          return Fp2.ZERO;
        let i = 1;
        let t_tmp = Fp2.sqr(t);
        while (!Fp2.eql(t_tmp, Fp2.ONE)) {
          i++;
          t_tmp = Fp2.sqr(t_tmp);
          if (i === M)
            throw new Error("Cannot find square root");
        }
        const exponent = _1n8 << BigInt(M - i - 1);
        const b = Fp2.pow(c, exponent);
        M = i;
        c = Fp2.sqr(b);
        t = Fp2.mul(t, c);
        R = Fp2.mul(R, b);
      }
      return R;
    };
  }
  function FpSqrt2(P) {
    if (P % _4n3 === _3n3)
      return sqrt3mod4;
    if (P % _8n2 === _5n2)
      return sqrt5mod8;
    if (P % _16n2 === _9n2)
      return sqrt9mod16(P);
    return tonelliShanks2(P);
  }
  var FIELD_FIELDS2 = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
  ];
  function validateField2(field) {
    const initial = {
      ORDER: "bigint",
      MASK: "bigint",
      BYTES: "number",
      BITS: "number"
    };
    const opts = FIELD_FIELDS2.reduce((map, val) => {
      map[val] = "function";
      return map;
    }, initial);
    _validateObject(field, opts);
    return field;
  }
  function FpPow2(Fp2, num, power) {
    if (power < _0n8)
      throw new Error("invalid exponent, negatives unsupported");
    if (power === _0n8)
      return Fp2.ONE;
    if (power === _1n8)
      return num;
    let p = Fp2.ONE;
    let d = num;
    while (power > _0n8) {
      if (power & _1n8)
        p = Fp2.mul(p, d);
      d = Fp2.sqr(d);
      power >>= _1n8;
    }
    return p;
  }
  function FpInvertBatch2(Fp2, nums, passZero = false) {
    const inverted = new Array(nums.length).fill(passZero ? Fp2.ZERO : void 0);
    const multipliedAcc = nums.reduce((acc, num, i) => {
      if (Fp2.is0(num))
        return acc;
      inverted[i] = acc;
      return Fp2.mul(acc, num);
    }, Fp2.ONE);
    const invertedAcc = Fp2.inv(multipliedAcc);
    nums.reduceRight((acc, num, i) => {
      if (Fp2.is0(num))
        return acc;
      inverted[i] = Fp2.mul(acc, inverted[i]);
      return Fp2.mul(acc, num);
    }, invertedAcc);
    return inverted;
  }
  function FpLegendre(Fp2, n) {
    const p1mod2 = (Fp2.ORDER - _1n8) / _2n6;
    const powered = Fp2.pow(n, p1mod2);
    const yes = Fp2.eql(powered, Fp2.ONE);
    const zero = Fp2.eql(powered, Fp2.ZERO);
    const no = Fp2.eql(powered, Fp2.neg(Fp2.ONE));
    if (!yes && !zero && !no)
      throw new Error("invalid Legendre symbol result");
    return yes ? 1 : zero ? 0 : -1;
  }
  function nLength2(n, nBitLength) {
    if (nBitLength !== void 0)
      anumber(nBitLength);
    const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return { nBitLength: _nBitLength, nByteLength };
  }
  function Field2(ORDER, bitLenOrOpts, isLE2 = false, opts = {}) {
    if (ORDER <= _0n8)
      throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
    let _nbitLength = void 0;
    let _sqrt = void 0;
    let modFromBytes = false;
    let allowedLengths = void 0;
    if (typeof bitLenOrOpts === "object" && bitLenOrOpts != null) {
      if (opts.sqrt || isLE2)
        throw new Error("cannot specify opts in two arguments");
      const _opts = bitLenOrOpts;
      if (_opts.BITS)
        _nbitLength = _opts.BITS;
      if (_opts.sqrt)
        _sqrt = _opts.sqrt;
      if (typeof _opts.isLE === "boolean")
        isLE2 = _opts.isLE;
      if (typeof _opts.modFromBytes === "boolean")
        modFromBytes = _opts.modFromBytes;
      allowedLengths = _opts.allowedLengths;
    } else {
      if (typeof bitLenOrOpts === "number")
        _nbitLength = bitLenOrOpts;
      if (opts.sqrt)
        _sqrt = opts.sqrt;
    }
    const { nBitLength: BITS, nByteLength: BYTES } = nLength2(ORDER, _nbitLength);
    if (BYTES > 2048)
      throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    let sqrtP;
    const f = Object.freeze({
      ORDER,
      isLE: isLE2,
      BITS,
      BYTES,
      MASK: bitMask2(BITS),
      ZERO: _0n8,
      ONE: _1n8,
      allowedLengths,
      create: (num) => mod2(num, ORDER),
      isValid: (num) => {
        if (typeof num !== "bigint")
          throw new Error("invalid field element: expected bigint, got " + typeof num);
        return _0n8 <= num && num < ORDER;
      },
      is0: (num) => num === _0n8,
      // is valid and invertible
      isValidNot0: (num) => !f.is0(num) && f.isValid(num),
      isOdd: (num) => (num & _1n8) === _1n8,
      neg: (num) => mod2(-num, ORDER),
      eql: (lhs, rhs) => lhs === rhs,
      sqr: (num) => mod2(num * num, ORDER),
      add: (lhs, rhs) => mod2(lhs + rhs, ORDER),
      sub: (lhs, rhs) => mod2(lhs - rhs, ORDER),
      mul: (lhs, rhs) => mod2(lhs * rhs, ORDER),
      pow: (num, power) => FpPow2(f, num, power),
      div: (lhs, rhs) => mod2(lhs * invert2(rhs, ORDER), ORDER),
      // Same as above, but doesn't normalize
      sqrN: (num) => num * num,
      addN: (lhs, rhs) => lhs + rhs,
      subN: (lhs, rhs) => lhs - rhs,
      mulN: (lhs, rhs) => lhs * rhs,
      inv: (num) => invert2(num, ORDER),
      sqrt: _sqrt || ((n) => {
        if (!sqrtP)
          sqrtP = FpSqrt2(ORDER);
        return sqrtP(f, n);
      }),
      toBytes: (num) => isLE2 ? numberToBytesLE2(num, BYTES) : numberToBytesBE2(num, BYTES),
      fromBytes: (bytes2, skipValidation = true) => {
        if (allowedLengths) {
          if (!allowedLengths.includes(bytes2.length) || bytes2.length > BYTES) {
            throw new Error("Field.fromBytes: expected " + allowedLengths + " bytes, got " + bytes2.length);
          }
          const padded = new Uint8Array(BYTES);
          padded.set(bytes2, isLE2 ? 0 : padded.length - bytes2.length);
          bytes2 = padded;
        }
        if (bytes2.length !== BYTES)
          throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes2.length);
        let scalar = isLE2 ? bytesToNumberLE2(bytes2) : bytesToNumberBE2(bytes2);
        if (modFromBytes)
          scalar = mod2(scalar, ORDER);
        if (!skipValidation) {
          if (!f.isValid(scalar))
            throw new Error("invalid field element: outside of range 0..ORDER");
        }
        return scalar;
      },
      // TODO: we don't need it here, move out to separate fn
      invertBatch: (lst) => FpInvertBatch2(f, lst),
      // We can't move this out because Fp6, Fp12 implement it
      // and it's unclear what to return in there.
      cmov: (a, b, c) => c ? b : a
    });
    return Object.freeze(f);
  }
  function getFieldBytesLength2(fieldOrder) {
    if (typeof fieldOrder !== "bigint")
      throw new Error("field order must be bigint");
    const bitLength = fieldOrder.toString(2).length;
    return Math.ceil(bitLength / 8);
  }
  function getMinHashLength2(fieldOrder) {
    const length = getFieldBytesLength2(fieldOrder);
    return length + Math.ceil(length / 2);
  }
  function mapHashToField2(key, fieldOrder, isLE2 = false) {
    const len = key.length;
    const fieldLen = getFieldBytesLength2(fieldOrder);
    const minLen = getMinHashLength2(fieldOrder);
    if (len < 16 || len < minLen || len > 1024)
      throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
    const num = isLE2 ? bytesToNumberLE2(key) : bytesToNumberBE2(key);
    const reduced = mod2(num, fieldOrder - _1n8) + _1n8;
    return isLE2 ? numberToBytesLE2(reduced, fieldLen) : numberToBytesBE2(reduced, fieldLen);
  }

  // node_modules/@noble/curves/esm/abstract/curve.js
  var _0n9 = BigInt(0);
  var _1n9 = BigInt(1);
  function negateCt(condition, item) {
    const neg = item.negate();
    return condition ? neg : item;
  }
  function normalizeZ(c, points) {
    const invertedZs = FpInvertBatch2(c.Fp, points.map((p) => p.Z));
    return points.map((p, i) => c.fromAffine(p.toAffine(invertedZs[i])));
  }
  function validateW(W, bits) {
    if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
      throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
  }
  function calcWOpts(W, scalarBits) {
    validateW(W, scalarBits);
    const windows = Math.ceil(scalarBits / W) + 1;
    const windowSize = 2 ** (W - 1);
    const maxNumber = 2 ** W;
    const mask = bitMask2(W);
    const shiftBy = BigInt(W);
    return { windows, windowSize, mask, maxNumber, shiftBy };
  }
  function calcOffsets(n, window, wOpts) {
    const { windowSize, mask, maxNumber, shiftBy } = wOpts;
    let wbits = Number(n & mask);
    let nextN = n >> shiftBy;
    if (wbits > windowSize) {
      wbits -= maxNumber;
      nextN += _1n9;
    }
    const offsetStart = window * windowSize;
    const offset = offsetStart + Math.abs(wbits) - 1;
    const isZero = wbits === 0;
    const isNeg = wbits < 0;
    const isNegF = window % 2 !== 0;
    const offsetF = offsetStart;
    return { nextN, offset, isZero, isNeg, isNegF, offsetF };
  }
  function validateMSMPoints(points, c) {
    if (!Array.isArray(points))
      throw new Error("array expected");
    points.forEach((p, i) => {
      if (!(p instanceof c))
        throw new Error("invalid point at index " + i);
    });
  }
  function validateMSMScalars(scalars, field) {
    if (!Array.isArray(scalars))
      throw new Error("array of scalars expected");
    scalars.forEach((s, i) => {
      if (!field.isValid(s))
        throw new Error("invalid scalar at index " + i);
    });
  }
  var pointPrecomputes = /* @__PURE__ */ new WeakMap();
  var pointWindowSizes = /* @__PURE__ */ new WeakMap();
  function getW(P) {
    return pointWindowSizes.get(P) || 1;
  }
  function assert0(n) {
    if (n !== _0n9)
      throw new Error("invalid wNAF");
  }
  var wNAF2 = class {
    // Parametrized with a given Point class (not individual point)
    constructor(Point3, bits) {
      this.BASE = Point3.BASE;
      this.ZERO = Point3.ZERO;
      this.Fn = Point3.Fn;
      this.bits = bits;
    }
    // non-const time multiplication ladder
    _unsafeLadder(elm, n, p = this.ZERO) {
      let d = elm;
      while (n > _0n9) {
        if (n & _1n9)
          p = p.add(d);
        d = d.double();
        n >>= _1n9;
      }
      return p;
    }
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @param point Point instance
     * @param W window size
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(point, W) {
      const { windows, windowSize } = calcWOpts(W, this.bits);
      const points = [];
      let p = point;
      let base = p;
      for (let window = 0; window < windows; window++) {
        base = p;
        points.push(base);
        for (let i = 1; i < windowSize; i++) {
          base = base.add(p);
          points.push(base);
        }
        p = base.double();
      }
      return points;
    }
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * More compact implementation:
     * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
     * @returns real and fake (for const-time) points
     */
    wNAF(W, precomputes, n) {
      if (!this.Fn.isValid(n))
        throw new Error("invalid scalar");
      let p = this.ZERO;
      let f = this.BASE;
      const wo = calcWOpts(W, this.bits);
      for (let window = 0; window < wo.windows; window++) {
        const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);
        n = nextN;
        if (isZero) {
          f = f.add(negateCt(isNegF, precomputes[offsetF]));
        } else {
          p = p.add(negateCt(isNeg, precomputes[offset]));
        }
      }
      assert0(n);
      return { p, f };
    }
    /**
     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
     * @param acc accumulator point to add result of multiplication
     * @returns point
     */
    wNAFUnsafe(W, precomputes, n, acc = this.ZERO) {
      const wo = calcWOpts(W, this.bits);
      for (let window = 0; window < wo.windows; window++) {
        if (n === _0n9)
          break;
        const { nextN, offset, isZero, isNeg } = calcOffsets(n, window, wo);
        n = nextN;
        if (isZero) {
          continue;
        } else {
          const item = precomputes[offset];
          acc = acc.add(isNeg ? item.negate() : item);
        }
      }
      assert0(n);
      return acc;
    }
    getPrecomputes(W, point, transform) {
      let comp = pointPrecomputes.get(point);
      if (!comp) {
        comp = this.precomputeWindow(point, W);
        if (W !== 1) {
          if (typeof transform === "function")
            comp = transform(comp);
          pointPrecomputes.set(point, comp);
        }
      }
      return comp;
    }
    cached(point, scalar, transform) {
      const W = getW(point);
      return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);
    }
    unsafe(point, scalar, transform, prev) {
      const W = getW(point);
      if (W === 1)
        return this._unsafeLadder(point, scalar, prev);
      return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);
    }
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    createCache(P, W) {
      validateW(W, this.bits);
      pointWindowSizes.set(P, W);
      pointPrecomputes.delete(P);
    }
    hasCache(elm) {
      return getW(elm) !== 1;
    }
  };
  function mulEndoUnsafe(Point3, point, k1, k2) {
    let acc = point;
    let p1 = Point3.ZERO;
    let p2 = Point3.ZERO;
    while (k1 > _0n9 || k2 > _0n9) {
      if (k1 & _1n9)
        p1 = p1.add(acc);
      if (k2 & _1n9)
        p2 = p2.add(acc);
      acc = acc.double();
      k1 >>= _1n9;
      k2 >>= _1n9;
    }
    return { p1, p2 };
  }
  function pippenger(c, fieldN, points, scalars) {
    validateMSMPoints(points, c);
    validateMSMScalars(scalars, fieldN);
    const plength = points.length;
    const slength = scalars.length;
    if (plength !== slength)
      throw new Error("arrays of points and scalars must have equal length");
    const zero = c.ZERO;
    const wbits = bitLen2(BigInt(plength));
    let windowSize = 1;
    if (wbits > 12)
      windowSize = wbits - 3;
    else if (wbits > 4)
      windowSize = wbits - 2;
    else if (wbits > 0)
      windowSize = 2;
    const MASK = bitMask2(windowSize);
    const buckets = new Array(Number(MASK) + 1).fill(zero);
    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
    let sum = zero;
    for (let i = lastBits; i >= 0; i -= windowSize) {
      buckets.fill(zero);
      for (let j = 0; j < slength; j++) {
        const scalar = scalars[j];
        const wbits2 = Number(scalar >> BigInt(i) & MASK);
        buckets[wbits2] = buckets[wbits2].add(points[j]);
      }
      let resI = zero;
      for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {
        sumI = sumI.add(buckets[j]);
        resI = resI.add(sumI);
      }
      sum = sum.add(resI);
      if (i !== 0)
        for (let j = 0; j < windowSize; j++)
          sum = sum.double();
    }
    return sum;
  }
  function createField(order, field, isLE2) {
    if (field) {
      if (field.ORDER !== order)
        throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
      validateField2(field);
      return field;
    } else {
      return Field2(order, { isLE: isLE2 });
    }
  }
  function _createCurveFields(type, CURVE, curveOpts = {}, FpFnLE) {
    if (FpFnLE === void 0)
      FpFnLE = type === "edwards";
    if (!CURVE || typeof CURVE !== "object")
      throw new Error(`expected valid ${type} CURVE object`);
    for (const p of ["p", "n", "h"]) {
      const val = CURVE[p];
      if (!(typeof val === "bigint" && val > _0n9))
        throw new Error(`CURVE.${p} must be positive bigint`);
    }
    const Fp2 = createField(CURVE.p, curveOpts.Fp, FpFnLE);
    const Fn = createField(CURVE.n, curveOpts.Fn, FpFnLE);
    const _b = type === "weierstrass" ? "b" : "d";
    const params = ["Gx", "Gy", "a", _b];
    for (const p of params) {
      if (!Fp2.isValid(CURVE[p]))
        throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);
    }
    CURVE = Object.freeze(Object.assign({}, CURVE));
    return { CURVE, Fp: Fp2, Fn };
  }

  // node_modules/@noble/curves/esm/abstract/weierstrass.js
  var divNearest2 = (num, den) => (num + (num >= 0 ? den : -den) / _2n7) / den;
  function _splitEndoScalar(k, basis, n) {
    const [[a1, b1], [a2, b2]] = basis;
    const c1 = divNearest2(b2 * k, n);
    const c2 = divNearest2(-b1 * k, n);
    let k1 = k - c1 * a1 - c2 * a2;
    let k2 = -c1 * b1 - c2 * b2;
    const k1neg = k1 < _0n10;
    const k2neg = k2 < _0n10;
    if (k1neg)
      k1 = -k1;
    if (k2neg)
      k2 = -k2;
    const MAX_NUM = bitMask2(Math.ceil(bitLen2(n) / 2)) + _1n10;
    if (k1 < _0n10 || k1 >= MAX_NUM || k2 < _0n10 || k2 >= MAX_NUM) {
      throw new Error("splitScalar (endomorphism): failed, k=" + k);
    }
    return { k1neg, k1, k2neg, k2 };
  }
  function validateSigFormat(format) {
    if (!["compact", "recovered", "der"].includes(format))
      throw new Error('Signature format must be "compact", "recovered", or "der"');
    return format;
  }
  function validateSigOpts(opts, def) {
    const optsn = {};
    for (let optName of Object.keys(def)) {
      optsn[optName] = opts[optName] === void 0 ? def[optName] : opts[optName];
    }
    _abool2(optsn.lowS, "lowS");
    _abool2(optsn.prehash, "prehash");
    if (optsn.format !== void 0)
      validateSigFormat(optsn.format);
    return optsn;
  }
  var DERErr2 = class extends Error {
    constructor(m = "") {
      super(m);
    }
  };
  var DER2 = {
    // asn.1 DER encoding utils
    Err: DERErr2,
    // Basic building block is TLV (Tag-Length-Value)
    _tlv: {
      encode: (tag, data) => {
        const { Err: E } = DER2;
        if (tag < 0 || tag > 256)
          throw new E("tlv.encode: wrong tag");
        if (data.length & 1)
          throw new E("tlv.encode: unpadded data");
        const dataLen = data.length / 2;
        const len = numberToHexUnpadded2(dataLen);
        if (len.length / 2 & 128)
          throw new E("tlv.encode: long form length too big");
        const lenLen = dataLen > 127 ? numberToHexUnpadded2(len.length / 2 | 128) : "";
        const t = numberToHexUnpadded2(tag);
        return t + lenLen + len + data;
      },
      // v - value, l - left bytes (unparsed)
      decode(tag, data) {
        const { Err: E } = DER2;
        let pos = 0;
        if (tag < 0 || tag > 256)
          throw new E("tlv.encode: wrong tag");
        if (data.length < 2 || data[pos++] !== tag)
          throw new E("tlv.decode: wrong tlv");
        const first = data[pos++];
        const isLong = !!(first & 128);
        let length = 0;
        if (!isLong)
          length = first;
        else {
          const lenLen = first & 127;
          if (!lenLen)
            throw new E("tlv.decode(long): indefinite length not supported");
          if (lenLen > 4)
            throw new E("tlv.decode(long): byte length is too big");
          const lengthBytes = data.subarray(pos, pos + lenLen);
          if (lengthBytes.length !== lenLen)
            throw new E("tlv.decode: length bytes not complete");
          if (lengthBytes[0] === 0)
            throw new E("tlv.decode(long): zero leftmost byte");
          for (const b of lengthBytes)
            length = length << 8 | b;
          pos += lenLen;
          if (length < 128)
            throw new E("tlv.decode(long): not minimal encoding");
        }
        const v = data.subarray(pos, pos + length);
        if (v.length !== length)
          throw new E("tlv.decode: wrong value length");
        return { v, l: data.subarray(pos + length) };
      }
    },
    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
    // since we always use positive integers here. It must always be empty:
    // - add zero byte if exists
    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
    _int: {
      encode(num) {
        const { Err: E } = DER2;
        if (num < _0n10)
          throw new E("integer: negative integers are not allowed");
        let hex = numberToHexUnpadded2(num);
        if (Number.parseInt(hex[0], 16) & 8)
          hex = "00" + hex;
        if (hex.length & 1)
          throw new E("unexpected DER parsing assertion: unpadded hex");
        return hex;
      },
      decode(data) {
        const { Err: E } = DER2;
        if (data[0] & 128)
          throw new E("invalid signature integer: negative");
        if (data[0] === 0 && !(data[1] & 128))
          throw new E("invalid signature integer: unnecessary leading zero");
        return bytesToNumberBE2(data);
      }
    },
    toSig(hex) {
      const { Err: E, _int: int, _tlv: tlv } = DER2;
      const data = ensureBytes2("signature", hex);
      const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
      if (seqLeftBytes.length)
        throw new E("invalid signature: left bytes after parsing");
      const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
      const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
      if (sLeftBytes.length)
        throw new E("invalid signature: left bytes after parsing");
      return { r: int.decode(rBytes), s: int.decode(sBytes) };
    },
    hexFromSig(sig) {
      const { _tlv: tlv, _int: int } = DER2;
      const rs = tlv.encode(2, int.encode(sig.r));
      const ss = tlv.encode(2, int.encode(sig.s));
      const seq = rs + ss;
      return tlv.encode(48, seq);
    }
  };
  var _0n10 = BigInt(0);
  var _1n10 = BigInt(1);
  var _2n7 = BigInt(2);
  var _3n4 = BigInt(3);
  var _4n4 = BigInt(4);
  function _normFnElement(Fn, key) {
    const { BYTES: expected } = Fn;
    let num;
    if (typeof key === "bigint") {
      num = key;
    } else {
      let bytes2 = ensureBytes2("private key", key);
      try {
        num = Fn.fromBytes(bytes2);
      } catch (error) {
        throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);
      }
    }
    if (!Fn.isValidNot0(num))
      throw new Error("invalid private key: out of range [1..N-1]");
    return num;
  }
  function weierstrassN(params, extraOpts = {}) {
    const validated = _createCurveFields("weierstrass", params, extraOpts);
    const { Fp: Fp2, Fn } = validated;
    let CURVE = validated.CURVE;
    const { h: cofactor, n: CURVE_ORDER } = CURVE;
    _validateObject(extraOpts, {}, {
      allowInfinityPoint: "boolean",
      clearCofactor: "function",
      isTorsionFree: "function",
      fromBytes: "function",
      toBytes: "function",
      endo: "object",
      wrapPrivateKey: "boolean"
    });
    const { endo } = extraOpts;
    if (endo) {
      if (!Fp2.is0(CURVE.a) || typeof endo.beta !== "bigint" || !Array.isArray(endo.basises)) {
        throw new Error('invalid endo: expected "beta": bigint and "basises": array');
      }
    }
    const lengths = getWLengths(Fp2, Fn);
    function assertCompressionIsSupported() {
      if (!Fp2.isOdd)
        throw new Error("compression is not supported: Field does not have .isOdd()");
    }
    function pointToBytes(_c, point, isCompressed) {
      const { x, y } = point.toAffine();
      const bx = Fp2.toBytes(x);
      _abool2(isCompressed, "isCompressed");
      if (isCompressed) {
        assertCompressionIsSupported();
        const hasEvenY = !Fp2.isOdd(y);
        return concatBytes3(pprefix(hasEvenY), bx);
      } else {
        return concatBytes3(Uint8Array.of(4), bx, Fp2.toBytes(y));
      }
    }
    function pointFromBytes(bytes2) {
      _abytes2(bytes2, void 0, "Point");
      const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths;
      const length = bytes2.length;
      const head = bytes2[0];
      const tail = bytes2.subarray(1);
      if (length === comp && (head === 2 || head === 3)) {
        const x = Fp2.fromBytes(tail);
        if (!Fp2.isValid(x))
          throw new Error("bad point: is not on curve, wrong x");
        const y2 = weierstrassEquation(x);
        let y;
        try {
          y = Fp2.sqrt(y2);
        } catch (sqrtError) {
          const err = sqrtError instanceof Error ? ": " + sqrtError.message : "";
          throw new Error("bad point: is not on curve, sqrt error" + err);
        }
        assertCompressionIsSupported();
        const isYOdd = Fp2.isOdd(y);
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y = Fp2.neg(y);
        return { x, y };
      } else if (length === uncomp && head === 4) {
        const L = Fp2.BYTES;
        const x = Fp2.fromBytes(tail.subarray(0, L));
        const y = Fp2.fromBytes(tail.subarray(L, L * 2));
        if (!isValidXY(x, y))
          throw new Error("bad point: is not on curve");
        return { x, y };
      } else {
        throw new Error(`bad point: got length ${length}, expected compressed=${comp} or uncompressed=${uncomp}`);
      }
    }
    const encodePoint = extraOpts.toBytes || pointToBytes;
    const decodePoint = extraOpts.fromBytes || pointFromBytes;
    function weierstrassEquation(x) {
      const x2 = Fp2.sqr(x);
      const x3 = Fp2.mul(x2, x);
      return Fp2.add(Fp2.add(x3, Fp2.mul(x, CURVE.a)), CURVE.b);
    }
    function isValidXY(x, y) {
      const left = Fp2.sqr(y);
      const right = weierstrassEquation(x);
      return Fp2.eql(left, right);
    }
    if (!isValidXY(CURVE.Gx, CURVE.Gy))
      throw new Error("bad curve params: generator point");
    const _4a3 = Fp2.mul(Fp2.pow(CURVE.a, _3n4), _4n4);
    const _27b2 = Fp2.mul(Fp2.sqr(CURVE.b), BigInt(27));
    if (Fp2.is0(Fp2.add(_4a3, _27b2)))
      throw new Error("bad curve params: a or b");
    function acoord(title, n, banZero = false) {
      if (!Fp2.isValid(n) || banZero && Fp2.is0(n))
        throw new Error(`bad point coordinate ${title}`);
      return n;
    }
    function aprjpoint(other) {
      if (!(other instanceof Point3))
        throw new Error("ProjectivePoint expected");
    }
    function splitEndoScalarN(k) {
      if (!endo || !endo.basises)
        throw new Error("no endo");
      return _splitEndoScalar(k, endo.basises, Fn.ORDER);
    }
    const toAffineMemo = memoized((p, iz) => {
      const { X, Y, Z } = p;
      if (Fp2.eql(Z, Fp2.ONE))
        return { x: X, y: Y };
      const is0 = p.is0();
      if (iz == null)
        iz = is0 ? Fp2.ONE : Fp2.inv(Z);
      const x = Fp2.mul(X, iz);
      const y = Fp2.mul(Y, iz);
      const zz = Fp2.mul(Z, iz);
      if (is0)
        return { x: Fp2.ZERO, y: Fp2.ZERO };
      if (!Fp2.eql(zz, Fp2.ONE))
        throw new Error("invZ was invalid");
      return { x, y };
    });
    const assertValidMemo = memoized((p) => {
      if (p.is0()) {
        if (extraOpts.allowInfinityPoint && !Fp2.is0(p.Y))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x, y } = p.toAffine();
      if (!Fp2.isValid(x) || !Fp2.isValid(y))
        throw new Error("bad point: x or y not field elements");
      if (!isValidXY(x, y))
        throw new Error("bad point: equation left != right");
      if (!p.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
      return true;
    });
    function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
      k2p = new Point3(Fp2.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);
      k1p = negateCt(k1neg, k1p);
      k2p = negateCt(k2neg, k2p);
      return k1p.add(k2p);
    }
    class Point3 {
      /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
      constructor(X, Y, Z) {
        this.X = acoord("x", X);
        this.Y = acoord("y", Y, true);
        this.Z = acoord("z", Z);
        Object.freeze(this);
      }
      static CURVE() {
        return CURVE;
      }
      /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
      static fromAffine(p) {
        const { x, y } = p || {};
        if (!p || !Fp2.isValid(x) || !Fp2.isValid(y))
          throw new Error("invalid affine point");
        if (p instanceof Point3)
          throw new Error("projective point not allowed");
        if (Fp2.is0(x) && Fp2.is0(y))
          return Point3.ZERO;
        return new Point3(x, y, Fp2.ONE);
      }
      static fromBytes(bytes2) {
        const P = Point3.fromAffine(decodePoint(_abytes2(bytes2, void 0, "point")));
        P.assertValidity();
        return P;
      }
      static fromHex(hex) {
        return Point3.fromBytes(ensureBytes2("pointHex", hex));
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      /**
       *
       * @param windowSize
       * @param isLazy true will defer table computation until the first multiplication
       * @returns
       */
      precompute(windowSize = 8, isLazy = true) {
        wnaf.createCache(this, windowSize);
        if (!isLazy)
          this.multiply(_3n4);
        return this;
      }
      // TODO: return `this`
      /** A point on curve is valid if it conforms to equation. */
      assertValidity() {
        assertValidMemo(this);
      }
      hasEvenY() {
        const { y } = this.toAffine();
        if (!Fp2.isOdd)
          throw new Error("Field doesn't support isOdd");
        return !Fp2.isOdd(y);
      }
      /** Compare one point to another. */
      equals(other) {
        aprjpoint(other);
        const { X: X1, Y: Y1, Z: Z1 } = this;
        const { X: X2, Y: Y2, Z: Z2 } = other;
        const U1 = Fp2.eql(Fp2.mul(X1, Z2), Fp2.mul(X2, Z1));
        const U2 = Fp2.eql(Fp2.mul(Y1, Z2), Fp2.mul(Y2, Z1));
        return U1 && U2;
      }
      /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
      negate() {
        return new Point3(this.X, Fp2.neg(this.Y), this.Z);
      }
      // Renes-Costello-Batina exception-free doubling formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 3
      // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
      double() {
        const { a, b } = CURVE;
        const b3 = Fp2.mul(b, _3n4);
        const { X: X1, Y: Y1, Z: Z1 } = this;
        let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
        let t0 = Fp2.mul(X1, X1);
        let t1 = Fp2.mul(Y1, Y1);
        let t2 = Fp2.mul(Z1, Z1);
        let t3 = Fp2.mul(X1, Y1);
        t3 = Fp2.add(t3, t3);
        Z3 = Fp2.mul(X1, Z1);
        Z3 = Fp2.add(Z3, Z3);
        X3 = Fp2.mul(a, Z3);
        Y3 = Fp2.mul(b3, t2);
        Y3 = Fp2.add(X3, Y3);
        X3 = Fp2.sub(t1, Y3);
        Y3 = Fp2.add(t1, Y3);
        Y3 = Fp2.mul(X3, Y3);
        X3 = Fp2.mul(t3, X3);
        Z3 = Fp2.mul(b3, Z3);
        t2 = Fp2.mul(a, t2);
        t3 = Fp2.sub(t0, t2);
        t3 = Fp2.mul(a, t3);
        t3 = Fp2.add(t3, Z3);
        Z3 = Fp2.add(t0, t0);
        t0 = Fp2.add(Z3, t0);
        t0 = Fp2.add(t0, t2);
        t0 = Fp2.mul(t0, t3);
        Y3 = Fp2.add(Y3, t0);
        t2 = Fp2.mul(Y1, Z1);
        t2 = Fp2.add(t2, t2);
        t0 = Fp2.mul(t2, t3);
        X3 = Fp2.sub(X3, t0);
        Z3 = Fp2.mul(t2, t1);
        Z3 = Fp2.add(Z3, Z3);
        Z3 = Fp2.add(Z3, Z3);
        return new Point3(X3, Y3, Z3);
      }
      // Renes-Costello-Batina exception-free addition formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 1
      // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
      add(other) {
        aprjpoint(other);
        const { X: X1, Y: Y1, Z: Z1 } = this;
        const { X: X2, Y: Y2, Z: Z2 } = other;
        let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
        const a = CURVE.a;
        const b3 = Fp2.mul(CURVE.b, _3n4);
        let t0 = Fp2.mul(X1, X2);
        let t1 = Fp2.mul(Y1, Y2);
        let t2 = Fp2.mul(Z1, Z2);
        let t3 = Fp2.add(X1, Y1);
        let t4 = Fp2.add(X2, Y2);
        t3 = Fp2.mul(t3, t4);
        t4 = Fp2.add(t0, t1);
        t3 = Fp2.sub(t3, t4);
        t4 = Fp2.add(X1, Z1);
        let t5 = Fp2.add(X2, Z2);
        t4 = Fp2.mul(t4, t5);
        t5 = Fp2.add(t0, t2);
        t4 = Fp2.sub(t4, t5);
        t5 = Fp2.add(Y1, Z1);
        X3 = Fp2.add(Y2, Z2);
        t5 = Fp2.mul(t5, X3);
        X3 = Fp2.add(t1, t2);
        t5 = Fp2.sub(t5, X3);
        Z3 = Fp2.mul(a, t4);
        X3 = Fp2.mul(b3, t2);
        Z3 = Fp2.add(X3, Z3);
        X3 = Fp2.sub(t1, Z3);
        Z3 = Fp2.add(t1, Z3);
        Y3 = Fp2.mul(X3, Z3);
        t1 = Fp2.add(t0, t0);
        t1 = Fp2.add(t1, t0);
        t2 = Fp2.mul(a, t2);
        t4 = Fp2.mul(b3, t4);
        t1 = Fp2.add(t1, t2);
        t2 = Fp2.sub(t0, t2);
        t2 = Fp2.mul(a, t2);
        t4 = Fp2.add(t4, t2);
        t0 = Fp2.mul(t1, t4);
        Y3 = Fp2.add(Y3, t0);
        t0 = Fp2.mul(t5, t4);
        X3 = Fp2.mul(t3, X3);
        X3 = Fp2.sub(X3, t0);
        t0 = Fp2.mul(t3, t1);
        Z3 = Fp2.mul(t5, Z3);
        Z3 = Fp2.add(Z3, t0);
        return new Point3(X3, Y3, Z3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      is0() {
        return this.equals(Point3.ZERO);
      }
      /**
       * Constant time multiplication.
       * Uses wNAF method. Windowed method may be 10% faster,
       * but takes 2x longer to generate and consumes 2x memory.
       * Uses precomputes when available.
       * Uses endomorphism for Koblitz curves.
       * @param scalar by which the point would be multiplied
       * @returns New point
       */
      multiply(scalar) {
        const { endo: endo2 } = extraOpts;
        if (!Fn.isValidNot0(scalar))
          throw new Error("invalid scalar: out of range");
        let point, fake;
        const mul = (n) => wnaf.cached(this, n, (p) => normalizeZ(Point3, p));
        if (endo2) {
          const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);
          const { p: k1p, f: k1f } = mul(k1);
          const { p: k2p, f: k2f } = mul(k2);
          fake = k1f.add(k2f);
          point = finishEndo(endo2.beta, k1p, k2p, k1neg, k2neg);
        } else {
          const { p, f } = mul(scalar);
          point = p;
          fake = f;
        }
        return normalizeZ(Point3, [point, fake])[0];
      }
      /**
       * Non-constant-time multiplication. Uses double-and-add algorithm.
       * It's faster, but should only be used when you don't care about
       * an exposed secret key e.g. sig verification, which works over *public* keys.
       */
      multiplyUnsafe(sc) {
        const { endo: endo2 } = extraOpts;
        const p = this;
        if (!Fn.isValid(sc))
          throw new Error("invalid scalar: out of range");
        if (sc === _0n10 || p.is0())
          return Point3.ZERO;
        if (sc === _1n10)
          return p;
        if (wnaf.hasCache(this))
          return this.multiply(sc);
        if (endo2) {
          const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);
          const { p1, p2 } = mulEndoUnsafe(Point3, p, k1, k2);
          return finishEndo(endo2.beta, p1, p2, k1neg, k2neg);
        } else {
          return wnaf.unsafe(p, sc);
        }
      }
      multiplyAndAddUnsafe(Q, a, b) {
        const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));
        return sum.is0() ? void 0 : sum;
      }
      /**
       * Converts Projective point to affine (x, y) coordinates.
       * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
       */
      toAffine(invertedZ) {
        return toAffineMemo(this, invertedZ);
      }
      /**
       * Checks whether Point is free of torsion elements (is in prime subgroup).
       * Always torsion-free for cofactor=1 curves.
       */
      isTorsionFree() {
        const { isTorsionFree } = extraOpts;
        if (cofactor === _1n10)
          return true;
        if (isTorsionFree)
          return isTorsionFree(Point3, this);
        return wnaf.unsafe(this, CURVE_ORDER).is0();
      }
      clearCofactor() {
        const { clearCofactor } = extraOpts;
        if (cofactor === _1n10)
          return this;
        if (clearCofactor)
          return clearCofactor(Point3, this);
        return this.multiplyUnsafe(cofactor);
      }
      isSmallOrder() {
        return this.multiplyUnsafe(cofactor).is0();
      }
      toBytes(isCompressed = true) {
        _abool2(isCompressed, "isCompressed");
        this.assertValidity();
        return encodePoint(Point3, this, isCompressed);
      }
      toHex(isCompressed = true) {
        return bytesToHex3(this.toBytes(isCompressed));
      }
      toString() {
        return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
      }
      // TODO: remove
      get px() {
        return this.X;
      }
      get py() {
        return this.X;
      }
      get pz() {
        return this.Z;
      }
      toRawBytes(isCompressed = true) {
        return this.toBytes(isCompressed);
      }
      _setWindowSize(windowSize) {
        this.precompute(windowSize);
      }
      static normalizeZ(points) {
        return normalizeZ(Point3, points);
      }
      static msm(points, scalars) {
        return pippenger(Point3, Fn, points, scalars);
      }
      static fromPrivateKey(privateKey) {
        return Point3.BASE.multiply(_normFnElement(Fn, privateKey));
      }
    }
    Point3.BASE = new Point3(CURVE.Gx, CURVE.Gy, Fp2.ONE);
    Point3.ZERO = new Point3(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
    Point3.Fp = Fp2;
    Point3.Fn = Fn;
    const bits = Fn.BITS;
    const wnaf = new wNAF2(Point3, extraOpts.endo ? Math.ceil(bits / 2) : bits);
    Point3.BASE.precompute(8);
    return Point3;
  }
  function pprefix(hasEvenY) {
    return Uint8Array.of(hasEvenY ? 2 : 3);
  }
  function getWLengths(Fp2, Fn) {
    return {
      secretKey: Fn.BYTES,
      publicKey: 1 + Fp2.BYTES,
      publicKeyUncompressed: 1 + 2 * Fp2.BYTES,
      publicKeyHasPrefix: true,
      signature: 2 * Fn.BYTES
    };
  }
  function ecdh(Point3, ecdhOpts = {}) {
    const { Fn } = Point3;
    const randomBytes_ = ecdhOpts.randomBytes || randomBytes2;
    const lengths = Object.assign(getWLengths(Point3.Fp, Fn), { seed: getMinHashLength2(Fn.ORDER) });
    function isValidSecretKey(secretKey) {
      try {
        return !!_normFnElement(Fn, secretKey);
      } catch (error) {
        return false;
      }
    }
    function isValidPublicKey(publicKey, isCompressed) {
      const { publicKey: comp, publicKeyUncompressed } = lengths;
      try {
        const l = publicKey.length;
        if (isCompressed === true && l !== comp)
          return false;
        if (isCompressed === false && l !== publicKeyUncompressed)
          return false;
        return !!Point3.fromBytes(publicKey);
      } catch (error) {
        return false;
      }
    }
    function randomSecretKey(seed = randomBytes_(lengths.seed)) {
      return mapHashToField2(_abytes2(seed, lengths.seed, "seed"), Fn.ORDER);
    }
    function getPublicKey(secretKey, isCompressed = true) {
      return Point3.BASE.multiply(_normFnElement(Fn, secretKey)).toBytes(isCompressed);
    }
    function keygen(seed) {
      const secretKey = randomSecretKey(seed);
      return { secretKey, publicKey: getPublicKey(secretKey) };
    }
    function isProbPub(item) {
      if (typeof item === "bigint")
        return false;
      if (item instanceof Point3)
        return true;
      const { secretKey, publicKey, publicKeyUncompressed } = lengths;
      if (Fn.allowedLengths || secretKey === publicKey)
        return void 0;
      const l = ensureBytes2("key", item).length;
      return l === publicKey || l === publicKeyUncompressed;
    }
    function getSharedSecret(secretKeyA, publicKeyB, isCompressed = true) {
      if (isProbPub(secretKeyA) === true)
        throw new Error("first arg must be private key");
      if (isProbPub(publicKeyB) === false)
        throw new Error("second arg must be public key");
      const s = _normFnElement(Fn, secretKeyA);
      const b = Point3.fromHex(publicKeyB);
      return b.multiply(s).toBytes(isCompressed);
    }
    const utils2 = {
      isValidSecretKey,
      isValidPublicKey,
      randomSecretKey,
      // TODO: remove
      isValidPrivateKey: isValidSecretKey,
      randomPrivateKey: randomSecretKey,
      normPrivateKeyToScalar: (key) => _normFnElement(Fn, key),
      precompute(windowSize = 8, point = Point3.BASE) {
        return point.precompute(windowSize, false);
      }
    };
    return Object.freeze({ getPublicKey, getSharedSecret, keygen, Point: Point3, utils: utils2, lengths });
  }
  function ecdsa(Point3, hash3, ecdsaOpts = {}) {
    ahash(hash3);
    _validateObject(ecdsaOpts, {}, {
      hmac: "function",
      lowS: "boolean",
      randomBytes: "function",
      bits2int: "function",
      bits2int_modN: "function"
    });
    const randomBytes3 = ecdsaOpts.randomBytes || randomBytes2;
    const hmac3 = ecdsaOpts.hmac || ((key, ...msgs) => hmac2(hash3, key, concatBytes3(...msgs)));
    const { Fp: Fp2, Fn } = Point3;
    const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;
    const { keygen, getPublicKey, getSharedSecret, utils: utils2, lengths } = ecdh(Point3, ecdsaOpts);
    const defaultSigOpts = {
      prehash: false,
      lowS: typeof ecdsaOpts.lowS === "boolean" ? ecdsaOpts.lowS : false,
      format: void 0,
      //'compact' as ECDSASigFormat,
      extraEntropy: false
    };
    const defaultSigOpts_format = "compact";
    function isBiggerThanHalfOrder(number2) {
      const HALF = CURVE_ORDER >> _1n10;
      return number2 > HALF;
    }
    function validateRS(title, num) {
      if (!Fn.isValidNot0(num))
        throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);
      return num;
    }
    function validateSigLength(bytes2, format) {
      validateSigFormat(format);
      const size = lengths.signature;
      const sizer = format === "compact" ? size : format === "recovered" ? size + 1 : void 0;
      return _abytes2(bytes2, sizer, `${format} signature`);
    }
    class Signature {
      constructor(r, s, recovery) {
        this.r = validateRS("r", r);
        this.s = validateRS("s", s);
        if (recovery != null)
          this.recovery = recovery;
        Object.freeze(this);
      }
      static fromBytes(bytes2, format = defaultSigOpts_format) {
        validateSigLength(bytes2, format);
        let recid;
        if (format === "der") {
          const { r: r2, s: s2 } = DER2.toSig(_abytes2(bytes2));
          return new Signature(r2, s2);
        }
        if (format === "recovered") {
          recid = bytes2[0];
          format = "compact";
          bytes2 = bytes2.subarray(1);
        }
        const L = Fn.BYTES;
        const r = bytes2.subarray(0, L);
        const s = bytes2.subarray(L, L * 2);
        return new Signature(Fn.fromBytes(r), Fn.fromBytes(s), recid);
      }
      static fromHex(hex, format) {
        return this.fromBytes(hexToBytes4(hex), format);
      }
      addRecoveryBit(recovery) {
        return new Signature(this.r, this.s, recovery);
      }
      recoverPublicKey(messageHash) {
        const FIELD_ORDER = Fp2.ORDER;
        const { r, s, recovery: rec } = this;
        if (rec == null || ![0, 1, 2, 3].includes(rec))
          throw new Error("recovery id invalid");
        const hasCofactor = CURVE_ORDER * _2n7 < FIELD_ORDER;
        if (hasCofactor && rec > 1)
          throw new Error("recovery id is ambiguous for h>1 curve");
        const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;
        if (!Fp2.isValid(radj))
          throw new Error("recovery id 2 or 3 invalid");
        const x = Fp2.toBytes(radj);
        const R = Point3.fromBytes(concatBytes3(pprefix((rec & 1) === 0), x));
        const ir = Fn.inv(radj);
        const h = bits2int_modN(ensureBytes2("msgHash", messageHash));
        const u1 = Fn.create(-h * ir);
        const u2 = Fn.create(s * ir);
        const Q = Point3.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));
        if (Q.is0())
          throw new Error("point at infinify");
        Q.assertValidity();
        return Q;
      }
      // Signatures should be low-s, to prevent malleability.
      hasHighS() {
        return isBiggerThanHalfOrder(this.s);
      }
      toBytes(format = defaultSigOpts_format) {
        validateSigFormat(format);
        if (format === "der")
          return hexToBytes4(DER2.hexFromSig(this));
        const r = Fn.toBytes(this.r);
        const s = Fn.toBytes(this.s);
        if (format === "recovered") {
          if (this.recovery == null)
            throw new Error("recovery bit must be present");
          return concatBytes3(Uint8Array.of(this.recovery), r, s);
        }
        return concatBytes3(r, s);
      }
      toHex(format) {
        return bytesToHex3(this.toBytes(format));
      }
      // TODO: remove
      assertValidity() {
      }
      static fromCompact(hex) {
        return Signature.fromBytes(ensureBytes2("sig", hex), "compact");
      }
      static fromDER(hex) {
        return Signature.fromBytes(ensureBytes2("sig", hex), "der");
      }
      normalizeS() {
        return this.hasHighS() ? new Signature(this.r, Fn.neg(this.s), this.recovery) : this;
      }
      toDERRawBytes() {
        return this.toBytes("der");
      }
      toDERHex() {
        return bytesToHex3(this.toBytes("der"));
      }
      toCompactRawBytes() {
        return this.toBytes("compact");
      }
      toCompactHex() {
        return bytesToHex3(this.toBytes("compact"));
      }
    }
    const bits2int = ecdsaOpts.bits2int || function bits2int_def(bytes2) {
      if (bytes2.length > 8192)
        throw new Error("input is too large");
      const num = bytesToNumberBE2(bytes2);
      const delta = bytes2.length * 8 - fnBits;
      return delta > 0 ? num >> BigInt(delta) : num;
    };
    const bits2int_modN = ecdsaOpts.bits2int_modN || function bits2int_modN_def(bytes2) {
      return Fn.create(bits2int(bytes2));
    };
    const ORDER_MASK = bitMask2(fnBits);
    function int2octets(num) {
      aInRange("num < 2^" + fnBits, num, _0n10, ORDER_MASK);
      return Fn.toBytes(num);
    }
    function validateMsgAndHash(message, prehash) {
      _abytes2(message, void 0, "message");
      return prehash ? _abytes2(hash3(message), void 0, "prehashed message") : message;
    }
    function prepSig(message, privateKey, opts) {
      if (["recovered", "canonical"].some((k) => k in opts))
        throw new Error("sign() legacy options not supported");
      const { lowS, prehash, extraEntropy } = validateSigOpts(opts, defaultSigOpts);
      message = validateMsgAndHash(message, prehash);
      const h1int = bits2int_modN(message);
      const d = _normFnElement(Fn, privateKey);
      const seedArgs = [int2octets(d), int2octets(h1int)];
      if (extraEntropy != null && extraEntropy !== false) {
        const e = extraEntropy === true ? randomBytes3(lengths.secretKey) : extraEntropy;
        seedArgs.push(ensureBytes2("extraEntropy", e));
      }
      const seed = concatBytes3(...seedArgs);
      const m = h1int;
      function k2sig(kBytes) {
        const k = bits2int(kBytes);
        if (!Fn.isValidNot0(k))
          return;
        const ik = Fn.inv(k);
        const q = Point3.BASE.multiply(k).toAffine();
        const r = Fn.create(q.x);
        if (r === _0n10)
          return;
        const s = Fn.create(ik * Fn.create(m + r * d));
        if (s === _0n10)
          return;
        let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n10);
        let normS = s;
        if (lowS && isBiggerThanHalfOrder(s)) {
          normS = Fn.neg(s);
          recovery ^= 1;
        }
        return new Signature(r, normS, recovery);
      }
      return { seed, k2sig };
    }
    function sign(message, secretKey, opts = {}) {
      message = ensureBytes2("message", message);
      const { seed, k2sig } = prepSig(message, secretKey, opts);
      const drbg = createHmacDrbg2(hash3.outputLen, Fn.BYTES, hmac3);
      const sig = drbg(seed, k2sig);
      return sig;
    }
    function tryParsingSig(sg) {
      let sig = void 0;
      const isHex = typeof sg === "string" || isBytes3(sg);
      const isObj = !isHex && sg !== null && typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint";
      if (!isHex && !isObj)
        throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
      if (isObj) {
        sig = new Signature(sg.r, sg.s);
      } else if (isHex) {
        try {
          sig = Signature.fromBytes(ensureBytes2("sig", sg), "der");
        } catch (derError) {
          if (!(derError instanceof DER2.Err))
            throw derError;
        }
        if (!sig) {
          try {
            sig = Signature.fromBytes(ensureBytes2("sig", sg), "compact");
          } catch (error) {
            return false;
          }
        }
      }
      if (!sig)
        return false;
      return sig;
    }
    function verify(signature, message, publicKey, opts = {}) {
      const { lowS, prehash, format } = validateSigOpts(opts, defaultSigOpts);
      publicKey = ensureBytes2("publicKey", publicKey);
      message = validateMsgAndHash(ensureBytes2("message", message), prehash);
      if ("strict" in opts)
        throw new Error("options.strict was renamed to lowS");
      const sig = format === void 0 ? tryParsingSig(signature) : Signature.fromBytes(ensureBytes2("sig", signature), format);
      if (sig === false)
        return false;
      try {
        const P = Point3.fromBytes(publicKey);
        if (lowS && sig.hasHighS())
          return false;
        const { r, s } = sig;
        const h = bits2int_modN(message);
        const is = Fn.inv(s);
        const u1 = Fn.create(h * is);
        const u2 = Fn.create(r * is);
        const R = Point3.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2));
        if (R.is0())
          return false;
        const v = Fn.create(R.x);
        return v === r;
      } catch (e) {
        return false;
      }
    }
    function recoverPublicKey(signature, message, opts = {}) {
      const { prehash } = validateSigOpts(opts, defaultSigOpts);
      message = validateMsgAndHash(message, prehash);
      return Signature.fromBytes(signature, "recovered").recoverPublicKey(message).toBytes();
    }
    return Object.freeze({
      keygen,
      getPublicKey,
      getSharedSecret,
      utils: utils2,
      lengths,
      Point: Point3,
      sign,
      verify,
      recoverPublicKey,
      Signature,
      hash: hash3
    });
  }
  function _weierstrass_legacy_opts_to_new(c) {
    const CURVE = {
      a: c.a,
      b: c.b,
      p: c.Fp.ORDER,
      n: c.n,
      h: c.h,
      Gx: c.Gx,
      Gy: c.Gy
    };
    const Fp2 = c.Fp;
    let allowedLengths = c.allowedPrivateKeyLengths ? Array.from(new Set(c.allowedPrivateKeyLengths.map((l) => Math.ceil(l / 2)))) : void 0;
    const Fn = Field2(CURVE.n, {
      BITS: c.nBitLength,
      allowedLengths,
      modFromBytes: c.wrapPrivateKey
    });
    const curveOpts = {
      Fp: Fp2,
      Fn,
      allowInfinityPoint: c.allowInfinityPoint,
      endo: c.endo,
      isTorsionFree: c.isTorsionFree,
      clearCofactor: c.clearCofactor,
      fromBytes: c.fromBytes,
      toBytes: c.toBytes
    };
    return { CURVE, curveOpts };
  }
  function _ecdsa_legacy_opts_to_new(c) {
    const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
    const ecdsaOpts = {
      hmac: c.hmac,
      randomBytes: c.randomBytes,
      lowS: c.lowS,
      bits2int: c.bits2int,
      bits2int_modN: c.bits2int_modN
    };
    return { CURVE, curveOpts, hash: c.hash, ecdsaOpts };
  }
  function _ecdsa_new_output_to_legacy(c, _ecdsa) {
    const Point3 = _ecdsa.Point;
    return Object.assign({}, _ecdsa, {
      ProjectivePoint: Point3,
      CURVE: Object.assign({}, c, nLength2(Point3.Fn.ORDER, Point3.Fn.BITS))
    });
  }
  function weierstrass2(c) {
    const { CURVE, curveOpts, hash: hash3, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);
    const Point3 = weierstrassN(CURVE, curveOpts);
    const signs = ecdsa(Point3, hash3, ecdsaOpts);
    return _ecdsa_new_output_to_legacy(c, signs);
  }

  // node_modules/@noble/curves/esm/_shortw_utils.js
  function createCurve2(curveDef, defHash) {
    const create = (hash3) => weierstrass2({ ...curveDef, hash: hash3 });
    return { ...create(defHash), create };
  }

  // node_modules/@noble/curves/esm/secp256k1.js
  var secp256k1_CURVE = {
    p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
    n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    h: BigInt(1),
    a: BigInt(0),
    b: BigInt(7),
    Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
    Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
  };
  var secp256k1_ENDO = {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    basises: [
      [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
      [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
    ]
  };
  var _2n8 = /* @__PURE__ */ BigInt(2);
  function sqrtMod2(y) {
    const P = secp256k1_CURVE.p;
    const _3n5 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    const b2 = y * y * y % P;
    const b3 = b2 * b2 * y % P;
    const b6 = pow22(b3, _3n5, P) * b3 % P;
    const b9 = pow22(b6, _3n5, P) * b3 % P;
    const b11 = pow22(b9, _2n8, P) * b2 % P;
    const b22 = pow22(b11, _11n, P) * b11 % P;
    const b44 = pow22(b22, _22n, P) * b22 % P;
    const b88 = pow22(b44, _44n, P) * b44 % P;
    const b176 = pow22(b88, _88n, P) * b88 % P;
    const b220 = pow22(b176, _44n, P) * b44 % P;
    const b223 = pow22(b220, _3n5, P) * b3 % P;
    const t1 = pow22(b223, _23n, P) * b22 % P;
    const t2 = pow22(t1, _6n, P) * b2 % P;
    const root = pow22(t2, _2n8, P);
    if (!Fpk1.eql(Fpk1.sqr(root), y))
      throw new Error("Cannot find square root");
    return root;
  }
  var Fpk1 = Field2(secp256k1_CURVE.p, { sqrt: sqrtMod2 });
  var secp256k12 = createCurve2({ ...secp256k1_CURVE, Fp: Fpk1, lowS: true, endo: secp256k1_ENDO }, sha2562);

  // node_modules/@noble/hashes/esm/legacy.js
  var Rho160 = /* @__PURE__ */ Uint8Array.from([
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8
  ]);
  var Id160 = /* @__PURE__ */ (() => Uint8Array.from(new Array(16).fill(0).map((_, i) => i)))();
  var Pi160 = /* @__PURE__ */ (() => Id160.map((i) => (9 * i + 5) % 16))();
  var idxLR = /* @__PURE__ */ (() => {
    const L = [Id160];
    const R = [Pi160];
    const res = [L, R];
    for (let i = 0; i < 4; i++)
      for (let j of res)
        j.push(j[i].map((k) => Rho160[k]));
    return res;
  })();
  var idxL = /* @__PURE__ */ (() => idxLR[0])();
  var idxR = /* @__PURE__ */ (() => idxLR[1])();
  var shifts160 = /* @__PURE__ */ [
    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
  ].map((i) => Uint8Array.from(i));
  var shiftsL160 = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts160[i][j]));
  var shiftsR160 = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts160[i][j]));
  var Kl160 = /* @__PURE__ */ Uint32Array.from([
    0,
    1518500249,
    1859775393,
    2400959708,
    2840853838
  ]);
  var Kr160 = /* @__PURE__ */ Uint32Array.from([
    1352829926,
    1548603684,
    1836072691,
    2053994217,
    0
  ]);
  function ripemd_f(group, x, y, z) {
    if (group === 0)
      return x ^ y ^ z;
    if (group === 1)
      return x & y | ~x & z;
    if (group === 2)
      return (x | ~y) ^ z;
    if (group === 3)
      return x & z | y & ~z;
    return x ^ (y | ~z);
  }
  var BUF_160 = /* @__PURE__ */ new Uint32Array(16);
  var RIPEMD160 = class extends HashMD2 {
    constructor() {
      super(64, 20, 8, true);
      this.h0 = 1732584193 | 0;
      this.h1 = 4023233417 | 0;
      this.h2 = 2562383102 | 0;
      this.h3 = 271733878 | 0;
      this.h4 = 3285377520 | 0;
    }
    get() {
      const { h0, h1, h2, h3, h4 } = this;
      return [h0, h1, h2, h3, h4];
    }
    set(h0, h1, h2, h3, h4) {
      this.h0 = h0 | 0;
      this.h1 = h1 | 0;
      this.h2 = h2 | 0;
      this.h3 = h3 | 0;
      this.h4 = h4 | 0;
    }
    process(view, offset) {
      for (let i = 0; i < 16; i++, offset += 4)
        BUF_160[i] = view.getUint32(offset, true);
      let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
      for (let group = 0; group < 5; group++) {
        const rGroup = 4 - group;
        const hbl = Kl160[group], hbr = Kr160[group];
        const rl = idxL[group], rr = idxR[group];
        const sl = shiftsL160[group], sr = shiftsR160[group];
        for (let i = 0; i < 16; i++) {
          const tl = rotl2(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el | 0;
          al = el, el = dl, dl = rotl2(cl, 10) | 0, cl = bl, bl = tl;
        }
        for (let i = 0; i < 16; i++) {
          const tr = rotl2(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er | 0;
          ar = er, er = dr, dr = rotl2(cr, 10) | 0, cr = br, br = tr;
        }
      }
      this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
    }
    roundClean() {
      clean(BUF_160);
    }
    destroy() {
      this.destroyed = true;
      clean(this.buffer);
      this.set(0, 0, 0, 0, 0);
    }
  };
  var ripemd160 = /* @__PURE__ */ createHasher(() => new RIPEMD160());

  // node_modules/@scure/bip32/lib/esm/index.js
  var Point2 = secp256k12.ProjectivePoint;
  var base58check = createBase58check(sha2562);
  function bytesToNumber(bytes2) {
    abytes2(bytes2);
    const h = bytes2.length === 0 ? "0" : bytesToHex3(bytes2);
    return BigInt("0x" + h);
  }
  function numberToBytes(num) {
    if (typeof num !== "bigint")
      throw new Error("bigint expected");
    return hexToBytes4(num.toString(16).padStart(64, "0"));
  }
  var MASTER_SECRET = utf8ToBytes3("Bitcoin seed");
  var BITCOIN_VERSIONS = { private: 76066276, public: 76067358 };
  var HARDENED_OFFSET = 2147483648;
  var hash160 = (data) => ripemd160(sha2562(data));
  var fromU32 = (data) => createView2(data).getUint32(0, false);
  var toU32 = (n) => {
    if (!Number.isSafeInteger(n) || n < 0 || n > 2 ** 32 - 1) {
      throw new Error("invalid number, should be from 0 to 2**32-1, got " + n);
    }
    const buf = new Uint8Array(4);
    createView2(buf).setUint32(0, n, false);
    return buf;
  };
  var HDKey = class _HDKey {
    get fingerprint() {
      if (!this.pubHash) {
        throw new Error("No publicKey set!");
      }
      return fromU32(this.pubHash);
    }
    get identifier() {
      return this.pubHash;
    }
    get pubKeyHash() {
      return this.pubHash;
    }
    get privateKey() {
      return this.privKeyBytes || null;
    }
    get publicKey() {
      return this.pubKey || null;
    }
    get privateExtendedKey() {
      const priv = this.privateKey;
      if (!priv) {
        throw new Error("No private key");
      }
      return base58check.encode(this.serialize(this.versions.private, concatBytes3(new Uint8Array([0]), priv)));
    }
    get publicExtendedKey() {
      if (!this.pubKey) {
        throw new Error("No public key");
      }
      return base58check.encode(this.serialize(this.versions.public, this.pubKey));
    }
    static fromMasterSeed(seed, versions = BITCOIN_VERSIONS) {
      abytes2(seed);
      if (8 * seed.length < 128 || 8 * seed.length > 512) {
        throw new Error("HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got " + seed.length);
      }
      const I = hmac2(sha512, MASTER_SECRET, seed);
      return new _HDKey({
        versions,
        chainCode: I.slice(32),
        privateKey: I.slice(0, 32)
      });
    }
    static fromExtendedKey(base58key, versions = BITCOIN_VERSIONS) {
      const keyBuffer = base58check.decode(base58key);
      const keyView = createView2(keyBuffer);
      const version = keyView.getUint32(0, false);
      const opt = {
        versions,
        depth: keyBuffer[4],
        parentFingerprint: keyView.getUint32(5, false),
        index: keyView.getUint32(9, false),
        chainCode: keyBuffer.slice(13, 45)
      };
      const key = keyBuffer.slice(45);
      const isPriv = key[0] === 0;
      if (version !== versions[isPriv ? "private" : "public"]) {
        throw new Error("Version mismatch");
      }
      if (isPriv) {
        return new _HDKey({ ...opt, privateKey: key.slice(1) });
      } else {
        return new _HDKey({ ...opt, publicKey: key });
      }
    }
    static fromJSON(json) {
      return _HDKey.fromExtendedKey(json.xpriv);
    }
    constructor(opt) {
      this.depth = 0;
      this.index = 0;
      this.chainCode = null;
      this.parentFingerprint = 0;
      if (!opt || typeof opt !== "object") {
        throw new Error("HDKey.constructor must not be called directly");
      }
      this.versions = opt.versions || BITCOIN_VERSIONS;
      this.depth = opt.depth || 0;
      this.chainCode = opt.chainCode || null;
      this.index = opt.index || 0;
      this.parentFingerprint = opt.parentFingerprint || 0;
      if (!this.depth) {
        if (this.parentFingerprint || this.index) {
          throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");
        }
      }
      if (opt.publicKey && opt.privateKey) {
        throw new Error("HDKey: publicKey and privateKey at same time.");
      }
      if (opt.privateKey) {
        if (!secp256k12.utils.isValidPrivateKey(opt.privateKey)) {
          throw new Error("Invalid private key");
        }
        this.privKey = typeof opt.privateKey === "bigint" ? opt.privateKey : bytesToNumber(opt.privateKey);
        this.privKeyBytes = numberToBytes(this.privKey);
        this.pubKey = secp256k12.getPublicKey(opt.privateKey, true);
      } else if (opt.publicKey) {
        this.pubKey = Point2.fromHex(opt.publicKey).toRawBytes(true);
      } else {
        throw new Error("HDKey: no public or private key provided");
      }
      this.pubHash = hash160(this.pubKey);
    }
    derive(path) {
      if (!/^[mM]'?/.test(path)) {
        throw new Error('Path must start with "m" or "M"');
      }
      if (/^[mM]'?$/.test(path)) {
        return this;
      }
      const parts = path.replace(/^[mM]'?\//, "").split("/");
      let child = this;
      for (const c of parts) {
        const m = /^(\d+)('?)$/.exec(c);
        const m1 = m && m[1];
        if (!m || m.length !== 3 || typeof m1 !== "string")
          throw new Error("invalid child index: " + c);
        let idx = +m1;
        if (!Number.isSafeInteger(idx) || idx >= HARDENED_OFFSET) {
          throw new Error("Invalid index");
        }
        if (m[2] === "'") {
          idx += HARDENED_OFFSET;
        }
        child = child.deriveChild(idx);
      }
      return child;
    }
    deriveChild(index) {
      if (!this.pubKey || !this.chainCode) {
        throw new Error("No publicKey or chainCode set");
      }
      let data = toU32(index);
      if (index >= HARDENED_OFFSET) {
        const priv = this.privateKey;
        if (!priv) {
          throw new Error("Could not derive hardened child key");
        }
        data = concatBytes3(new Uint8Array([0]), priv, data);
      } else {
        data = concatBytes3(this.pubKey, data);
      }
      const I = hmac2(sha512, this.chainCode, data);
      const childTweak = bytesToNumber(I.slice(0, 32));
      const chainCode = I.slice(32);
      if (!secp256k12.utils.isValidPrivateKey(childTweak)) {
        throw new Error("Tweak bigger than curve order");
      }
      const opt = {
        versions: this.versions,
        chainCode,
        depth: this.depth + 1,
        parentFingerprint: this.fingerprint,
        index
      };
      try {
        if (this.privateKey) {
          const added = mod2(this.privKey + childTweak, secp256k12.CURVE.n);
          if (!secp256k12.utils.isValidPrivateKey(added)) {
            throw new Error("The tweak was out of range or the resulted private key is invalid");
          }
          opt.privateKey = added;
        } else {
          const added = Point2.fromHex(this.pubKey).add(Point2.fromPrivateKey(childTweak));
          if (added.equals(Point2.ZERO)) {
            throw new Error("The tweak was equal to negative P, which made the result key invalid");
          }
          opt.publicKey = added.toRawBytes(true);
        }
        return new _HDKey(opt);
      } catch (err) {
        return this.deriveChild(index + 1);
      }
    }
    sign(hash3) {
      if (!this.privateKey) {
        throw new Error("No privateKey set!");
      }
      abytes2(hash3, 32);
      return secp256k12.sign(hash3, this.privKey).toCompactRawBytes();
    }
    verify(hash3, signature) {
      abytes2(hash3, 32);
      abytes2(signature, 64);
      if (!this.publicKey) {
        throw new Error("No publicKey set!");
      }
      let sig;
      try {
        sig = secp256k12.Signature.fromCompact(signature);
      } catch (error) {
        return false;
      }
      return secp256k12.verify(sig, hash3, this.publicKey);
    }
    wipePrivateData() {
      this.privKey = void 0;
      if (this.privKeyBytes) {
        this.privKeyBytes.fill(0);
        this.privKeyBytes = void 0;
      }
      return this;
    }
    toJSON() {
      return {
        xpriv: this.privateExtendedKey,
        xpub: this.publicExtendedKey
      };
    }
    serialize(version, key) {
      if (!this.chainCode) {
        throw new Error("No chainCode set");
      }
      abytes2(key, 33);
      return concatBytes3(toU32(version), new Uint8Array([this.depth]), toU32(this.parentFingerprint), toU32(this.index), this.chainCode, key);
    }
  };

  // node_modules/@ethereumjs/rlp/dist/esm/index.js
  function encode(input) {
    if (Array.isArray(input)) {
      const output2 = [];
      let outputLength = 0;
      for (let i = 0; i < input.length; i++) {
        const encoded = encode(input[i]);
        output2.push(encoded);
        outputLength += encoded.length;
      }
      return concatBytes4(encodeLength(outputLength, 192), ...output2);
    }
    const inputBuf = toBytes3(input);
    if (inputBuf.length === 1 && inputBuf[0] < 128) {
      return inputBuf;
    }
    return concatBytes4(encodeLength(inputBuf.length, 128), inputBuf);
  }
  function safeSlice(input, start, end) {
    if (end > input.length) {
      throw new Error("invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds");
    }
    return input.slice(start, end);
  }
  function decodeLength(v) {
    if (v[0] === 0) {
      throw new Error("invalid RLP: extra zeros");
    }
    return parseHexByte(bytesToHex4(v));
  }
  function encodeLength(len, offset) {
    if (len < 56) {
      return Uint8Array.from([len + offset]);
    }
    const hexLength = numberToHex(len);
    const lLength = hexLength.length / 2;
    const firstByte = numberToHex(offset + 55 + lLength);
    return Uint8Array.from(hexToBytes5(firstByte + hexLength));
  }
  function decode(input, stream = false) {
    if (typeof input === "undefined" || input === null || input.length === 0) {
      return Uint8Array.from([]);
    }
    const inputBytes = toBytes3(input);
    const decoded = _decode(inputBytes);
    if (stream) {
      return {
        data: decoded.data,
        remainder: decoded.remainder.slice()
      };
    }
    if (decoded.remainder.length !== 0) {
      throw new Error("invalid RLP: remainder must be zero");
    }
    return decoded.data;
  }
  function _decode(input) {
    let length, llength, data, innerRemainder, d;
    const decoded = [];
    const firstByte = input[0];
    if (firstByte <= 127) {
      return {
        data: input.slice(0, 1),
        remainder: input.subarray(1)
      };
    } else if (firstByte <= 183) {
      length = firstByte - 127;
      if (firstByte === 128) {
        data = Uint8Array.from([]);
      } else {
        data = safeSlice(input, 1, length);
      }
      if (length === 2 && data[0] < 128) {
        throw new Error("invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed");
      }
      return {
        data,
        remainder: input.subarray(length)
      };
    } else if (firstByte <= 191) {
      llength = firstByte - 182;
      if (input.length - 1 < llength) {
        throw new Error("invalid RLP: not enough bytes for string length");
      }
      length = decodeLength(safeSlice(input, 1, llength));
      if (length <= 55) {
        throw new Error("invalid RLP: expected string length to be greater than 55");
      }
      data = safeSlice(input, llength, length + llength);
      return {
        data,
        remainder: input.subarray(length + llength)
      };
    } else if (firstByte <= 247) {
      length = firstByte - 191;
      innerRemainder = safeSlice(input, 1, length);
      while (innerRemainder.length) {
        d = _decode(innerRemainder);
        decoded.push(d.data);
        innerRemainder = d.remainder;
      }
      return {
        data: decoded,
        remainder: input.subarray(length)
      };
    } else {
      llength = firstByte - 246;
      length = decodeLength(safeSlice(input, 1, llength));
      if (length < 56) {
        throw new Error("invalid RLP: encoded list too short");
      }
      const totalLength = llength + length;
      if (totalLength > input.length) {
        throw new Error("invalid RLP: total length is larger than the data");
      }
      innerRemainder = safeSlice(input, llength, totalLength);
      while (innerRemainder.length) {
        d = _decode(innerRemainder);
        decoded.push(d.data);
        innerRemainder = d.remainder;
      }
      return {
        data: decoded,
        remainder: input.subarray(totalLength)
      };
    }
  }
  var cachedHexes = Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, "0"));
  function bytesToHex4(uint8a) {
    let hex = "";
    for (let i = 0; i < uint8a.length; i++) {
      hex += cachedHexes[uint8a[i]];
    }
    return hex;
  }
  function parseHexByte(hexByte) {
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte))
      throw new Error("Invalid byte sequence");
    return byte;
  }
  function hexToBytes5(hex) {
    if (typeof hex !== "string") {
      throw new TypeError("hexToBytes: expected string, got " + typeof hex);
    }
    if (hex.length % 2)
      throw new Error("hexToBytes: received invalid unpadded hex");
    const array = new Uint8Array(hex.length / 2);
    for (let i = 0; i < array.length; i++) {
      const j = i * 2;
      array[i] = parseHexByte(hex.slice(j, j + 2));
    }
    return array;
  }
  function concatBytes4(...arrays) {
    if (arrays.length === 1)
      return arrays[0];
    const length = arrays.reduce((a, arr) => a + arr.length, 0);
    const result = new Uint8Array(length);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
      const arr = arrays[i];
      result.set(arr, pad);
      pad += arr.length;
    }
    return result;
  }
  function utf8ToBytes4(utf) {
    return new TextEncoder().encode(utf);
  }
  function numberToHex(integer) {
    if (integer < 0) {
      throw new Error("Invalid integer as argument, must be unsigned!");
    }
    const hex = integer.toString(16);
    return hex.length % 2 ? `0${hex}` : hex;
  }
  function padToEven(a) {
    return a.length % 2 ? `0${a}` : a;
  }
  function isHexPrefixed(str) {
    return str.length >= 2 && str[0] === "0" && str[1] === "x";
  }
  function stripHexPrefix(str) {
    if (typeof str !== "string") {
      return str;
    }
    return isHexPrefixed(str) ? str.slice(2) : str;
  }
  function toBytes3(v) {
    if (v instanceof Uint8Array) {
      return v;
    }
    if (typeof v === "string") {
      if (isHexPrefixed(v)) {
        return hexToBytes5(padToEven(stripHexPrefix(v)));
      }
      return utf8ToBytes4(v);
    }
    if (typeof v === "number" || typeof v === "bigint") {
      if (!v) {
        return Uint8Array.from([]);
      }
      return hexToBytes5(numberToHex(v));
    }
    if (v === null || v === void 0) {
      return Uint8Array.from([]);
    }
    throw new Error("toBytes: received unsupported type " + typeof v);
  }
  var RLP = { encode, decode };

  // node_modules/@ethereumjs/util/dist/esm/internal.js
  function isHexString(value, length) {
    if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/))
      return false;
    if (typeof length !== "undefined" && length > 0 && value.length !== 2 + 2 * length)
      return false;
    return true;
  }
  var stripHexPrefix2 = (str) => {
    if (typeof str !== "string")
      throw new Error(`[stripHexPrefix] input must be type 'string', received ${typeof str}`);
    return isHexString(str) ? str.slice(2) : str;
  };
  function padToEven2(value) {
    let a = value;
    if (typeof a !== "string") {
      throw new Error(`[padToEven] value must be type 'string', received ${typeof a}`);
    }
    if (a.length % 2)
      a = `0${a}`;
    return a;
  }

  // node_modules/@ethereumjs/util/dist/esm/helpers.js
  var assertIsHexString = function(input) {
    if (!isHexString(input)) {
      const msg = `This method only supports 0x-prefixed hex strings but input was: ${input}`;
      throw new Error(msg);
    }
  };
  var assertIsBytes = function(input) {
    if (!(input instanceof Uint8Array)) {
      const msg = `This method only supports Uint8Array but input was: ${input}`;
      throw new Error(msg);
    }
  };
  var assertIsString = function(input) {
    if (typeof input !== "string") {
      const msg = `This method only supports strings but input was: ${input}`;
      throw new Error(msg);
    }
  };

  // node_modules/@ethereumjs/util/dist/esm/bytes.js
  var BIGINT_0 = BigInt(0);
  var hexToBytesMapFirstKey = {};
  var hexToBytesMapSecondKey = {};
  for (let i = 0; i < 16; i++) {
    const vSecondKey = i;
    const vFirstKey = i * 16;
    const key = i.toString(16).toLowerCase();
    hexToBytesMapSecondKey[key] = vSecondKey;
    hexToBytesMapSecondKey[key.toUpperCase()] = vSecondKey;
    hexToBytesMapFirstKey[key] = vFirstKey;
    hexToBytesMapFirstKey[key.toUpperCase()] = vFirstKey;
  }
  function _unprefixedHexToBytes(hex) {
    const byteLen = hex.length;
    const bytes2 = new Uint8Array(byteLen / 2);
    for (let i = 0; i < byteLen; i += 2) {
      bytes2[i / 2] = hexToBytesMapFirstKey[hex[i]] + hexToBytesMapSecondKey[hex[i + 1]];
    }
    return bytes2;
  }
  var unprefixedHexToBytes = (inp) => {
    if (inp.slice(0, 2) === "0x") {
      throw new Error("hex string is prefixed with 0x, should be unprefixed");
    } else {
      return _unprefixedHexToBytes(padToEven2(inp));
    }
  };
  var hexByByte = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
  var bytesToHex5 = (bytes2) => {
    let hex = `0x`;
    if (bytes2 === void 0 || bytes2.length === 0)
      return hex;
    for (const byte of bytes2) {
      hex = `${hex}${hexByByte[byte]}`;
    }
    return hex;
  };
  var BIGINT_CACHE = [];
  for (let i = 0; i <= 256 * 256 - 1; i++) {
    BIGINT_CACHE[i] = BigInt(i);
  }
  var bytesToBigInt = (bytes2, littleEndian = false) => {
    if (littleEndian) {
      bytes2.reverse();
    }
    const hex = bytesToHex5(bytes2);
    if (hex === "0x") {
      return BIGINT_0;
    }
    if (hex.length === 4) {
      return BIGINT_CACHE[bytes2[0]];
    }
    if (hex.length === 6) {
      return BIGINT_CACHE[bytes2[0] * 256 + bytes2[1]];
    }
    return BigInt(hex);
  };
  var hexToBytes6 = (hex) => {
    if (typeof hex !== "string") {
      throw new Error(`hex argument type ${typeof hex} must be of type string`);
    }
    if (!/^0x[0-9a-fA-F]*$/.test(hex)) {
      throw new Error(`Input must be a 0x-prefixed hexadecimal string, got ${hex}`);
    }
    const unprefixedHex = hex.slice(2);
    return _unprefixedHexToBytes(unprefixedHex.length % 2 === 0 ? unprefixedHex : padToEven2(unprefixedHex));
  };
  var intToHex = (i) => {
    if (!Number.isSafeInteger(i) || i < 0) {
      throw new Error(`Received an invalid integer type: ${i}`);
    }
    return `0x${i.toString(16)}`;
  };
  var intToBytes = (i) => {
    const hex = intToHex(i);
    return hexToBytes6(hex);
  };
  var bigIntToBytes = (num, littleEndian = false) => {
    const bytes2 = toBytes4(`0x${padToEven2(num.toString(16))}`);
    return littleEndian ? bytes2.reverse() : bytes2;
  };
  var zeros = (bytes2) => {
    return new Uint8Array(bytes2);
  };
  var setLength = (msg, length, right) => {
    if (right) {
      if (msg.length < length) {
        return new Uint8Array([...msg, ...zeros(length - msg.length)]);
      }
      return msg.subarray(0, length);
    } else {
      if (msg.length < length) {
        return new Uint8Array([...zeros(length - msg.length), ...msg]);
      }
      return msg.subarray(-length);
    }
  };
  var setLengthLeft = (msg, length) => {
    assertIsBytes(msg);
    return setLength(msg, length, false);
  };
  var stripZeros = (a) => {
    let first = a[0];
    while (a.length > 0 && first.toString() === "0") {
      a = a.slice(1);
      first = a[0];
    }
    return a;
  };
  var unpadBytes = (a) => {
    assertIsBytes(a);
    return stripZeros(a);
  };
  var toBytes4 = (v) => {
    if (v === null || v === void 0) {
      return new Uint8Array();
    }
    if (Array.isArray(v) || v instanceof Uint8Array) {
      return Uint8Array.from(v);
    }
    if (typeof v === "string") {
      if (!isHexString(v)) {
        throw new Error(`Cannot convert string to Uint8Array. toBytes only supports 0x-prefixed hex strings and this string was given: ${v}`);
      }
      return hexToBytes6(v);
    }
    if (typeof v === "number") {
      return intToBytes(v);
    }
    if (typeof v === "bigint") {
      if (v < BIGINT_0) {
        throw new Error(`Cannot convert negative bigint to Uint8Array. Given: ${v}`);
      }
      let n = v.toString(16);
      if (n.length % 2)
        n = "0" + n;
      return unprefixedHexToBytes(n);
    }
    if (v.toBytes !== void 0) {
      return v.toBytes();
    }
    throw new Error("invalid type");
  };
  var validateNoLeadingZeroes = (values) => {
    for (const [k, v] of Object.entries(values)) {
      if (v !== void 0 && v.length > 0 && v[0] === 0) {
        throw new Error(`${k} cannot have leading zeroes, received: ${bytesToHex5(v)}`);
      }
    }
  };
  var bigIntToHex = (num) => {
    return `0x${num.toString(16)}`;
  };
  var bigIntToUnpaddedBytes = (value) => {
    return unpadBytes(bigIntToBytes(value));
  };
  var concatBytes5 = (...arrays) => {
    if (arrays.length === 1)
      return arrays[0];
    const length = arrays.reduce((a, arr) => a + arr.length, 0);
    const result = new Uint8Array(length);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
      const arr = arrays[i];
      result.set(arr, pad);
      pad += arr.length;
    }
    return result;
  };

  // node_modules/@ethereumjs/util/dist/esm/constants.js
  var MAX_UINT64 = BigInt("0xffffffffffffffff");
  var MAX_INTEGER = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
  var MAX_INTEGER_BIGINT = BigInt("115792089237316195423570985008687907853269984665640564039457584007913129639935");
  var SECP256K1_ORDER = secp256k1.CURVE.n;
  var SECP256K1_ORDER_DIV_2 = secp256k1.CURVE.n / BigInt(2);
  var TWO_POW256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
  var KECCAK256_NULL_S = "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
  var KECCAK256_NULL = hexToBytes6(KECCAK256_NULL_S);
  var KECCAK256_RLP_ARRAY_S = "0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347";
  var KECCAK256_RLP_ARRAY = hexToBytes6(KECCAK256_RLP_ARRAY_S);
  var KECCAK256_RLP_S = "0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421";
  var KECCAK256_RLP = hexToBytes6(KECCAK256_RLP_S);
  var RLP_EMPTY_STRING = Uint8Array.from([128]);
  var BIGINT_NEG1 = BigInt(-1);
  var BIGINT_02 = BigInt(0);
  var BIGINT_1 = BigInt(1);
  var BIGINT_2 = BigInt(2);
  var BIGINT_3 = BigInt(3);
  var BIGINT_7 = BigInt(7);
  var BIGINT_8 = BigInt(8);
  var BIGINT_27 = BigInt(27);
  var BIGINT_28 = BigInt(28);
  var BIGINT_31 = BigInt(31);
  var BIGINT_32 = BigInt(32);
  var BIGINT_64 = BigInt(64);
  var BIGINT_128 = BigInt(128);
  var BIGINT_255 = BigInt(255);
  var BIGINT_256 = BigInt(256);
  var BIGINT_96 = BigInt(96);
  var BIGINT_100 = BigInt(100);
  var BIGINT_160 = BigInt(160);
  var BIGINT_224 = BigInt(224);
  var BIGINT_2EXP96 = BigInt(7922816251426434e13);
  var BIGINT_2EXP160 = BigInt(1461501637330903e33);
  var BIGINT_2EXP224 = BigInt(2695994666715064e52);
  var BIGINT_2EXP256 = BIGINT_2 ** BIGINT_256;

  // node_modules/@ethereumjs/util/dist/esm/units.js
  var GWEI_TO_WEI = BigInt(1e9);

  // node_modules/@ethereumjs/util/dist/esm/account.js
  var isValidAddress = function(hexAddress) {
    try {
      assertIsString(hexAddress);
    } catch (e) {
      return false;
    }
    return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);
  };
  var toChecksumAddress = function(hexAddress, eip1191ChainId) {
    assertIsHexString(hexAddress);
    const address = stripHexPrefix2(hexAddress).toLowerCase();
    let prefix = "";
    if (eip1191ChainId !== void 0) {
      const chainId = bytesToBigInt(toBytes4(eip1191ChainId));
      prefix = chainId.toString() + "0x";
    }
    const bytes2 = utf8ToBytes(prefix + address);
    const hash3 = bytesToHex5(keccak256(bytes2)).slice(2);
    let ret = "";
    for (let i = 0; i < address.length; i++) {
      if (parseInt(hash3[i], 16) >= 8) {
        ret += address[i].toUpperCase();
      } else {
        ret += address[i];
      }
    }
    return `0x${ret}`;
  };
  var generateAddress = function(from, nonce) {
    assertIsBytes(from);
    assertIsBytes(nonce);
    if (bytesToBigInt(nonce) === BIGINT_02) {
      return keccak256(RLP.encode([from, Uint8Array.from([])])).subarray(-20);
    }
    return keccak256(RLP.encode([from, nonce])).subarray(-20);
  };
  var generateAddress2 = function(from, salt, initCode) {
    assertIsBytes(from);
    assertIsBytes(salt);
    assertIsBytes(initCode);
    if (from.length !== 20) {
      throw new Error("Expected from to be of length 20");
    }
    if (salt.length !== 32) {
      throw new Error("Expected salt to be of length 32");
    }
    const address = keccak256(concatBytes5(hexToBytes6("0xff"), from, salt, keccak256(initCode)));
    return address.subarray(-20);
  };
  var pubToAddress = function(pubKey, sanitize = false) {
    assertIsBytes(pubKey);
    if (sanitize && pubKey.length !== 64) {
      pubKey = secp256k1.ProjectivePoint.fromHex(pubKey).toRawBytes(false).slice(1);
    }
    if (pubKey.length !== 64) {
      throw new Error("Expected pubKey to be of length 64");
    }
    return keccak256(pubKey).subarray(-20);
  };
  var publicToAddress = pubToAddress;
  var privateToPublic = function(privateKey) {
    assertIsBytes(privateKey);
    return secp256k1.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(false).slice(1);
  };
  var privateToAddress = function(privateKey) {
    return publicToAddress(privateToPublic(privateKey));
  };
  var emptyUint8Arr = new Uint8Array(0);

  // node_modules/@ethereumjs/util/dist/esm/address.js
  var Address = class _Address {
    constructor(bytes2) {
      if (bytes2.length !== 20) {
        throw new Error("Invalid address length");
      }
      this.bytes = bytes2;
    }
    /**
     * Returns the zero address.
     */
    static zero() {
      return new _Address(zeros(20));
    }
    /**
     * Returns an Address object from a hex-encoded string.
     * @param str - Hex-encoded address
     */
    static fromString(str) {
      if (!isValidAddress(str)) {
        throw new Error(`Invalid address input=${str}`);
      }
      return new _Address(hexToBytes6(str));
    }
    /**
     * Returns an address for a given public key.
     * @param pubKey The two points of an uncompressed key
     */
    static fromPublicKey(pubKey) {
      if (!(pubKey instanceof Uint8Array)) {
        throw new Error("Public key should be Uint8Array");
      }
      const bytes2 = pubToAddress(pubKey);
      return new _Address(bytes2);
    }
    /**
     * Returns an address for a given private key.
     * @param privateKey A private key must be 256 bits wide
     */
    static fromPrivateKey(privateKey) {
      if (!(privateKey instanceof Uint8Array)) {
        throw new Error("Private key should be Uint8Array");
      }
      const bytes2 = privateToAddress(privateKey);
      return new _Address(bytes2);
    }
    /**
     * Generates an address for a newly created contract.
     * @param from The address which is creating this new address
     * @param nonce The nonce of the from account
     */
    static generate(from, nonce) {
      if (typeof nonce !== "bigint") {
        throw new Error("Expected nonce to be a bigint");
      }
      return new _Address(generateAddress(from.bytes, bigIntToBytes(nonce)));
    }
    /**
     * Generates an address for a contract created using CREATE2.
     * @param from The address which is creating this new address
     * @param salt A salt
     * @param initCode The init code of the contract being created
     */
    static generate2(from, salt, initCode) {
      if (!(salt instanceof Uint8Array)) {
        throw new Error("Expected salt to be a Uint8Array");
      }
      if (!(initCode instanceof Uint8Array)) {
        throw new Error("Expected initCode to be a Uint8Array");
      }
      return new _Address(generateAddress2(from.bytes, salt, initCode));
    }
    /**
     * Is address equal to another.
     */
    equals(address) {
      return equalsBytes(this.bytes, address.bytes);
    }
    /**
     * Is address zero.
     */
    isZero() {
      return this.equals(_Address.zero());
    }
    /**
     * True if address is in the address range defined
     * by EIP-1352
     */
    isPrecompileOrSystemAddress() {
      const address = bytesToBigInt(this.bytes);
      const rangeMin = BIGINT_02;
      const rangeMax = BigInt("0xffff");
      return address >= rangeMin && address <= rangeMax;
    }
    /**
     * Returns hex encoding of address.
     */
    toString() {
      return bytesToHex5(this.bytes);
    }
    /**
     * Returns a new Uint8Array representation of address.
     */
    toBytes() {
      return new Uint8Array(this.bytes);
    }
  };

  // node_modules/@ethereumjs/util/dist/esm/db.js
  var KeyEncoding;
  (function(KeyEncoding2) {
    KeyEncoding2["String"] = "string";
    KeyEncoding2["Bytes"] = "view";
    KeyEncoding2["Number"] = "number";
  })(KeyEncoding || (KeyEncoding = {}));
  var ValueEncoding;
  (function(ValueEncoding2) {
    ValueEncoding2["String"] = "string";
    ValueEncoding2["Bytes"] = "view";
    ValueEncoding2["JSON"] = "json";
  })(ValueEncoding || (ValueEncoding = {}));

  // node_modules/@ethereumjs/util/dist/esm/types.js
  var TypeOutput;
  (function(TypeOutput2) {
    TypeOutput2[TypeOutput2["Number"] = 0] = "Number";
    TypeOutput2[TypeOutput2["BigInt"] = 1] = "BigInt";
    TypeOutput2[TypeOutput2["Uint8Array"] = 2] = "Uint8Array";
    TypeOutput2[TypeOutput2["PrefixedHexString"] = 3] = "PrefixedHexString";
  })(TypeOutput || (TypeOutput = {}));
  function toType(input, outputType) {
    if (input === null) {
      return null;
    }
    if (input === void 0) {
      return void 0;
    }
    if (typeof input === "string" && !isHexString(input)) {
      throw new Error(`A string must be provided with a 0x-prefix, given: ${input}`);
    } else if (typeof input === "number" && !Number.isSafeInteger(input)) {
      throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)");
    }
    const output2 = toBytes4(input);
    switch (outputType) {
      case TypeOutput.Uint8Array:
        return output2;
      case TypeOutput.BigInt:
        return bytesToBigInt(output2);
      case TypeOutput.Number: {
        const bigInt = bytesToBigInt(output2);
        if (bigInt > BigInt(Number.MAX_SAFE_INTEGER)) {
          throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)");
        }
        return Number(bigInt);
      }
      case TypeOutput.PrefixedHexString:
        return bytesToHex5(output2);
      default:
        throw new Error("unknown outputType");
    }
  }

  // node_modules/@ethereumjs/util/dist/esm/signature.js
  function ecsign(msgHash, privateKey, chainId) {
    const sig = secp256k1.sign(msgHash, privateKey);
    const buf = sig.toCompactRawBytes();
    const r = buf.slice(0, 32);
    const s = buf.slice(32, 64);
    const v = chainId === void 0 ? BigInt(sig.recovery + 27) : BigInt(sig.recovery + 35) + BigInt(chainId) * BIGINT_2;
    return { r, s, v };
  }
  function calculateSigRecovery(v, chainId) {
    if (v === BIGINT_02 || v === BIGINT_1)
      return v;
    if (chainId === void 0) {
      return v - BIGINT_27;
    }
    return v - (chainId * BIGINT_2 + BigInt(35));
  }
  function isValidSigRecovery(recovery) {
    return recovery === BIGINT_02 || recovery === BIGINT_1;
  }
  var ecrecover = function(msgHash, v, r, s, chainId) {
    const signature = concatBytes5(setLengthLeft(r, 32), setLengthLeft(s, 32));
    const recovery = calculateSigRecovery(v, chainId);
    if (!isValidSigRecovery(recovery)) {
      throw new Error("Invalid signature v value");
    }
    const sig = secp256k1.Signature.fromCompact(signature).addRecoveryBit(Number(recovery));
    const senderPubKey = sig.recoverPublicKey(msgHash);
    return senderPubKey.toRawBytes(false).slice(1);
  };

  // node_modules/@ethereumjs/util/dist/esm/asyncEventEmitter.js
  var import_events = __toESM(require_events(), 1);

  // node_modules/ethereum-cryptography/esm/sha256.js
  var sha2563 = wrapHash(sha256);

  // node_modules/@ethereumjs/util/dist/esm/blobs.js
  var BYTES_PER_FIELD_ELEMENT = 32;
  var FIELD_ELEMENTS_PER_BLOB = 4096;
  var USEFUL_BYTES_PER_BLOB = 32 * FIELD_ELEMENTS_PER_BLOB;
  var MAX_BLOBS_PER_TX = 2;
  var MAX_USEFUL_BYTES_PER_TX = USEFUL_BYTES_PER_BLOB * MAX_BLOBS_PER_TX - 1;
  var BLOB_SIZE = BYTES_PER_FIELD_ELEMENT * FIELD_ELEMENTS_PER_BLOB;

  // node_modules/@ethereumjs/util/dist/esm/requests.js
  var CLRequestType;
  (function(CLRequestType2) {
    CLRequestType2[CLRequestType2["Deposit"] = 0] = "Deposit";
    CLRequestType2[CLRequestType2["Withdrawal"] = 1] = "Withdrawal";
    CLRequestType2[CLRequestType2["Consolidation"] = 2] = "Consolidation";
  })(CLRequestType || (CLRequestType = {}));

  // node_modules/@ethereumjs/util/dist/esm/verkle.js
  var VerkleLeafType;
  (function(VerkleLeafType2) {
    VerkleLeafType2[VerkleLeafType2["Version"] = 0] = "Version";
    VerkleLeafType2[VerkleLeafType2["Balance"] = 1] = "Balance";
    VerkleLeafType2[VerkleLeafType2["Nonce"] = 2] = "Nonce";
    VerkleLeafType2[VerkleLeafType2["CodeHash"] = 3] = "CodeHash";
    VerkleLeafType2[VerkleLeafType2["CodeSize"] = 4] = "CodeSize";
  })(VerkleLeafType || (VerkleLeafType = {}));
  var VERKLE_VERSION_LEAF_KEY = intToBytes(VerkleLeafType.Version);
  var VERKLE_BALANCE_LEAF_KEY = intToBytes(VerkleLeafType.Balance);
  var VERKLE_NONCE_LEAF_KEY = intToBytes(VerkleLeafType.Nonce);
  var VERKLE_CODE_HASH_LEAF_KEY = intToBytes(VerkleLeafType.CodeHash);
  var VERKLE_CODE_SIZE_LEAF_KEY = intToBytes(VerkleLeafType.CodeSize);
  var VERKLE_MAIN_STORAGE_OFFSET = BigInt(256) ** BigInt(31);

  // node_modules/@ethereumjs/common/dist/esm/common.js
  var import_events2 = __toESM(require_events(), 1);

  // node_modules/@ethereumjs/common/dist/esm/chains.js
  var chains = {
    mainnet: {
      name: "mainnet",
      chainId: 1,
      networkId: 1,
      defaultHardfork: "shanghai",
      consensus: {
        type: "pow",
        algorithm: "ethash",
        ethash: {}
      },
      comment: "The Ethereum main chain",
      url: "https://ethstats.net/",
      genesis: {
        gasLimit: 5e3,
        difficulty: 17179869184,
        nonce: "0x0000000000000042",
        extraData: "0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa"
      },
      depositContractAddress: "0x00000000219ab540356cBB839Cbe05303d7705Fa",
      hardforks: [
        {
          name: "chainstart",
          block: 0,
          forkHash: "0xfc64ec04"
        },
        {
          name: "homestead",
          block: 115e4,
          forkHash: "0x97c2c34c"
        },
        {
          name: "dao",
          block: 192e4,
          forkHash: "0x91d1f948"
        },
        {
          name: "tangerineWhistle",
          block: 2463e3,
          forkHash: "0x7a64da13"
        },
        {
          name: "spuriousDragon",
          block: 2675e3,
          forkHash: "0x3edd5b10"
        },
        {
          name: "byzantium",
          block: 437e4,
          forkHash: "0xa00bc324"
        },
        {
          name: "constantinople",
          block: 728e4,
          forkHash: "0x668db0af"
        },
        {
          name: "petersburg",
          block: 728e4,
          forkHash: "0x668db0af"
        },
        {
          name: "istanbul",
          block: 9069e3,
          forkHash: "0x879d6e30"
        },
        {
          name: "muirGlacier",
          block: 92e5,
          forkHash: "0xe029e991"
        },
        {
          name: "berlin",
          block: 12244e3,
          forkHash: "0x0eb440f6"
        },
        {
          name: "london",
          block: 12965e3,
          forkHash: "0xb715077d"
        },
        {
          name: "arrowGlacier",
          block: 13773e3,
          forkHash: "0x20c327fc"
        },
        {
          name: "grayGlacier",
          block: 1505e4,
          forkHash: "0xf0afd0e3"
        },
        {
          // The forkHash will remain same as mergeForkIdTransition is post merge
          // terminal block: https://etherscan.io/block/15537393
          name: "paris",
          ttd: "58750000000000000000000",
          block: 15537394,
          forkHash: "0xf0afd0e3"
        },
        {
          name: "mergeForkIdTransition",
          block: null,
          forkHash: null
        },
        {
          name: "shanghai",
          block: null,
          timestamp: "1681338455",
          forkHash: "0xdce96c2d"
        },
        {
          name: "cancun",
          block: null,
          timestamp: "1710338135",
          forkHash: "0x9f3d2254"
        },
        {
          name: "prague",
          block: null
        }
      ],
      bootstrapNodes: [
        {
          ip: "18.138.108.67",
          port: 30303,
          id: "d860a01f9722d78051619d1e2351aba3f43f943f6f00718d1b9baa4101932a1f5011f16bb2b1bb35db20d6fe28fa0bf09636d26a87d31de9ec6203eeedb1f666",
          location: "ap-southeast-1-001",
          comment: "bootnode-aws-ap-southeast-1-001"
        },
        {
          ip: "3.209.45.79",
          port: 30303,
          id: "22a8232c3abc76a16ae9d6c3b164f98775fe226f0917b0ca871128a74a8e9630b458460865bab457221f1d448dd9791d24c4e5d88786180ac185df813a68d4de",
          location: "us-east-1-001",
          comment: "bootnode-aws-us-east-1-001"
        },
        {
          ip: "65.108.70.101",
          port: 30303,
          id: "2b252ab6a1d0f971d9722cb839a42cb81db019ba44c08754628ab4a823487071b5695317c8ccd085219c3a03af063495b2f1da8d18218da2d6a82981b45e6ffc",
          location: "eu-west-1-001",
          comment: "bootnode-hetzner-hel"
        },
        {
          ip: "157.90.35.166",
          port: 30303,
          id: "4aeb4ab6c14b23e2c4cfdce879c04b0748a20d8e9b59e25ded2a08143e265c6c25936e74cbc8e641e3312ca288673d91f2f93f8e277de3cfa444ecdaaf982052",
          location: "eu-central-1-001",
          comment: "bootnode-hetzner-fsn"
        }
      ],
      dnsNetworks: [
        "enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.mainnet.ethdisco.net"
      ]
    },
    goerli: {
      name: "goerli",
      chainId: 5,
      networkId: 5,
      defaultHardfork: "shanghai",
      consensus: {
        type: "poa",
        algorithm: "clique",
        clique: {
          period: 15,
          epoch: 3e4
        }
      },
      comment: "Cross-client PoA test network",
      url: "https://github.com/goerli/testnet",
      genesis: {
        timestamp: "0x5c51a607",
        gasLimit: 10485760,
        difficulty: 1,
        nonce: "0x0000000000000000",
        extraData: "0x22466c6578692069732061207468696e6722202d204166726900000000000000e0a2bd4258d2768837baa26a28fe71dc079f84c70000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
      },
      hardforks: [
        {
          name: "chainstart",
          block: 0,
          forkHash: "0xa3f5ab08"
        },
        {
          name: "homestead",
          block: 0,
          forkHash: "0xa3f5ab08"
        },
        {
          name: "tangerineWhistle",
          block: 0,
          forkHash: "0xa3f5ab08"
        },
        {
          name: "spuriousDragon",
          block: 0,
          forkHash: "0xa3f5ab08"
        },
        {
          name: "byzantium",
          block: 0,
          forkHash: "0xa3f5ab08"
        },
        {
          name: "constantinople",
          block: 0,
          forkHash: "0xa3f5ab08"
        },
        {
          name: "petersburg",
          block: 0,
          forkHash: "0xa3f5ab08"
        },
        {
          name: "istanbul",
          block: 1561651,
          forkHash: "0xc25efa5c"
        },
        {
          name: "berlin",
          block: 4460644,
          forkHash: "0x757a1c47"
        },
        {
          name: "london",
          block: 5062605,
          forkHash: "0xb8c6299d"
        },
        {
          // The forkHash will remain same as mergeForkIdTransition is post merge,
          // terminal block: https://goerli.etherscan.io/block/7382818
          name: "paris",
          ttd: "10790000",
          block: 7382819,
          forkHash: "0xb8c6299d"
        },
        {
          name: "mergeForkIdTransition",
          block: null,
          forkHash: null
        },
        {
          name: "shanghai",
          block: null,
          timestamp: "1678832736",
          forkHash: "0xf9843abf"
        },
        {
          name: "cancun",
          block: null,
          timestamp: "1705473120",
          forkHash: "0x70cc14e2"
        }
      ],
      bootstrapNodes: [
        {
          ip: "51.141.78.53",
          port: 30303,
          id: "011f758e6552d105183b1761c5e2dea0111bc20fd5f6422bc7f91e0fabbec9a6595caf6239b37feb773dddd3f87240d99d859431891e4a642cf2a0a9e6cbb98a",
          location: "",
          comment: "Upstream bootnode 1"
        },
        {
          ip: "13.93.54.137",
          port: 30303,
          id: "176b9417f511d05b6b2cf3e34b756cf0a7096b3094572a8f6ef4cdcb9d1f9d00683bf0f83347eebdf3b81c3521c2332086d9592802230bf528eaf606a1d9677b",
          location: "",
          comment: "Upstream bootnode 2"
        },
        {
          ip: "94.237.54.114",
          port: 30313,
          id: "46add44b9f13965f7b9875ac6b85f016f341012d84f975377573800a863526f4da19ae2c620ec73d11591fa9510e992ecc03ad0751f53cc02f7c7ed6d55c7291",
          location: "",
          comment: "Upstream bootnode 3"
        },
        {
          ip: "18.218.250.66",
          port: 30313,
          id: "b5948a2d3e9d486c4d75bf32713221c2bd6cf86463302339299bd227dc2e276cd5a1c7ca4f43a0e9122fe9af884efed563bd2a1fd28661f3b5f5ad7bf1de5949",
          location: "",
          comment: "Upstream bootnode 4"
        },
        {
          ip: "3.11.147.67",
          port: 30303,
          id: "a61215641fb8714a373c80edbfa0ea8878243193f57c96eeb44d0bc019ef295abd4e044fd619bfc4c59731a73fb79afe84e9ab6da0c743ceb479cbb6d263fa91",
          location: "",
          comment: "Ethereum Foundation bootnode"
        },
        {
          ip: "51.15.116.226",
          port: 30303,
          id: "a869b02cec167211fb4815a82941db2e7ed2936fd90e78619c53eb17753fcf0207463e3419c264e2a1dd8786de0df7e68cf99571ab8aeb7c4e51367ef186b1dd",
          location: "",
          comment: "Goerli Initiative bootnode"
        },
        {
          ip: "51.15.119.157",
          port: 30303,
          id: "807b37ee4816ecf407e9112224494b74dd5933625f655962d892f2f0f02d7fbbb3e2a94cf87a96609526f30c998fd71e93e2f53015c558ffc8b03eceaf30ee33",
          location: "",
          comment: "Goerli Initiative bootnode"
        },
        {
          ip: "51.15.119.157",
          port: 40303,
          id: "a59e33ccd2b3e52d578f1fbd70c6f9babda2650f0760d6ff3b37742fdcdfdb3defba5d56d315b40c46b70198c7621e63ffa3f987389c7118634b0fefbbdfa7fd",
          location: "",
          comment: "Goerli Initiative bootnode"
        }
      ],
      dnsNetworks: [
        "enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.goerli.ethdisco.net"
      ]
    },
    sepolia: {
      name: "sepolia",
      chainId: 11155111,
      networkId: 11155111,
      defaultHardfork: "shanghai",
      consensus: {
        type: "pow",
        algorithm: "ethash",
        ethash: {}
      },
      comment: "PoW test network to replace Ropsten",
      url: "https://github.com/ethereum/go-ethereum/pull/23730",
      genesis: {
        timestamp: "0x6159af19",
        gasLimit: 3e7,
        difficulty: 131072,
        nonce: "0x0000000000000000",
        extraData: "0x5365706f6c69612c20417468656e732c204174746963612c2047726565636521"
      },
      hardforks: [
        {
          name: "chainstart",
          block: 0,
          forkHash: "0xfe3366e7"
        },
        {
          name: "homestead",
          block: 0,
          forkHash: "0xfe3366e7"
        },
        {
          name: "tangerineWhistle",
          block: 0,
          forkHash: "0xfe3366e7"
        },
        {
          name: "spuriousDragon",
          block: 0,
          forkHash: "0xfe3366e7"
        },
        {
          name: "byzantium",
          block: 0,
          forkHash: "0xfe3366e7"
        },
        {
          name: "constantinople",
          block: 0,
          forkHash: "0xfe3366e7"
        },
        {
          name: "petersburg",
          block: 0,
          forkHash: "0xfe3366e7"
        },
        {
          name: "istanbul",
          block: 0,
          forkHash: "0xfe3366e7"
        },
        {
          name: "muirGlacier",
          block: 0,
          forkHash: "0xfe3366e7"
        },
        {
          name: "berlin",
          block: 0,
          forkHash: "0xfe3366e7"
        },
        {
          name: "london",
          block: 0,
          forkHash: "0xfe3366e7"
        },
        {
          // The forkHash will remain same as mergeForkIdTransition is post merge,
          // terminal block: https://sepolia.etherscan.io/block/1450408
          name: "paris",
          ttd: "17000000000000000",
          block: 1450409,
          forkHash: "0xfe3366e7"
        },
        {
          name: "mergeForkIdTransition",
          block: 1735371,
          forkHash: "0xb96cbd13"
        },
        {
          name: "shanghai",
          block: null,
          timestamp: "1677557088",
          forkHash: "0xf7f9bc08"
        },
        {
          name: "cancun",
          block: null,
          timestamp: "1706655072",
          forkHash: "0x88cf81d9"
        }
      ],
      bootstrapNodes: [
        {
          ip: "18.168.182.86",
          port: 30303,
          id: "9246d00bc8fd1742e5ad2428b80fc4dc45d786283e05ef6edbd9002cbc335d40998444732fbe921cb88e1d2c73d1b1de53bae6a2237996e9bfe14f871baf7066",
          location: "",
          comment: "geth"
        },
        {
          ip: "52.14.151.177",
          port: 30303,
          id: "ec66ddcf1a974950bd4c782789a7e04f8aa7110a72569b6e65fcd51e937e74eed303b1ea734e4d19cfaec9fbff9b6ee65bf31dcb50ba79acce9dd63a6aca61c7",
          location: "",
          comment: "besu"
        },
        {
          ip: "165.22.196.173",
          port: 30303,
          id: "ce970ad2e9daa9e14593de84a8b49da3d54ccfdf83cbc4fe519cb8b36b5918ed4eab087dedd4a62479b8d50756b492d5f762367c8d20329a7854ec01547568a6",
          location: "",
          comment: "EF"
        },
        {
          ip: "65.108.95.67",
          port: 30303,
          id: "075503b13ed736244896efcde2a992ec0b451357d46cb7a8132c0384721742597fc8f0d91bbb40bb52e7d6e66728d36a1fda09176294e4a30cfac55dcce26bc6",
          location: "",
          comment: "lodestar"
        }
      ],
      dnsNetworks: [
        "enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.sepolia.ethdisco.net"
      ]
    },
    holesky: {
      name: "holesky",
      chainId: 17e3,
      networkId: 17e3,
      defaultHardfork: "paris",
      consensus: {
        type: "pos",
        algorithm: "casper"
      },
      comment: "PoS test network to replace Goerli",
      url: "https://github.com/eth-clients/holesky/",
      genesis: {
        baseFeePerGas: "0x3B9ACA00",
        difficulty: "0x01",
        extraData: "0x",
        gasLimit: "0x17D7840",
        nonce: "0x0000000000001234",
        timestamp: "0x65156994"
      },
      hardforks: [
        {
          name: "chainstart",
          block: 0,
          forkHash: "0xc61a6098"
        },
        {
          name: "homestead",
          block: 0,
          forkHash: "0xc61a6098"
        },
        {
          name: "tangerineWhistle",
          block: 0,
          forkHash: "0xc61a6098"
        },
        {
          name: "spuriousDragon",
          block: 0,
          forkHash: "0xc61a6098"
        },
        {
          name: "byzantium",
          block: 0,
          forkHash: "0xc61a6098"
        },
        {
          name: "constantinople",
          block: 0,
          forkHash: "0xc61a6098"
        },
        {
          name: "petersburg",
          block: 0,
          forkHash: "0xc61a6098"
        },
        {
          name: "istanbul",
          block: 0,
          forkHash: "0xc61a6098"
        },
        {
          name: "muirGlacier",
          block: 0,
          forkHash: "0xc61a6098"
        },
        {
          name: "berlin",
          block: 0,
          forkHash: "0xc61a6098"
        },
        {
          name: "london",
          block: 0,
          forkHash: "0xc61a6098"
        },
        {
          name: "paris",
          ttd: "0",
          block: 0,
          forkHash: "0xc61a6098"
        },
        {
          name: "mergeForkIdTransition",
          block: 0,
          forkHash: "0xc61a6098"
        },
        {
          name: "shanghai",
          block: null,
          timestamp: "1696000704",
          forkHash: "0xfd4f016b"
        },
        {
          name: "cancun",
          block: null,
          timestamp: "1707305664",
          forkHash: "0x9b192ad0"
        }
      ],
      bootstrapNodes: [
        {
          ip: "146.190.13.128",
          port: 30303,
          id: "ac906289e4b7f12df423d654c5a962b6ebe5b3a74cc9e06292a85221f9a64a6f1cfdd6b714ed6dacef51578f92b34c60ee91e9ede9c7f8fadc4d347326d95e2b",
          location: "",
          comment: "bootnode 1"
        },
        {
          ip: "178.128.136.233",
          port: 30303,
          id: "a3435a0155a3e837c02f5e7f5662a2f1fbc25b48e4dc232016e1c51b544cb5b4510ef633ea3278c0e970fa8ad8141e2d4d0f9f95456c537ff05fdf9b31c15072",
          location: "",
          comment: "bootnode 2"
        }
      ],
      dnsNetworks: [
        "enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.holesky.ethdisco.net"
      ]
    },
    kaustinen6: {
      name: "kaustinen6",
      chainId: 69420,
      networkId: 69420,
      defaultHardfork: "osaka",
      consensus: {
        type: "pos",
        algorithm: "casper"
      },
      comment: "Verkle kaustinen testnet 6 (likely temporary, do not hard-wire into production code)",
      url: "https://github.com/eth-clients/kaustinen/",
      genesis: {
        difficulty: "0x01",
        extraData: "0x",
        gasLimit: "0x17D7840",
        nonce: "0x0000000000001234",
        timestamp: "0x66190fbc"
      },
      hardforks: [
        {
          name: "chainstart",
          block: 0
        },
        {
          name: "homestead",
          block: 0
        },
        {
          name: "tangerineWhistle",
          block: 0
        },
        {
          name: "spuriousDragon",
          block: 0
        },
        {
          name: "byzantium",
          block: 0
        },
        {
          name: "constantinople",
          block: 0
        },
        {
          name: "petersburg",
          block: 0
        },
        {
          name: "istanbul",
          block: 0
        },
        {
          name: "berlin",
          block: 0
        },
        {
          name: "london",
          block: 0
        },
        {
          name: "paris",
          ttd: "0",
          block: 0
        },
        {
          name: "mergeForkIdTransition",
          block: 0
        },
        {
          name: "shanghai",
          block: null,
          timestamp: "0"
        },
        {
          name: "osaka",
          block: null,
          timestamp: "1712848500"
        }
      ],
      bootstrapNodes: [],
      dnsNetworks: []
    }
  };

  // node_modules/@ethereumjs/common/dist/esm/crc.js
  var TABLE = [
    0,
    1996959894,
    3993919788,
    2567524794,
    124634137,
    1886057615,
    3915621685,
    2657392035,
    249268274,
    2044508324,
    3772115230,
    2547177864,
    162941995,
    2125561021,
    3887607047,
    2428444049,
    498536548,
    1789927666,
    4089016648,
    2227061214,
    450548861,
    1843258603,
    4107580753,
    2211677639,
    325883990,
    1684777152,
    4251122042,
    2321926636,
    335633487,
    1661365465,
    4195302755,
    2366115317,
    997073096,
    1281953886,
    3579855332,
    2724688242,
    1006888145,
    1258607687,
    3524101629,
    2768942443,
    901097722,
    1119000684,
    3686517206,
    2898065728,
    853044451,
    1172266101,
    3705015759,
    2882616665,
    651767980,
    1373503546,
    3369554304,
    3218104598,
    565507253,
    1454621731,
    3485111705,
    3099436303,
    671266974,
    1594198024,
    3322730930,
    2970347812,
    795835527,
    1483230225,
    3244367275,
    3060149565,
    1994146192,
    31158534,
    2563907772,
    4023717930,
    1907459465,
    112637215,
    2680153253,
    3904427059,
    2013776290,
    251722036,
    2517215374,
    3775830040,
    2137656763,
    141376813,
    2439277719,
    3865271297,
    1802195444,
    476864866,
    2238001368,
    4066508878,
    1812370925,
    453092731,
    2181625025,
    4111451223,
    1706088902,
    314042704,
    2344532202,
    4240017532,
    1658658271,
    366619977,
    2362670323,
    4224994405,
    1303535960,
    984961486,
    2747007092,
    3569037538,
    1256170817,
    1037604311,
    2765210733,
    3554079995,
    1131014506,
    879679996,
    2909243462,
    3663771856,
    1141124467,
    855842277,
    2852801631,
    3708648649,
    1342533948,
    654459306,
    3188396048,
    3373015174,
    1466479909,
    544179635,
    3110523913,
    3462522015,
    1591671054,
    702138776,
    2966460450,
    3352799412,
    1504918807,
    783551873,
    3082640443,
    3233442989,
    3988292384,
    2596254646,
    62317068,
    1957810842,
    3939845945,
    2647816111,
    81470997,
    1943803523,
    3814918930,
    2489596804,
    225274430,
    2053790376,
    3826175755,
    2466906013,
    167816743,
    2097651377,
    4027552580,
    2265490386,
    503444072,
    1762050814,
    4150417245,
    2154129355,
    426522225,
    1852507879,
    4275313526,
    2312317920,
    282753626,
    1742555852,
    4189708143,
    2394877945,
    397917763,
    1622183637,
    3604390888,
    2714866558,
    953729732,
    1340076626,
    3518719985,
    2797360999,
    1068828381,
    1219638859,
    3624741850,
    2936675148,
    906185462,
    1090812512,
    3747672003,
    2825379669,
    829329135,
    1181335161,
    3412177804,
    3160834842,
    628085408,
    1382605366,
    3423369109,
    3138078467,
    570562233,
    1426400815,
    3317316542,
    2998733608,
    733239954,
    1555261956,
    3268935591,
    3050360625,
    752459403,
    1541320221,
    2607071920,
    3965973030,
    1969922972,
    40735498,
    2617837225,
    3943577151,
    1913087877,
    83908371,
    2512341634,
    3803740692,
    2075208622,
    213261112,
    2463272603,
    3855990285,
    2094854071,
    198958881,
    2262029012,
    4057260610,
    1759359992,
    534414190,
    2176718541,
    4139329115,
    1873836001,
    414664567,
    2282248934,
    4279200368,
    1711684554,
    285281116,
    2405801727,
    4167216745,
    1634467795,
    376229701,
    2685067896,
    3608007406,
    1308918612,
    956543938,
    2808555105,
    3495958263,
    1231636301,
    1047427035,
    2932959818,
    3654703836,
    1088359270,
    936918e3,
    2847714899,
    3736837829,
    1202900863,
    817233897,
    3183342108,
    3401237130,
    1404277552,
    615818150,
    3134207493,
    3453421203,
    1423857449,
    601450431,
    3009837614,
    3294710456,
    1567103746,
    711928724,
    3020668471,
    3272380065,
    1510334235,
    755167117
  ];
  if (typeof Int32Array !== "undefined") {
    TABLE = new Int32Array(TABLE);
  }
  var crc = (current, previous) => {
    let crc2 = previous === 0 ? 0 : ~~previous ^ -1;
    for (let index = 0; index < current.length; index++) {
      crc2 = TABLE[(crc2 ^ current[index]) & 255] ^ crc2 >>> 8;
    }
    return crc2 ^ -1;
  };
  var crc32 = (current, previous) => {
    return crc(current, previous) >>> 0;
  };

  // node_modules/@ethereumjs/common/dist/esm/enums.js
  var Chain;
  (function(Chain2) {
    Chain2[Chain2["Mainnet"] = 1] = "Mainnet";
    Chain2[Chain2["Goerli"] = 5] = "Goerli";
    Chain2[Chain2["Sepolia"] = 11155111] = "Sepolia";
    Chain2[Chain2["Holesky"] = 17e3] = "Holesky";
    Chain2[Chain2["Kaustinen6"] = 69420] = "Kaustinen6";
  })(Chain || (Chain = {}));
  var ChainGenesis = {
    [Chain.Mainnet]: {
      name: "mainnet",
      blockNumber: BIGINT_02,
      stateRoot: hexToBytes6("0xd7f8974fb5ac78d9ac099b9ad5018bedc2ce0a72dad1827a1709da30580f0544")
    },
    [Chain.Goerli]: {
      name: "goerli",
      blockNumber: BIGINT_02,
      stateRoot: hexToBytes6("0x5d6cded585e73c4e322c30c2f782a336316f17dd85a4863b9d838d2d4b8b3008")
    },
    [Chain.Sepolia]: {
      name: "sepolia",
      blockNumber: BIGINT_02,
      stateRoot: hexToBytes6("0x5eb6e371a698b8d68f665192350ffcecbbbf322916f4b51bd79bb6887da3f494")
    },
    [Chain.Holesky]: {
      name: "holesky",
      blockNumber: BIGINT_02,
      stateRoot: hexToBytes6("0x69d8c9d72f6fa4ad42d4702b433707212f90db395eb54dc20bc85de253788783")
    },
    [Chain.Kaustinen6]: {
      name: "kaustinen6",
      blockNumber: BIGINT_02,
      stateRoot: hexToBytes6("0x1fbf85345a3cbba9a6d44f991b721e55620a22397c2a93ee8d5011136ac300ee")
    }
  };
  var Hardfork;
  (function(Hardfork2) {
    Hardfork2["Chainstart"] = "chainstart";
    Hardfork2["Homestead"] = "homestead";
    Hardfork2["Dao"] = "dao";
    Hardfork2["TangerineWhistle"] = "tangerineWhistle";
    Hardfork2["SpuriousDragon"] = "spuriousDragon";
    Hardfork2["Byzantium"] = "byzantium";
    Hardfork2["Constantinople"] = "constantinople";
    Hardfork2["Petersburg"] = "petersburg";
    Hardfork2["Istanbul"] = "istanbul";
    Hardfork2["MuirGlacier"] = "muirGlacier";
    Hardfork2["Berlin"] = "berlin";
    Hardfork2["London"] = "london";
    Hardfork2["ArrowGlacier"] = "arrowGlacier";
    Hardfork2["GrayGlacier"] = "grayGlacier";
    Hardfork2["MergeForkIdTransition"] = "mergeForkIdTransition";
    Hardfork2["Paris"] = "paris";
    Hardfork2["Shanghai"] = "shanghai";
    Hardfork2["Cancun"] = "cancun";
    Hardfork2["Prague"] = "prague";
    Hardfork2["Osaka"] = "osaka";
  })(Hardfork || (Hardfork = {}));
  var ConsensusType;
  (function(ConsensusType2) {
    ConsensusType2["ProofOfStake"] = "pos";
    ConsensusType2["ProofOfWork"] = "pow";
    ConsensusType2["ProofOfAuthority"] = "poa";
  })(ConsensusType || (ConsensusType = {}));
  var ConsensusAlgorithm;
  (function(ConsensusAlgorithm2) {
    ConsensusAlgorithm2["Ethash"] = "ethash";
    ConsensusAlgorithm2["Clique"] = "clique";
    ConsensusAlgorithm2["Casper"] = "casper";
  })(ConsensusAlgorithm || (ConsensusAlgorithm = {}));
  var CustomChain;
  (function(CustomChain2) {
    CustomChain2["PolygonMainnet"] = "polygon-mainnet";
    CustomChain2["PolygonMumbai"] = "polygon-mumbai";
    CustomChain2["ArbitrumOne"] = "arbitrum-one";
    CustomChain2["xDaiChain"] = "x-dai-chain";
    CustomChain2["OptimisticKovan"] = "optimistic-kovan";
    CustomChain2["OptimisticEthereum"] = "optimistic-ethereum";
  })(CustomChain || (CustomChain = {}));

  // node_modules/@ethereumjs/common/dist/esm/eips.js
  var Status;
  (function(Status3) {
    Status3["Stagnant"] = "stagnant";
    Status3["Draft"] = "draft";
    Status3["Review"] = "review";
    Status3["Final"] = "final";
  })(Status || (Status = {}));
  var EIPs = {
    1153: {
      comment: "Transient storage opcodes",
      url: "https://eips.ethereum.org/EIPS/eip-1153",
      status: Status.Review,
      minimumHardfork: Hardfork.Chainstart,
      requiredEIPs: [],
      gasPrices: {
        tstore: {
          v: 100,
          d: "Base fee of the TSTORE opcode"
        },
        tload: {
          v: 100,
          d: "Base fee of the TLOAD opcode"
        }
      }
    },
    1559: {
      comment: "Fee market change for ETH 1.0 chain",
      url: "https://eips.ethereum.org/EIPS/eip-1559",
      status: Status.Final,
      minimumHardfork: Hardfork.Berlin,
      requiredEIPs: [2930],
      gasConfig: {
        baseFeeMaxChangeDenominator: {
          v: 8,
          d: "Maximum base fee change denominator"
        },
        elasticityMultiplier: {
          v: 2,
          d: "Maximum block gas target elasticity"
        },
        initialBaseFee: {
          v: 1e9,
          d: "Initial base fee on first EIP1559 block"
        }
      }
    },
    2565: {
      comment: "ModExp gas cost",
      url: "https://eips.ethereum.org/EIPS/eip-2565",
      status: Status.Final,
      minimumHardfork: Hardfork.Byzantium,
      requiredEIPs: [],
      gasPrices: {
        modexpGquaddivisor: {
          v: 3,
          d: "Gquaddivisor from modexp precompile for gas calculation"
        }
      }
    },
    2537: {
      comment: "BLS12-381 precompiles",
      url: "https://eips.ethereum.org/EIPS/eip-2537",
      status: "Draft",
      minimumHardfork: Hardfork.Chainstart,
      requiredEIPs: [],
      gasConfig: {},
      gasPrices: {
        Bls12381G1AddGas: {
          v: 500,
          d: "Gas cost of a single BLS12-381 G1 addition precompile-call"
        },
        Bls12381G1MulGas: {
          v: 12e3,
          d: "Gas cost of a single BLS12-381 G1 multiplication precompile-call"
        },
        Bls12381G2AddGas: {
          v: 800,
          d: "Gas cost of a single BLS12-381 G2 addition precompile-call"
        },
        Bls12381G2MulGas: {
          v: 45e3,
          d: "Gas cost of a single BLS12-381 G2 multiplication precompile-call"
        },
        Bls12381PairingBaseGas: {
          v: 65e3,
          d: "Base gas cost of BLS12-381 pairing check"
        },
        Bls12381PairingPerPairGas: {
          v: 43e3,
          d: "Per-pair gas cost of BLS12-381 pairing check"
        },
        Bls12381MapG1Gas: {
          v: 5500,
          d: "Gas cost of BLS12-381 map field element to G1"
        },
        Bls12381MapG2Gas: {
          v: 75e3,
          d: "Gas cost of BLS12-381 map field element to G2"
        }
      },
      vm: {},
      pow: {}
    },
    2718: {
      comment: "Typed Transaction Envelope",
      url: "https://eips.ethereum.org/EIPS/eip-2718",
      status: Status.Final,
      minimumHardfork: Hardfork.Chainstart,
      requiredEIPs: []
    },
    2929: {
      comment: "Gas cost increases for state access opcodes",
      url: "https://eips.ethereum.org/EIPS/eip-2929",
      status: Status.Final,
      minimumHardfork: Hardfork.Chainstart,
      requiredEIPs: [],
      gasPrices: {
        coldsload: {
          v: 2100,
          d: "Gas cost of the first read of storage from a given location (per transaction)"
        },
        coldaccountaccess: {
          v: 2600,
          d: "Gas cost of the first read of a given address (per transaction)"
        },
        warmstorageread: {
          v: 100,
          d: "Gas cost of reading storage locations which have already loaded 'cold'"
        },
        sstoreCleanGasEIP2200: {
          v: 2900,
          d: "Once per SSTORE operation from clean non-zero to something else"
        },
        sstoreNoopGasEIP2200: {
          v: 100,
          d: "Once per SSTORE operation if the value doesn't change"
        },
        sstoreDirtyGasEIP2200: {
          v: 100,
          d: "Once per SSTORE operation if a dirty value is changed"
        },
        sstoreInitRefundEIP2200: {
          v: 19900,
          d: "Once per SSTORE operation for resetting to the original zero value"
        },
        sstoreCleanRefundEIP2200: {
          v: 4900,
          d: "Once per SSTORE operation for resetting to the original non-zero value"
        },
        call: {
          v: 0,
          d: "Base fee of the CALL opcode"
        },
        callcode: {
          v: 0,
          d: "Base fee of the CALLCODE opcode"
        },
        delegatecall: {
          v: 0,
          d: "Base fee of the DELEGATECALL opcode"
        },
        staticcall: {
          v: 0,
          d: "Base fee of the STATICCALL opcode"
        },
        balance: {
          v: 0,
          d: "Base fee of the BALANCE opcode"
        },
        extcodesize: {
          v: 0,
          d: "Base fee of the EXTCODESIZE opcode"
        },
        extcodecopy: {
          v: 0,
          d: "Base fee of the EXTCODECOPY opcode"
        },
        extcodehash: {
          v: 0,
          d: "Base fee of the EXTCODEHASH opcode"
        },
        sload: {
          v: 0,
          d: "Base fee of the SLOAD opcode"
        },
        sstore: {
          v: 0,
          d: "Base fee of the SSTORE opcode"
        }
      }
    },
    2930: {
      comment: "Optional access lists",
      url: "https://eips.ethereum.org/EIPS/eip-2930",
      status: Status.Final,
      minimumHardfork: Hardfork.Istanbul,
      requiredEIPs: [2718, 2929],
      gasPrices: {
        accessListStorageKeyCost: {
          v: 1900,
          d: "Gas cost per storage key in an Access List transaction"
        },
        accessListAddressCost: {
          v: 2400,
          d: "Gas cost per storage key in an Access List transaction"
        }
      }
    },
    2935: {
      comment: "Save historical block hashes in state (Verkle related usage, UNSTABLE)",
      url: "https://github.com/gballet/EIPs/pull/3/commits/2e9ac09a142b0d9fb4db0b8d4609f92e5d9990c5",
      status: Status.Draft,
      minimumHardfork: Hardfork.Chainstart,
      requiredEIPs: [],
      vm: {
        historyStorageAddress: {
          v: BigInt("0x0aae40965e6800cd9b1f4b05ff21581047e3f91e"),
          d: "The address where the historical blockhashes are stored"
        },
        historyServeWindow: {
          v: BigInt(8192),
          d: "The amount of blocks to be served by the historical blockhash contract"
        }
      }
    },
    3074: {
      comment: "AUTH and AUTHCALL opcodes",
      url: "https://github.com/ethereum/EIPs/commit/eca4416ff3c025fcb6ec8cd4eac481e74e108481",
      status: Status.Review,
      minimumHardfork: Hardfork.London,
      requiredEIPs: [],
      gasPrices: {
        auth: {
          v: 3100,
          d: "Gas cost of the AUTH opcode"
        },
        authcall: {
          v: 0,
          d: "Gas cost of the AUTHCALL opcode"
        },
        authcallValueTransfer: {
          v: 6700,
          d: "Paid for CALL when the value transfer is non-zero"
        }
      }
    },
    3198: {
      comment: "BASEFEE opcode",
      url: "https://eips.ethereum.org/EIPS/eip-3198",
      status: Status.Final,
      minimumHardfork: Hardfork.London,
      requiredEIPs: [],
      gasPrices: {
        basefee: {
          v: 2,
          d: "Gas cost of the BASEFEE opcode"
        }
      }
    },
    3529: {
      comment: "Reduction in refunds",
      url: "https://eips.ethereum.org/EIPS/eip-3529",
      status: Status.Final,
      minimumHardfork: Hardfork.Berlin,
      requiredEIPs: [2929],
      gasConfig: {
        maxRefundQuotient: {
          v: 5,
          d: "Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)"
        }
      },
      gasPrices: {
        selfdestructRefund: {
          v: 0,
          d: "Refunded following a selfdestruct operation"
        },
        sstoreClearRefundEIP2200: {
          v: 4800,
          d: "Once per SSTORE operation for clearing an originally existing storage slot"
        }
      }
    },
    3540: {
      comment: "EVM Object Format (EOF) v1",
      url: "https://eips.ethereum.org/EIPS/eip-3540",
      status: Status.Review,
      minimumHardfork: Hardfork.London,
      requiredEIPs: [3541]
    },
    3541: {
      comment: "Reject new contracts starting with the 0xEF byte",
      url: "https://eips.ethereum.org/EIPS/eip-3541",
      status: Status.Final,
      minimumHardfork: Hardfork.Berlin,
      requiredEIPs: []
    },
    3554: {
      comment: "Difficulty Bomb Delay to December 1st 2021",
      url: "https://eips.ethereum.org/EIPS/eip-3554",
      status: Status.Final,
      minimumHardfork: Hardfork.MuirGlacier,
      requiredEIPs: [],
      pow: {
        difficultyBombDelay: {
          v: 95e5,
          d: "the amount of blocks to delay the difficulty bomb with"
        }
      }
    },
    3607: {
      comment: "Reject transactions from senders with deployed code",
      url: "https://eips.ethereum.org/EIPS/eip-3607",
      status: Status.Final,
      minimumHardfork: Hardfork.Chainstart,
      requiredEIPs: []
    },
    3651: {
      comment: "Warm COINBASE",
      url: "https://eips.ethereum.org/EIPS/eip-3651",
      status: Status.Review,
      minimumHardfork: Hardfork.London,
      requiredEIPs: [2929]
    },
    3670: {
      comment: "EOF - Code Validation",
      url: "https://eips.ethereum.org/EIPS/eip-3670",
      status: "Review",
      minimumHardfork: Hardfork.London,
      requiredEIPs: [3540],
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {}
    },
    3675: {
      comment: "Upgrade consensus to Proof-of-Stake",
      url: "https://eips.ethereum.org/EIPS/eip-3675",
      status: Status.Final,
      minimumHardfork: Hardfork.London,
      requiredEIPs: []
    },
    3855: {
      comment: "PUSH0 instruction",
      url: "https://eips.ethereum.org/EIPS/eip-3855",
      status: Status.Review,
      minimumHardfork: Hardfork.Chainstart,
      requiredEIPs: [],
      gasPrices: {
        push0: {
          v: 2,
          d: "Base fee of the PUSH0 opcode"
        }
      }
    },
    3860: {
      comment: "Limit and meter initcode",
      url: "https://eips.ethereum.org/EIPS/eip-3860",
      status: Status.Review,
      minimumHardfork: Hardfork.SpuriousDragon,
      requiredEIPs: [],
      gasPrices: {
        initCodeWordCost: {
          v: 2,
          d: "Gas to pay for each word (32 bytes) of initcode when creating a contract"
        }
      },
      vm: {
        maxInitCodeSize: {
          v: 49152,
          d: "Maximum length of initialization code when creating a contract"
        }
      }
    },
    4345: {
      comment: "Difficulty Bomb Delay to June 2022",
      url: "https://eips.ethereum.org/EIPS/eip-4345",
      status: Status.Final,
      minimumHardfork: Hardfork.London,
      requiredEIPs: [],
      pow: {
        difficultyBombDelay: {
          v: 107e5,
          d: "the amount of blocks to delay the difficulty bomb with"
        }
      }
    },
    4399: {
      comment: "Supplant DIFFICULTY opcode with PREVRANDAO",
      url: "https://eips.ethereum.org/EIPS/eip-4399",
      status: Status.Review,
      minimumHardfork: Hardfork.London,
      requiredEIPs: [],
      gasPrices: {
        prevrandao: {
          v: 2,
          d: "Base fee of the PREVRANDAO opcode (previously DIFFICULTY)"
        }
      }
    },
    4788: {
      comment: "Beacon block root in the EVM",
      url: "https://eips.ethereum.org/EIPS/eip-4788",
      status: Status.Draft,
      minimumHardfork: Hardfork.Cancun,
      requiredEIPs: [],
      gasPrices: {},
      vm: {
        historicalRootsLength: {
          v: 8191,
          d: "The modulo parameter of the beaconroot ring buffer in the beaconroot statefull precompile"
        }
      }
    },
    4844: {
      comment: "Shard Blob Transactions",
      url: "https://eips.ethereum.org/EIPS/eip-4844",
      status: Status.Draft,
      minimumHardfork: Hardfork.Paris,
      requiredEIPs: [1559, 2718, 2930, 4895],
      gasConfig: {
        blobGasPerBlob: {
          v: 131072,
          d: "The base fee for blob gas per blob"
        },
        targetBlobGasPerBlock: {
          v: 393216,
          d: "The target blob gas consumed per block"
        },
        maxblobGasPerBlock: {
          v: 786432,
          d: "The max blob gas allowable per block"
        },
        blobGasPriceUpdateFraction: {
          v: 3338477,
          d: "The denominator used in the exponential when calculating a blob gas price"
        }
      },
      gasPrices: {
        simpleGasPerBlob: {
          v: 12e3,
          d: "The basic gas fee for each blob"
        },
        minBlobGasPrice: {
          v: 1,
          d: "The minimum fee per blob gas"
        },
        kzgPointEvaluationGasPrecompilePrice: {
          v: 5e4,
          d: "The fee associated with the point evaluation precompile"
        },
        blobhash: {
          v: 3,
          d: "Base fee of the BLOBHASH opcode"
        }
      },
      sharding: {
        blobCommitmentVersionKzg: {
          v: 1,
          d: "The number indicated a versioned hash is a KZG commitment"
        },
        fieldElementsPerBlob: {
          v: 4096,
          d: "The number of field elements allowed per blob"
        }
      }
    },
    4895: {
      comment: "Beacon chain push withdrawals as operations",
      url: "https://eips.ethereum.org/EIPS/eip-4895",
      status: Status.Review,
      minimumHardfork: Hardfork.Paris,
      requiredEIPs: []
    },
    5133: {
      comment: "Delaying Difficulty Bomb to mid-September 2022",
      url: "https://eips.ethereum.org/EIPS/eip-5133",
      status: Status.Draft,
      minimumHardfork: Hardfork.GrayGlacier,
      requiredEIPs: [],
      pow: {
        difficultyBombDelay: {
          v: 114e5,
          d: "the amount of blocks to delay the difficulty bomb with"
        }
      }
    },
    5656: {
      comment: "MCOPY - Memory copying instruction",
      url: "https://eips.ethereum.org/EIPS/eip-5656",
      status: Status.Draft,
      minimumHardfork: Hardfork.Shanghai,
      requiredEIPs: [],
      gasPrices: {
        mcopy: {
          v: 3,
          d: "Base fee of the MCOPY opcode"
        }
      }
    },
    6110: {
      comment: "Supply validator deposits on chain",
      url: "https://eips.ethereum.org/EIPS/eip-6110",
      status: Status.Draft,
      minimumHardfork: Hardfork.Cancun,
      requiredEIPs: [7685]
    },
    6780: {
      comment: "SELFDESTRUCT only in same transaction",
      url: "https://eips.ethereum.org/EIPS/eip-6780",
      status: Status.Draft,
      minimumHardfork: Hardfork.London,
      requiredEIPs: []
    },
    6800: {
      comment: "Ethereum state using a unified verkle tree (experimental)",
      url: "https://github.com/ethereum/EIPs/pull/6800",
      status: Status.Draft,
      minimumHardfork: Hardfork.London,
      requiredEIPs: [],
      gasPrices: {
        create: {
          v: 1e3,
          d: "Base fee of the CREATE opcode"
        },
        coldsload: {
          v: 0,
          d: "Gas cost of the first read of storage from a given location (per transaction)"
        }
      },
      vm: {
        // kaustinen 6 current uses this address, however this will be updated to correct address
        // in next iteration
        historyStorageAddress: {
          v: BigInt("0xfffffffffffffffffffffffffffffffffffffffe"),
          d: "The address where the historical blockhashes are stored"
        }
      }
    },
    7002: {
      comment: "Execution layer triggerable withdrawals (experimental)",
      url: "https://github.com/ethereum/EIPs/blob/3b5fcad6b35782f8aaeba7d4ac26004e8fbd720f/EIPS/eip-7002.md",
      status: Status.Draft,
      minimumHardfork: Hardfork.Paris,
      requiredEIPs: [7685],
      vm: {
        withdrawalRequestType: {
          v: BigInt(1),
          d: "The withdrawal request type for EIP-7685"
        },
        excessWithdrawalsRequestStorageSlot: {
          v: BigInt(0),
          d: "The storage slot of the excess withdrawals"
        },
        withdrawalsRequestCountStorage: {
          v: BigInt(1),
          d: "The storage slot of the withdrawal request count"
        },
        withdrawalsRequestQueueHeadStorageSlot: {
          v: BigInt(2),
          d: "The storage slot of the withdrawal request head of the queue"
        },
        withdrawalsRequestTailHeadStorageSlot: {
          v: BigInt(3),
          d: "The storage slot of the withdrawal request tail of the queue"
        },
        withdrawalsRequestQueueStorageOffset: {
          v: BigInt(4),
          d: "The storage slot of the withdrawal request queue offset"
        },
        maxWithdrawalRequestsPerBlock: {
          v: BigInt(16),
          d: "The max withdrawal requests per block"
        },
        targetWithdrawalRequestsPerBlock: {
          v: BigInt(2),
          d: "The target withdrawal requests per block"
        },
        minWithdrawalRequestFee: {
          v: BigInt(1),
          d: "The minimum withdrawal request fee (in wei)"
        },
        withdrawalRequestFeeUpdateFraction: {
          v: BigInt(17),
          d: "The withdrawal request fee update fraction (used in the fake exponential)"
        },
        systemAddress: {
          v: BigInt("0xfffffffffffffffffffffffffffffffffffffffe"),
          d: "The system address to perform operations on the withdrawal requests predeploy address"
        },
        withdrawalRequestPredeployAddress: {
          v: BigInt("0x00A3ca265EBcb825B45F985A16CEFB49958cE017"),
          d: "Address of the validator excess address"
        }
      }
    },
    7251: {
      comment: "Execution layer triggered consolidations (experimental)",
      url: "https://eips.ethereum.org/EIPS/eip-7251",
      status: Status.Draft,
      minimumHardfork: Hardfork.Paris,
      requiredEIPs: [7685],
      vm: {
        consolidationRequestType: {
          v: BigInt(2),
          d: "The withdrawal request type for EIP-7685"
        },
        systemAddress: {
          v: BigInt("0xfffffffffffffffffffffffffffffffffffffffe"),
          d: "The system address to perform operations on the consolidation requests predeploy address"
        },
        consolidationRequestPredeployAddress: {
          v: BigInt("0x00b42dbF2194e931E80326D950320f7d9Dbeac02"),
          d: "Address of the consolidations contract"
        }
      }
    },
    7516: {
      comment: "BLOBBASEFEE opcode",
      url: "https://eips.ethereum.org/EIPS/eip-7516",
      status: Status.Draft,
      minimumHardfork: Hardfork.Paris,
      requiredEIPs: [4844],
      gasPrices: {
        blobbasefee: {
          v: 2,
          d: "Gas cost of the BLOBBASEFEE opcode"
        }
      }
    },
    7685: {
      comment: "General purpose execution layer requests",
      url: "https://eips.ethereum.org/EIPS/eip-7685",
      status: Status.Draft,
      // TODO: Set correct minimum hardfork
      minimumHardfork: Hardfork.Cancun,
      requiredEIPs: [3675],
      gasPrices: {}
    },
    7702: {
      comment: "Set EOA account code for one transaction",
      url: "https://github.com/ethereum/EIPs/blob/62419ca3f45375db00b04a368ea37c0bfb05386a/EIPS/eip-7702.md",
      status: Status.Review,
      // TODO: Set correct minimum hardfork
      minimumHardfork: Hardfork.Cancun,
      requiredEIPs: [2718, 2929, 2930],
      gasPrices: {
        perAuthBaseCost: {
          v: 2500,
          d: "Gas cost of each authority item"
        }
      }
    },
    7709: {
      comment: "Use historical block hashes saved in state for BLOCKHASH",
      url: "https://eips.ethereum.org/EIPS/eip-7709",
      status: Status.Draft,
      minimumHardfork: Hardfork.Chainstart,
      requiredEIPs: [2935]
    }
  };

  // node_modules/@ethereumjs/common/dist/esm/hardforks.js
  var Status2;
  (function(Status3) {
    Status3["Draft"] = "draft";
    Status3["Review"] = "review";
    Status3["Final"] = "final";
  })(Status2 || (Status2 = {}));
  var hardforks = {
    chainstart: {
      name: "chainstart",
      comment: "Start of the Ethereum main chain",
      url: "",
      status: Status2.Final,
      gasConfig: {
        minGasLimit: {
          v: 5e3,
          d: "Minimum the gas limit may ever be"
        },
        gasLimitBoundDivisor: {
          v: 1024,
          d: "The bound divisor of the gas limit, used in update calculations"
        },
        maxRefundQuotient: {
          v: 2,
          d: "Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)"
        }
      },
      gasPrices: {
        base: {
          v: 2,
          d: "Gas base cost, used e.g. for ChainID opcode (Istanbul)"
        },
        exp: {
          v: 10,
          d: "Base fee of the EXP opcode"
        },
        expByte: {
          v: 10,
          d: "Times ceil(log256(exponent)) for the EXP instruction"
        },
        keccak256: {
          v: 30,
          d: "Base fee of the SHA3 opcode"
        },
        keccak256Word: {
          v: 6,
          d: "Once per word of the SHA3 operation's data"
        },
        sload: {
          v: 50,
          d: "Base fee of the SLOAD opcode"
        },
        sstoreSet: {
          v: 2e4,
          d: "Once per SSTORE operation if the zeroness changes from zero"
        },
        sstoreReset: {
          v: 5e3,
          d: "Once per SSTORE operation if the zeroness does not change from zero"
        },
        sstoreRefund: {
          v: 15e3,
          d: "Once per SSTORE operation if the zeroness changes to zero"
        },
        jumpdest: {
          v: 1,
          d: "Base fee of the JUMPDEST opcode"
        },
        log: {
          v: 375,
          d: "Base fee of the LOG opcode"
        },
        logData: {
          v: 8,
          d: "Per byte in a LOG* operation's data"
        },
        logTopic: {
          v: 375,
          d: "Multiplied by the * of the LOG*, per LOG transaction. e.g. LOG0 incurs 0 * c_txLogTopicGas, LOG4 incurs 4 * c_txLogTopicGas"
        },
        create: {
          v: 32e3,
          d: "Base fee of the CREATE opcode"
        },
        call: {
          v: 40,
          d: "Base fee of the CALL opcode"
        },
        callStipend: {
          v: 2300,
          d: "Free gas given at beginning of call"
        },
        callValueTransfer: {
          v: 9e3,
          d: "Paid for CALL when the value transfor is non-zero"
        },
        callNewAccount: {
          v: 25e3,
          d: "Paid for CALL when the destination address didn't exist prior"
        },
        selfdestructRefund: {
          v: 24e3,
          d: "Refunded following a selfdestruct operation"
        },
        memory: {
          v: 3,
          d: "Times the address of the (highest referenced byte in memory + 1). NOTE: referencing happens on read, write and in instructions such as RETURN and CALL"
        },
        quadCoeffDiv: {
          v: 512,
          d: "Divisor for the quadratic particle of the memory cost equation"
        },
        createData: {
          v: 200,
          d: ""
        },
        tx: {
          v: 21e3,
          d: "Per transaction. NOTE: Not payable on data of calls between transactions"
        },
        txCreation: {
          v: 32e3,
          d: "The cost of creating a contract via tx"
        },
        txDataZero: {
          v: 4,
          d: "Per byte of data attached to a transaction that equals zero. NOTE: Not payable on data of calls between transactions"
        },
        txDataNonZero: {
          v: 68,
          d: "Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions"
        },
        copy: {
          v: 3,
          d: "Multiplied by the number of 32-byte words that are copied (round up) for any *COPY operation and added"
        },
        ecRecover: {
          v: 3e3,
          d: ""
        },
        sha256: {
          v: 60,
          d: ""
        },
        sha256Word: {
          v: 12,
          d: ""
        },
        ripemd160: {
          v: 600,
          d: ""
        },
        ripemd160Word: {
          v: 120,
          d: ""
        },
        identity: {
          v: 15,
          d: ""
        },
        identityWord: {
          v: 3,
          d: ""
        },
        stop: {
          v: 0,
          d: "Base fee of the STOP opcode"
        },
        add: {
          v: 3,
          d: "Base fee of the ADD opcode"
        },
        mul: {
          v: 5,
          d: "Base fee of the MUL opcode"
        },
        sub: {
          v: 3,
          d: "Base fee of the SUB opcode"
        },
        div: {
          v: 5,
          d: "Base fee of the DIV opcode"
        },
        sdiv: {
          v: 5,
          d: "Base fee of the SDIV opcode"
        },
        mod: {
          v: 5,
          d: "Base fee of the MOD opcode"
        },
        smod: {
          v: 5,
          d: "Base fee of the SMOD opcode"
        },
        addmod: {
          v: 8,
          d: "Base fee of the ADDMOD opcode"
        },
        mulmod: {
          v: 8,
          d: "Base fee of the MULMOD opcode"
        },
        signextend: {
          v: 5,
          d: "Base fee of the SIGNEXTEND opcode"
        },
        lt: {
          v: 3,
          d: "Base fee of the LT opcode"
        },
        gt: {
          v: 3,
          d: "Base fee of the GT opcode"
        },
        slt: {
          v: 3,
          d: "Base fee of the SLT opcode"
        },
        sgt: {
          v: 3,
          d: "Base fee of the SGT opcode"
        },
        eq: {
          v: 3,
          d: "Base fee of the EQ opcode"
        },
        iszero: {
          v: 3,
          d: "Base fee of the ISZERO opcode"
        },
        and: {
          v: 3,
          d: "Base fee of the AND opcode"
        },
        or: {
          v: 3,
          d: "Base fee of the OR opcode"
        },
        xor: {
          v: 3,
          d: "Base fee of the XOR opcode"
        },
        not: {
          v: 3,
          d: "Base fee of the NOT opcode"
        },
        byte: {
          v: 3,
          d: "Base fee of the BYTE opcode"
        },
        address: {
          v: 2,
          d: "Base fee of the ADDRESS opcode"
        },
        balance: {
          v: 20,
          d: "Base fee of the BALANCE opcode"
        },
        origin: {
          v: 2,
          d: "Base fee of the ORIGIN opcode"
        },
        caller: {
          v: 2,
          d: "Base fee of the CALLER opcode"
        },
        callvalue: {
          v: 2,
          d: "Base fee of the CALLVALUE opcode"
        },
        calldataload: {
          v: 3,
          d: "Base fee of the CALLDATALOAD opcode"
        },
        calldatasize: {
          v: 2,
          d: "Base fee of the CALLDATASIZE opcode"
        },
        calldatacopy: {
          v: 3,
          d: "Base fee of the CALLDATACOPY opcode"
        },
        codesize: {
          v: 2,
          d: "Base fee of the CODESIZE opcode"
        },
        codecopy: {
          v: 3,
          d: "Base fee of the CODECOPY opcode"
        },
        gasprice: {
          v: 2,
          d: "Base fee of the GASPRICE opcode"
        },
        extcodesize: {
          v: 20,
          d: "Base fee of the EXTCODESIZE opcode"
        },
        extcodecopy: {
          v: 20,
          d: "Base fee of the EXTCODECOPY opcode"
        },
        blockhash: {
          v: 20,
          d: "Base fee of the BLOCKHASH opcode"
        },
        coinbase: {
          v: 2,
          d: "Base fee of the COINBASE opcode"
        },
        timestamp: {
          v: 2,
          d: "Base fee of the TIMESTAMP opcode"
        },
        number: {
          v: 2,
          d: "Base fee of the NUMBER opcode"
        },
        difficulty: {
          v: 2,
          d: "Base fee of the DIFFICULTY opcode"
        },
        gaslimit: {
          v: 2,
          d: "Base fee of the GASLIMIT opcode"
        },
        pop: {
          v: 2,
          d: "Base fee of the POP opcode"
        },
        mload: {
          v: 3,
          d: "Base fee of the MLOAD opcode"
        },
        mstore: {
          v: 3,
          d: "Base fee of the MSTORE opcode"
        },
        mstore8: {
          v: 3,
          d: "Base fee of the MSTORE8 opcode"
        },
        sstore: {
          v: 0,
          d: "Base fee of the SSTORE opcode"
        },
        jump: {
          v: 8,
          d: "Base fee of the JUMP opcode"
        },
        jumpi: {
          v: 10,
          d: "Base fee of the JUMPI opcode"
        },
        pc: {
          v: 2,
          d: "Base fee of the PC opcode"
        },
        msize: {
          v: 2,
          d: "Base fee of the MSIZE opcode"
        },
        gas: {
          v: 2,
          d: "Base fee of the GAS opcode"
        },
        push: {
          v: 3,
          d: "Base fee of the PUSH opcode"
        },
        dup: {
          v: 3,
          d: "Base fee of the DUP opcode"
        },
        swap: {
          v: 3,
          d: "Base fee of the SWAP opcode"
        },
        callcode: {
          v: 40,
          d: "Base fee of the CALLCODE opcode"
        },
        return: {
          v: 0,
          d: "Base fee of the RETURN opcode"
        },
        invalid: {
          v: 0,
          d: "Base fee of the INVALID opcode"
        },
        selfdestruct: {
          v: 0,
          d: "Base fee of the SELFDESTRUCT opcode"
        }
      },
      vm: {
        stackLimit: {
          v: 1024,
          d: "Maximum size of VM stack allowed"
        },
        callCreateDepth: {
          v: 1024,
          d: "Maximum depth of call/create stack"
        },
        maxExtraDataSize: {
          v: 32,
          d: "Maximum size extra data may be after Genesis"
        }
      },
      pow: {
        minimumDifficulty: {
          v: 131072,
          d: "The minimum that the difficulty may ever be"
        },
        difficultyBoundDivisor: {
          v: 2048,
          d: "The bound divisor of the difficulty, used in the update calculations"
        },
        durationLimit: {
          v: 13,
          d: "The decision boundary on the blocktime duration used to determine whether difficulty should go up or not"
        },
        epochDuration: {
          v: 3e4,
          d: "Duration between proof-of-work epochs"
        },
        timebombPeriod: {
          v: 1e5,
          d: "Exponential difficulty timebomb period"
        },
        minerReward: {
          v: BigInt("5000000000000000000"),
          d: "the amount a miner get rewarded for mining a block"
        },
        difficultyBombDelay: {
          v: 0,
          d: "the amount of blocks to delay the difficulty bomb with"
        }
      }
    },
    homestead: {
      name: "homestead",
      comment: "Homestead hardfork with protocol and network changes",
      url: "https://eips.ethereum.org/EIPS/eip-606",
      status: Status2.Final,
      gasPrices: {
        delegatecall: {
          v: 40,
          d: "Base fee of the DELEGATECALL opcode"
        }
      }
    },
    dao: {
      name: "dao",
      comment: "DAO rescue hardfork",
      url: "https://eips.ethereum.org/EIPS/eip-779",
      status: Status2.Final
    },
    tangerineWhistle: {
      name: "tangerineWhistle",
      comment: "Hardfork with gas cost changes for IO-heavy operations",
      url: "https://eips.ethereum.org/EIPS/eip-608",
      status: Status2.Final,
      gasPrices: {
        sload: {
          v: 200,
          d: "Once per SLOAD operation"
        },
        call: {
          v: 700,
          d: "Once per CALL operation & message call transaction"
        },
        extcodesize: {
          v: 700,
          d: "Base fee of the EXTCODESIZE opcode"
        },
        extcodecopy: {
          v: 700,
          d: "Base fee of the EXTCODECOPY opcode"
        },
        balance: {
          v: 400,
          d: "Base fee of the BALANCE opcode"
        },
        delegatecall: {
          v: 700,
          d: "Base fee of the DELEGATECALL opcode"
        },
        callcode: {
          v: 700,
          d: "Base fee of the CALLCODE opcode"
        },
        selfdestruct: {
          v: 5e3,
          d: "Base fee of the SELFDESTRUCT opcode"
        }
      }
    },
    spuriousDragon: {
      name: "spuriousDragon",
      comment: "HF with EIPs for simple replay attack protection, EXP cost increase, state trie clearing, contract code size limit",
      url: "https://eips.ethereum.org/EIPS/eip-607",
      status: Status2.Final,
      gasPrices: {
        expByte: {
          v: 50,
          d: "Times ceil(log256(exponent)) for the EXP instruction"
        }
      },
      vm: {
        maxCodeSize: {
          v: 24576,
          d: "Maximum length of contract code"
        }
      }
    },
    byzantium: {
      name: "byzantium",
      comment: "Hardfork with new precompiles, instructions and other protocol changes",
      url: "https://eips.ethereum.org/EIPS/eip-609",
      status: Status2.Final,
      gasPrices: {
        modexpGquaddivisor: {
          v: 20,
          d: "Gquaddivisor from modexp precompile for gas calculation"
        },
        ecAdd: {
          v: 500,
          d: "Gas costs for curve addition precompile"
        },
        ecMul: {
          v: 4e4,
          d: "Gas costs for curve multiplication precompile"
        },
        ecPairing: {
          v: 1e5,
          d: "Base gas costs for curve pairing precompile"
        },
        ecPairingWord: {
          v: 8e4,
          d: "Gas costs regarding curve pairing precompile input length"
        },
        revert: {
          v: 0,
          d: "Base fee of the REVERT opcode"
        },
        staticcall: {
          v: 700,
          d: "Base fee of the STATICCALL opcode"
        },
        returndatasize: {
          v: 2,
          d: "Base fee of the RETURNDATASIZE opcode"
        },
        returndatacopy: {
          v: 3,
          d: "Base fee of the RETURNDATACOPY opcode"
        }
      },
      pow: {
        minerReward: {
          v: BigInt("3000000000000000000"),
          d: "the amount a miner get rewarded for mining a block"
        },
        difficultyBombDelay: {
          v: 3e6,
          d: "the amount of blocks to delay the difficulty bomb with"
        }
      }
    },
    constantinople: {
      name: "constantinople",
      comment: "Postponed hardfork including EIP-1283 (SSTORE gas metering changes)",
      url: "https://eips.ethereum.org/EIPS/eip-1013",
      status: Status2.Final,
      gasPrices: {
        netSstoreNoopGas: {
          v: 200,
          d: "Once per SSTORE operation if the value doesn't change"
        },
        netSstoreInitGas: {
          v: 2e4,
          d: "Once per SSTORE operation from clean zero"
        },
        netSstoreCleanGas: {
          v: 5e3,
          d: "Once per SSTORE operation from clean non-zero"
        },
        netSstoreDirtyGas: {
          v: 200,
          d: "Once per SSTORE operation from dirty"
        },
        netSstoreClearRefund: {
          v: 15e3,
          d: "Once per SSTORE operation for clearing an originally existing storage slot"
        },
        netSstoreResetRefund: {
          v: 4800,
          d: "Once per SSTORE operation for resetting to the original non-zero value"
        },
        netSstoreResetClearRefund: {
          v: 19800,
          d: "Once per SSTORE operation for resetting to the original zero value"
        },
        shl: {
          v: 3,
          d: "Base fee of the SHL opcode"
        },
        shr: {
          v: 3,
          d: "Base fee of the SHR opcode"
        },
        sar: {
          v: 3,
          d: "Base fee of the SAR opcode"
        },
        extcodehash: {
          v: 400,
          d: "Base fee of the EXTCODEHASH opcode"
        },
        create2: {
          v: 32e3,
          d: "Base fee of the CREATE2 opcode"
        }
      },
      pow: {
        minerReward: {
          v: BigInt("2000000000000000000"),
          d: "The amount a miner gets rewarded for mining a block"
        },
        difficultyBombDelay: {
          v: 5e6,
          d: "the amount of blocks to delay the difficulty bomb with"
        }
      }
    },
    petersburg: {
      name: "petersburg",
      comment: "Aka constantinopleFix, removes EIP-1283, activate together with or after constantinople",
      url: "https://eips.ethereum.org/EIPS/eip-1716",
      status: Status2.Final,
      gasPrices: {
        netSstoreNoopGas: {
          v: null,
          d: "Removed along EIP-1283"
        },
        netSstoreInitGas: {
          v: null,
          d: "Removed along EIP-1283"
        },
        netSstoreCleanGas: {
          v: null,
          d: "Removed along EIP-1283"
        },
        netSstoreDirtyGas: {
          v: null,
          d: "Removed along EIP-1283"
        },
        netSstoreClearRefund: {
          v: null,
          d: "Removed along EIP-1283"
        },
        netSstoreResetRefund: {
          v: null,
          d: "Removed along EIP-1283"
        },
        netSstoreResetClearRefund: {
          v: null,
          d: "Removed along EIP-1283"
        }
      }
    },
    istanbul: {
      name: "istanbul",
      comment: "HF targeted for December 2019 following the Constantinople/Petersburg HF",
      url: "https://eips.ethereum.org/EIPS/eip-1679",
      status: Status2.Final,
      gasConfig: {},
      gasPrices: {
        blake2Round: {
          v: 1,
          d: "Gas cost per round for the Blake2 F precompile"
        },
        ecAdd: {
          v: 150,
          d: "Gas costs for curve addition precompile"
        },
        ecMul: {
          v: 6e3,
          d: "Gas costs for curve multiplication precompile"
        },
        ecPairing: {
          v: 45e3,
          d: "Base gas costs for curve pairing precompile"
        },
        ecPairingWord: {
          v: 34e3,
          d: "Gas costs regarding curve pairing precompile input length"
        },
        txDataNonZero: {
          v: 16,
          d: "Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions"
        },
        sstoreSentryGasEIP2200: {
          v: 2300,
          d: "Minimum gas required to be present for an SSTORE call, not consumed"
        },
        sstoreNoopGasEIP2200: {
          v: 800,
          d: "Once per SSTORE operation if the value doesn't change"
        },
        sstoreDirtyGasEIP2200: {
          v: 800,
          d: "Once per SSTORE operation if a dirty value is changed"
        },
        sstoreInitGasEIP2200: {
          v: 2e4,
          d: "Once per SSTORE operation from clean zero to non-zero"
        },
        sstoreInitRefundEIP2200: {
          v: 19200,
          d: "Once per SSTORE operation for resetting to the original zero value"
        },
        sstoreCleanGasEIP2200: {
          v: 5e3,
          d: "Once per SSTORE operation from clean non-zero to something else"
        },
        sstoreCleanRefundEIP2200: {
          v: 4200,
          d: "Once per SSTORE operation for resetting to the original non-zero value"
        },
        sstoreClearRefundEIP2200: {
          v: 15e3,
          d: "Once per SSTORE operation for clearing an originally existing storage slot"
        },
        balance: {
          v: 700,
          d: "Base fee of the BALANCE opcode"
        },
        extcodehash: {
          v: 700,
          d: "Base fee of the EXTCODEHASH opcode"
        },
        chainid: {
          v: 2,
          d: "Base fee of the CHAINID opcode"
        },
        selfbalance: {
          v: 5,
          d: "Base fee of the SELFBALANCE opcode"
        },
        sload: {
          v: 800,
          d: "Base fee of the SLOAD opcode"
        }
      }
    },
    muirGlacier: {
      name: "muirGlacier",
      comment: "HF to delay the difficulty bomb",
      url: "https://eips.ethereum.org/EIPS/eip-2384",
      status: Status2.Final,
      pow: {
        difficultyBombDelay: {
          v: 9e6,
          d: "the amount of blocks to delay the difficulty bomb with"
        }
      }
    },
    berlin: {
      name: "berlin",
      comment: "HF targeted for July 2020 following the Muir Glacier HF",
      url: "https://eips.ethereum.org/EIPS/eip-2070",
      status: Status2.Final,
      eips: [2565, 2929, 2718, 2930]
    },
    london: {
      name: "london",
      comment: "HF targeted for July 2021 following the Berlin fork",
      url: "https://github.com/ethereum/eth1.0-specs/blob/master/network-upgrades/mainnet-upgrades/london.md",
      status: Status2.Final,
      eips: [1559, 3198, 3529, 3541]
    },
    arrowGlacier: {
      name: "arrowGlacier",
      comment: "HF to delay the difficulty bomb",
      url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/arrow-glacier.md",
      status: Status2.Final,
      eips: [4345]
    },
    grayGlacier: {
      name: "grayGlacier",
      comment: "Delaying the difficulty bomb to Mid September 2022",
      url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/gray-glacier.md",
      status: Status2.Final,
      eips: [5133]
    },
    paris: {
      name: "paris",
      comment: "Hardfork to upgrade the consensus mechanism to Proof-of-Stake",
      url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/merge.md",
      status: Status2.Final,
      consensus: {
        type: "pos",
        algorithm: "casper",
        casper: {}
      },
      eips: [3675, 4399]
    },
    mergeForkIdTransition: {
      name: "mergeForkIdTransition",
      comment: "Pre-merge hardfork to fork off non-upgraded clients",
      url: "https://eips.ethereum.org/EIPS/eip-3675",
      status: Status2.Final,
      eips: []
    },
    shanghai: {
      name: "shanghai",
      comment: "Next feature hardfork after the merge hardfork having withdrawals, warm coinbase, push0, limit/meter initcode",
      url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/shanghai.md",
      status: Status2.Final,
      eips: [3651, 3855, 3860, 4895]
    },
    cancun: {
      name: "cancun",
      comment: "Next feature hardfork after shanghai, includes proto-danksharding EIP 4844 blobs (still WIP hence not for production use), transient storage opcodes, parent beacon block root availability in EVM, selfdestruct only in same transaction, and blob base fee opcode",
      url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/cancun.md",
      status: Status2.Final,
      eips: [1153, 4844, 4788, 5656, 6780, 7516]
    },
    prague: {
      name: "prague",
      comment: "Next feature hardfork after cancun, internally used for pectra testing/implementation (incomplete/experimental)",
      url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/prague.md",
      status: Status2.Draft,
      eips: [2537, 2935, 3074, 6110, 7002, 7251, 7685]
    },
    osaka: {
      name: "osaka",
      comment: "Next feature hardfork after prague, internally used for verkle testing/implementation (incomplete/experimental)",
      url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/osaka.md",
      status: Status2.Draft,
      eips: [2935, 6800]
    }
  };

  // node_modules/@ethereumjs/common/dist/esm/utils.js
  function formatNonce(nonce) {
    if (!nonce || nonce === "0x0") {
      return "0x0000000000000000";
    }
    if (isHexString(nonce)) {
      return `0x${stripHexPrefix2(nonce).padStart(16, "0")}`;
    }
    return `0x${nonce.padStart(16, "0")}`;
  }
  function parseGethParams(json, mergeForkIdPostMerge = true) {
    const { name, config, difficulty, mixHash, gasLimit, coinbase, baseFeePerGas, excessBlobGas, extraData: unparsedExtraData, nonce: unparsedNonce, timestamp: unparsedTimestamp } = json;
    const genesisTimestamp = Number(unparsedTimestamp);
    const { chainId, depositContractAddress } = config;
    const extraData = unparsedExtraData === "" ? "0x" : unparsedExtraData;
    const timestamp = isHexString(unparsedTimestamp) ? unparsedTimestamp : intToHex(parseInt(unparsedTimestamp));
    const nonce = unparsedNonce.length !== 18 ? formatNonce(unparsedNonce) : unparsedNonce;
    if (config.eip155Block !== config.eip158Block) {
      throw new Error("EIP155 block number must equal EIP 158 block number since both are part of SpuriousDragon hardfork and the client only supports activating the full hardfork");
    }
    const params = {
      name,
      chainId,
      networkId: chainId,
      depositContractAddress,
      genesis: {
        timestamp,
        gasLimit,
        difficulty,
        nonce,
        extraData,
        mixHash,
        coinbase,
        baseFeePerGas,
        excessBlobGas
      },
      hardfork: void 0,
      hardforks: [],
      bootstrapNodes: [],
      consensus: config.clique !== void 0 ? {
        type: "poa",
        algorithm: "clique",
        clique: {
          // The recent geth genesis seems to be using blockperiodseconds
          // and epochlength for clique specification
          // see: https://hackmd.io/PqZgMpnkSWCWv5joJoFymQ
          period: config.clique.period ?? config.clique.blockperiodseconds,
          epoch: config.clique.epoch ?? config.clique.epochlength
        }
      } : {
        type: "pow",
        algorithm: "ethash",
        ethash: {}
      }
    };
    const forkMap = {
      [Hardfork.Homestead]: { name: "homesteadBlock" },
      [Hardfork.Dao]: { name: "daoForkBlock" },
      [Hardfork.TangerineWhistle]: { name: "eip150Block" },
      [Hardfork.SpuriousDragon]: { name: "eip155Block" },
      [Hardfork.Byzantium]: { name: "byzantiumBlock" },
      [Hardfork.Constantinople]: { name: "constantinopleBlock" },
      [Hardfork.Petersburg]: { name: "petersburgBlock" },
      [Hardfork.Istanbul]: { name: "istanbulBlock" },
      [Hardfork.MuirGlacier]: { name: "muirGlacierBlock" },
      [Hardfork.Berlin]: { name: "berlinBlock" },
      [Hardfork.London]: { name: "londonBlock" },
      [Hardfork.MergeForkIdTransition]: { name: "mergeForkBlock", postMerge: mergeForkIdPostMerge },
      [Hardfork.Shanghai]: { name: "shanghaiTime", postMerge: true, isTimestamp: true },
      [Hardfork.Cancun]: { name: "cancunTime", postMerge: true, isTimestamp: true },
      [Hardfork.Prague]: { name: "pragueTime", postMerge: true, isTimestamp: true },
      [Hardfork.Osaka]: { name: "osakaTime", postMerge: true, isTimestamp: true }
    };
    const forkMapRev = Object.keys(forkMap).reduce((acc, elem) => {
      acc[forkMap[elem].name] = elem;
      return acc;
    }, {});
    const configHardforkNames = Object.keys(config).filter((key) => forkMapRev[key] !== void 0 && config[key] !== void 0 && config[key] !== null);
    params.hardforks = configHardforkNames.map((nameBlock) => ({
      name: forkMapRev[nameBlock],
      block: forkMap[forkMapRev[nameBlock]].isTimestamp === true || typeof config[nameBlock] !== "number" ? null : config[nameBlock],
      timestamp: forkMap[forkMapRev[nameBlock]].isTimestamp === true && typeof config[nameBlock] === "number" ? config[nameBlock] : void 0
    })).filter((fork) => fork.block !== null || fork.timestamp !== void 0);
    params.hardforks.sort(function(a, b) {
      return (a.block ?? Infinity) - (b.block ?? Infinity);
    });
    params.hardforks.sort(function(a, b) {
      return (a.timestamp ?? 0) - (b.timestamp ?? 0);
    });
    for (const hf of params.hardforks) {
      if (hf.timestamp === genesisTimestamp) {
        hf.timestamp = 0;
      }
    }
    if (config.terminalTotalDifficulty !== void 0) {
      const mergeConfig = {
        name: Hardfork.Paris,
        ttd: config.terminalTotalDifficulty,
        block: null
      };
      const postMergeIndex = params.hardforks.findIndex((hf) => forkMap[hf.name]?.postMerge === true);
      if (postMergeIndex !== -1) {
        params.hardforks.splice(postMergeIndex, 0, mergeConfig);
      } else {
        params.hardforks.push(mergeConfig);
      }
    }
    const latestHardfork = params.hardforks.length > 0 ? params.hardforks.slice(-1)[0] : void 0;
    params.hardfork = latestHardfork?.name;
    params.hardforks.unshift({ name: Hardfork.Chainstart, block: 0 });
    return params;
  }
  function parseGethGenesis(json, name, mergeForkIdPostMerge) {
    try {
      const required = ["config", "difficulty", "gasLimit", "nonce", "alloc"];
      if (required.some((field) => !(field in json))) {
        const missingField = required.filter((field) => !(field in json));
        throw new Error(`Invalid format, expected geth genesis field "${missingField}" missing`);
      }
      const finalJson = { ...json };
      if (name !== void 0) {
        finalJson.name = name;
      }
      return parseGethParams(finalJson, mergeForkIdPostMerge);
    } catch (e) {
      throw new Error(`Error parsing parameters file: ${e.message}`);
    }
  }

  // node_modules/@ethereumjs/common/dist/esm/common.js
  var Common = class _Common {
    constructor(opts) {
      this._eips = [];
      this._paramsCache = {};
      this._activatedEIPsCache = [];
      this.events = new import_events2.EventEmitter();
      this._customChains = opts.customChains ?? [];
      this._chainParams = this.setChain(opts.chain);
      this.DEFAULT_HARDFORK = this._chainParams.defaultHardfork ?? Hardfork.Shanghai;
      this.HARDFORK_CHANGES = this.hardforks().map((hf) => [
        hf.name,
        hardforks[hf.name] ?? (this._chainParams.customHardforks && this._chainParams.customHardforks[hf.name])
      ]);
      this._hardfork = this.DEFAULT_HARDFORK;
      if (opts.hardfork !== void 0) {
        this.setHardfork(opts.hardfork);
      }
      if (opts.eips) {
        this.setEIPs(opts.eips);
      }
      this.customCrypto = opts.customCrypto ?? {};
      if (Object.keys(this._paramsCache).length === 0) {
        this._buildParamsCache();
        this._buildActivatedEIPsCache();
      }
    }
    /**
     * Creates a {@link Common} object for a custom chain, based on a standard one.
     *
     * It uses all the {@link Chain} parameters from the {@link baseChain} option except the ones overridden
     * in a provided {@link chainParamsOrName} dictionary. Some usage example:
     *
     * ```javascript
     * Common.custom({chainId: 123})
     * ```
     *
     * There are also selected supported custom chains which can be initialized by using one of the
     * {@link CustomChains} for {@link chainParamsOrName}, e.g.:
     *
     * ```javascript
     * Common.custom(CustomChains.MaticMumbai)
     * ```
     *
     * Note that these supported custom chains only provide some base parameters (usually the chain and
     * network ID and a name) and can only be used for selected use cases (e.g. sending a tx with
     * the `@ethereumjs/tx` library to a Layer-2 chain).
     *
     * @param chainParamsOrName Custom parameter dict (`name` will default to `custom-chain`) or string with name of a supported custom chain
     * @param opts Custom chain options to set the {@link CustomCommonOpts.baseChain}, selected {@link CustomCommonOpts.hardfork} and others
     */
    static custom(chainParamsOrName, opts = {}) {
      const baseChain = opts.baseChain ?? "mainnet";
      const standardChainParams = { ..._Common._getChainParams(baseChain) };
      standardChainParams["name"] = "custom-chain";
      if (typeof chainParamsOrName !== "string") {
        return new _Common({
          chain: {
            ...standardChainParams,
            ...chainParamsOrName
          },
          ...opts
        });
      } else {
        if (chainParamsOrName === CustomChain.PolygonMainnet) {
          return _Common.custom({
            name: CustomChain.PolygonMainnet,
            chainId: 137,
            networkId: 137
          }, opts);
        }
        if (chainParamsOrName === CustomChain.PolygonMumbai) {
          return _Common.custom({
            name: CustomChain.PolygonMumbai,
            chainId: 80001,
            networkId: 80001
          }, opts);
        }
        if (chainParamsOrName === CustomChain.ArbitrumOne) {
          return _Common.custom({
            name: CustomChain.ArbitrumOne,
            chainId: 42161,
            networkId: 42161
          }, opts);
        }
        if (chainParamsOrName === CustomChain.xDaiChain) {
          return _Common.custom({
            name: CustomChain.xDaiChain,
            chainId: 100,
            networkId: 100
          }, opts);
        }
        if (chainParamsOrName === CustomChain.OptimisticKovan) {
          return _Common.custom({
            name: CustomChain.OptimisticKovan,
            chainId: 69,
            networkId: 69
          }, opts);
        }
        if (chainParamsOrName === CustomChain.OptimisticEthereum) {
          return _Common.custom(
            {
              name: CustomChain.OptimisticEthereum,
              chainId: 10,
              networkId: 10
            },
            // Optimism has not implemented the London hardfork yet (targeting Q1.22)
            { hardfork: Hardfork.Berlin, ...opts }
          );
        }
        throw new Error(`Custom chain ${chainParamsOrName} not supported`);
      }
    }
    /**
     * Static method to load and set common from a geth genesis json
     * @param genesisJson json of geth configuration
     * @param { chain, eips, genesisHash, hardfork, mergeForkIdPostMerge } to further configure the common instance
     * @returns Common
     */
    static fromGethGenesis(genesisJson, { chain: chain2, eips, genesisHash, hardfork, mergeForkIdPostMerge, customCrypto }) {
      const genesisParams = parseGethGenesis(genesisJson, chain2, mergeForkIdPostMerge);
      const common = new _Common({
        chain: genesisParams.name ?? "custom",
        customChains: [genesisParams],
        eips,
        hardfork: hardfork ?? genesisParams.hardfork,
        customCrypto
      });
      if (genesisHash !== void 0) {
        common.setForkHashes(genesisHash);
      }
      return common;
    }
    /**
     * Static method to determine if a {@link chainId} is supported as a standard chain
     * @param chainId bigint id (`1`) of a standard chain
     * @returns boolean
     */
    static isSupportedChainId(chainId) {
      const initializedChains = this.getInitializedChains();
      return Boolean(initializedChains["names"][chainId.toString()]);
    }
    static _getChainParams(chain2, customChains) {
      const initializedChains = this.getInitializedChains(customChains);
      if (typeof chain2 === "number" || typeof chain2 === "bigint") {
        chain2 = chain2.toString();
        if (initializedChains["names"][chain2]) {
          const name = initializedChains["names"][chain2];
          return initializedChains[name];
        }
        throw new Error(`Chain with ID ${chain2} not supported`);
      }
      if (initializedChains[chain2] !== void 0) {
        return initializedChains[chain2];
      }
      throw new Error(`Chain with name ${chain2} not supported`);
    }
    /**
     * Sets the chain
     * @param chain String ('mainnet') or Number (1) chain representation.
     *              Or, a Dictionary of chain parameters for a private network.
     * @returns The dictionary with parameters set as chain
     */
    setChain(chain2) {
      if (typeof chain2 === "number" || typeof chain2 === "bigint" || typeof chain2 === "string") {
        this._chainParams = _Common._getChainParams(chain2, this._customChains);
      } else if (typeof chain2 === "object") {
        if (this._customChains.length > 0) {
          throw new Error("Chain must be a string, number, or bigint when initialized with customChains passed in");
        }
        const required = ["networkId", "genesis", "hardforks", "bootstrapNodes"];
        for (const param of required) {
          if (!(param in chain2)) {
            throw new Error(`Missing required chain parameter: ${param}`);
          }
        }
        this._chainParams = chain2;
      } else {
        throw new Error("Wrong input format");
      }
      for (const hf of this.hardforks()) {
        if (hf.block === void 0) {
          throw new Error(`Hardfork cannot have undefined block number`);
        }
      }
      return this._chainParams;
    }
    /**
     * Sets the hardfork to get params for
     * @param hardfork String identifier (e.g. 'byzantium') or {@link Hardfork} enum
     */
    setHardfork(hardfork) {
      let existing = false;
      for (const hfChanges of this.HARDFORK_CHANGES) {
        if (hfChanges[0] === hardfork) {
          if (this._hardfork !== hardfork) {
            this._hardfork = hardfork;
            this._buildParamsCache();
            this._buildActivatedEIPsCache();
            this.events.emit("hardforkChanged", hardfork);
          }
          existing = true;
        }
      }
      if (!existing) {
        throw new Error(`Hardfork with name ${hardfork} not supported`);
      }
    }
    /**
     * Returns the hardfork either based on block numer (older HFs) or
     * timestamp (Shanghai upwards).
     *
     * An optional TD takes precedence in case the corresponding HF block
     * is set to `null` or otherwise needs to match (if not an error
     * will be thrown).
     *
     * @param Opts Block number, timestamp or TD (all optional)
     * @returns The name of the HF
     */
    getHardforkBy(opts) {
      const blockNumber = toType(opts.blockNumber, TypeOutput.BigInt);
      const td = toType(opts.td, TypeOutput.BigInt);
      const timestamp = toType(opts.timestamp, TypeOutput.BigInt);
      const hfs = this.hardforks().filter((hf) => hf.block !== null || hf.ttd !== null && hf.ttd !== void 0 || hf.timestamp !== void 0);
      const mergeIndex = hfs.findIndex((hf) => hf.ttd !== null && hf.ttd !== void 0);
      const doubleTTDHF = hfs.slice(mergeIndex + 1).findIndex((hf) => hf.ttd !== null && hf.ttd !== void 0);
      if (doubleTTDHF >= 0) {
        throw Error(`More than one merge hardforks found with ttd specified`);
      }
      let hfIndex = hfs.findIndex((hf) => blockNumber !== void 0 && hf.block !== null && BigInt(hf.block) > blockNumber || timestamp !== void 0 && hf.timestamp !== void 0 && BigInt(hf.timestamp) > timestamp);
      if (hfIndex === -1) {
        hfIndex = hfs.length;
      } else if (hfIndex === 0) {
        throw Error("Must have at least one hardfork at block 0");
      }
      if (timestamp === void 0) {
        const stepBack = hfs.slice(0, hfIndex).reverse().findIndex((hf) => hf.block !== null || hf.ttd !== void 0);
        hfIndex = hfIndex - stepBack;
      }
      hfIndex = hfIndex - 1;
      if (hfs[hfIndex].block === null && hfs[hfIndex].timestamp === void 0) {
        if (td === void 0 || td === null || BigInt(hfs[hfIndex].ttd) > td) {
          hfIndex -= 1;
        }
      } else {
        if (mergeIndex >= 0 && td !== void 0 && td !== null) {
          if (hfIndex >= mergeIndex && BigInt(hfs[mergeIndex].ttd) > td) {
            throw Error("Maximum HF determined by total difficulty is lower than the block number HF");
          } else if (hfIndex < mergeIndex && BigInt(hfs[mergeIndex].ttd) < td) {
            throw Error("HF determined by block number is lower than the minimum total difficulty HF");
          }
        }
      }
      const hfStartIndex = hfIndex;
      for (; hfIndex < hfs.length - 1; hfIndex++) {
        if (hfs[hfIndex].block !== hfs[hfIndex + 1].block || hfs[hfIndex].timestamp !== hfs[hfIndex + 1].timestamp) {
          break;
        }
      }
      if (timestamp !== void 0) {
        const minTimeStamp = hfs.slice(0, hfStartIndex).reduce((acc, hf) => Math.max(Number(hf.timestamp ?? "0"), acc), 0);
        if (minTimeStamp > timestamp) {
          throw Error(`Maximum HF determined by timestamp is lower than the block number/ttd HF`);
        }
        const maxTimeStamp = hfs.slice(hfIndex + 1).reduce((acc, hf) => Math.min(Number(hf.timestamp ?? timestamp), acc), Number(timestamp));
        if (maxTimeStamp < timestamp) {
          throw Error(`Maximum HF determined by block number/ttd is lower than timestamp HF`);
        }
      }
      const hardfork = hfs[hfIndex];
      return hardfork.name;
    }
    /**
     * Sets a new hardfork either based on block numer (older HFs) or
     * timestamp (Shanghai upwards).
     *
     * An optional TD takes precedence in case the corresponding HF block
     * is set to `null` or otherwise needs to match (if not an error
     * will be thrown).
     *
     * @param Opts Block number, timestamp or TD (all optional)
     * @returns The name of the HF set
     */
    setHardforkBy(opts) {
      const hardfork = this.getHardforkBy(opts);
      this.setHardfork(hardfork);
      return hardfork;
    }
    /**
     * Internal helper function, returns the params for the given hardfork for the chain set
     * @param hardfork Hardfork name
     * @returns Dictionary with hardfork params or null if hardfork not on chain
     */
    _getHardfork(hardfork) {
      const hfs = this.hardforks();
      for (const hf of hfs) {
        if (hf["name"] === hardfork)
          return hf;
      }
      return null;
    }
    /**
     * Sets the active EIPs
     * @param eips
     */
    setEIPs(eips = []) {
      for (const eip of eips) {
        if (!(eip in EIPs)) {
          throw new Error(`${eip} not supported`);
        }
        const minHF = this.gteHardfork(EIPs[eip]["minimumHardfork"]);
        if (!minHF) {
          throw new Error(`${eip} cannot be activated on hardfork ${this.hardfork()}, minimumHardfork: ${minHF}`);
        }
      }
      this._eips = eips;
      this._buildParamsCache();
      this._buildActivatedEIPsCache();
      for (const eip of eips) {
        if (EIPs[eip].requiredEIPs !== void 0) {
          for (const elem of EIPs[eip].requiredEIPs) {
            if (!(eips.includes(elem) || this.isActivatedEIP(elem))) {
              throw new Error(`${eip} requires EIP ${elem}, but is not included in the EIP list`);
            }
          }
        }
      }
    }
    /**
     * Internal helper for _buildParamsCache()
     */
    _mergeWithParamsCache(params) {
      this._paramsCache["gasConfig"] = {
        ...this._paramsCache["gasConfig"],
        ...params["gasConfig"]
      };
      this._paramsCache["gasPrices"] = {
        ...this._paramsCache["gasPrices"],
        ...params["gasPrices"]
      };
      this._paramsCache["pow"] = {
        ...this._paramsCache["pow"],
        ...params["pow"]
      };
      this._paramsCache["sharding"] = {
        ...this._paramsCache["sharding"],
        ...params["sharding"]
      };
      this._paramsCache["vm"] = {
        ...this._paramsCache["vm"],
        ...params["vm"]
      };
    }
    /**
     * Build up a cache for all parameter values for the current HF and all activated EIPs
     */
    _buildParamsCache() {
      this._paramsCache = {};
      const hardfork = this.hardfork();
      for (const hfChanges of this.HARDFORK_CHANGES) {
        if ("eips" in hfChanges[1]) {
          const hfEIPs = hfChanges[1]["eips"];
          for (const eip of hfEIPs) {
            if (!(eip in EIPs)) {
              throw new Error(`${eip} not supported`);
            }
            this._mergeWithParamsCache(EIPs[eip]);
          }
        } else {
          this._mergeWithParamsCache(hfChanges[1]);
        }
        if (hfChanges[0] === hardfork)
          break;
      }
      for (const eip of this._eips) {
        if (!(eip in EIPs)) {
          throw new Error(`${eip} not supported`);
        }
        this._mergeWithParamsCache(EIPs[eip]);
      }
    }
    _buildActivatedEIPsCache() {
      this._activatedEIPsCache = [];
      for (const hfChanges of this.HARDFORK_CHANGES) {
        const hf = hfChanges[1];
        if (this.gteHardfork(hf["name"]) && "eips" in hf) {
          this._activatedEIPsCache = this._activatedEIPsCache.concat(hf["eips"]);
        }
      }
      this._activatedEIPsCache = this._activatedEIPsCache.concat(this._eips);
    }
    /**
     * Returns a parameter for the current chain setup
     *
     * If the parameter is present in an EIP, the EIP always takes precedence.
     * Otherwise the parameter is taken from the latest applied HF with
     * a change on the respective parameter.
     *
     * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')
     * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)
     * @returns The value requested or `BigInt(0)` if not found
     */
    param(topic, name) {
      let value = null;
      if (this._paramsCache[topic] !== void 0 && this._paramsCache[topic][name] !== void 0) {
        value = this._paramsCache[topic][name].v;
      }
      return BigInt(value ?? 0);
    }
    /**
     * Returns the parameter corresponding to a hardfork
     * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')
     * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)
     * @param hardfork Hardfork name
     * @returns The value requested or `BigInt(0)` if not found
     */
    paramByHardfork(topic, name, hardfork) {
      let value = null;
      for (const hfChanges of this.HARDFORK_CHANGES) {
        if ("eips" in hfChanges[1]) {
          const hfEIPs = hfChanges[1]["eips"];
          for (const eip of hfEIPs) {
            const valueEIP = this.paramByEIP(topic, name, eip);
            value = typeof valueEIP === "bigint" ? valueEIP : value;
          }
        } else {
          if (hfChanges[1][topic] !== void 0 && hfChanges[1][topic][name] !== void 0) {
            value = hfChanges[1][topic][name].v;
          }
        }
        if (hfChanges[0] === hardfork)
          break;
      }
      return BigInt(value ?? 0);
    }
    /**
     * Returns a parameter corresponding to an EIP
     * @param topic Parameter topic ('gasConfig', 'gasPrices', 'vm', 'pow')
     * @param name Parameter name (e.g. 'minGasLimit' for 'gasConfig' topic)
     * @param eip Number of the EIP
     * @returns The value requested or `undefined` if not found
     */
    paramByEIP(topic, name, eip) {
      if (!(eip in EIPs)) {
        throw new Error(`${eip} not supported`);
      }
      const eipParams = EIPs[eip];
      if (!(topic in eipParams)) {
        return void 0;
      }
      if (eipParams[topic][name] === void 0) {
        return void 0;
      }
      const value = eipParams[topic][name].v;
      return BigInt(value);
    }
    /**
     * Returns a parameter for the hardfork active on block number or
     * optional provided total difficulty (Merge HF)
     * @param topic Parameter topic
     * @param name Parameter name
     * @param blockNumber Block number
     * @param td Total difficulty
     *    * @returns The value requested or `BigInt(0)` if not found
     */
    paramByBlock(topic, name, blockNumber, td, timestamp) {
      const hardfork = this.getHardforkBy({ blockNumber, td, timestamp });
      return this.paramByHardfork(topic, name, hardfork);
    }
    /**
     * Checks if an EIP is activated by either being included in the EIPs
     * manually passed in with the {@link CommonOpts.eips} or in a
     * hardfork currently being active
     *
     * Note: this method only works for EIPs being supported
     * by the {@link CommonOpts.eips} constructor option
     * @param eip
     */
    isActivatedEIP(eip) {
      if (this._activatedEIPsCache.includes(eip)) {
        return true;
      }
      return false;
    }
    /**
     * Checks if set or provided hardfork is active on block number
     * @param hardfork Hardfork name or null (for HF set)
     * @param blockNumber
     * @returns True if HF is active on block number
     */
    hardforkIsActiveOnBlock(hardfork, blockNumber) {
      blockNumber = toType(blockNumber, TypeOutput.BigInt);
      hardfork = hardfork ?? this._hardfork;
      const hfBlock = this.hardforkBlock(hardfork);
      if (typeof hfBlock === "bigint" && hfBlock !== BIGINT_02 && blockNumber >= hfBlock) {
        return true;
      }
      return false;
    }
    /**
     * Alias to hardforkIsActiveOnBlock when hardfork is set
     * @param blockNumber
     * @returns True if HF is active on block number
     */
    activeOnBlock(blockNumber) {
      return this.hardforkIsActiveOnBlock(null, blockNumber);
    }
    /**
     * Sequence based check if given or set HF1 is greater than or equal HF2
     * @param hardfork1 Hardfork name or null (if set)
     * @param hardfork2 Hardfork name
     * @param opts Hardfork options
     * @returns True if HF1 gte HF2
     */
    hardforkGteHardfork(hardfork1, hardfork2) {
      hardfork1 = hardfork1 ?? this._hardfork;
      const hardforks2 = this.hardforks();
      let posHf1 = -1, posHf2 = -1;
      let index = 0;
      for (const hf of hardforks2) {
        if (hf["name"] === hardfork1)
          posHf1 = index;
        if (hf["name"] === hardfork2)
          posHf2 = index;
        index += 1;
      }
      return posHf1 >= posHf2 && posHf2 !== -1;
    }
    /**
     * Alias to hardforkGteHardfork when hardfork is set
     * @param hardfork Hardfork name
     * @returns True if hardfork set is greater than hardfork provided
     */
    gteHardfork(hardfork) {
      return this.hardforkGteHardfork(null, hardfork);
    }
    /**
     * Returns the hardfork change block for hardfork provided or set
     * @param hardfork Hardfork name, optional if HF set
     * @returns Block number or null if unscheduled
     */
    hardforkBlock(hardfork) {
      hardfork = hardfork ?? this._hardfork;
      const block = this._getHardfork(hardfork)?.["block"];
      if (block === void 0 || block === null) {
        return null;
      }
      return BigInt(block);
    }
    hardforkTimestamp(hardfork) {
      hardfork = hardfork ?? this._hardfork;
      const timestamp = this._getHardfork(hardfork)?.["timestamp"];
      if (timestamp === void 0 || timestamp === null) {
        return null;
      }
      return BigInt(timestamp);
    }
    /**
     * Returns the hardfork change block for eip
     * @param eip EIP number
     * @returns Block number or null if unscheduled
     */
    eipBlock(eip) {
      for (const hfChanges of this.HARDFORK_CHANGES) {
        const hf = hfChanges[1];
        if ("eips" in hf) {
          if (hf["eips"].includes(eip)) {
            return this.hardforkBlock(hfChanges[0]);
          }
        }
      }
      return null;
    }
    /**
     * Returns the scheduled timestamp of the EIP (if scheduled and scheduled by timestamp)
     * @param eip EIP number
     * @returns Scheduled timestamp. If this EIP is unscheduled, or the EIP is scheduled by block number or ttd, then it returns `null`.
     */
    eipTimestamp(eip) {
      for (const hfChanges of this.HARDFORK_CHANGES) {
        const hf = hfChanges[1];
        if ("eips" in hf) {
          if (hf["eips"].includes(eip)) {
            return this.hardforkTimestamp(hfChanges[0]);
          }
        }
      }
      return null;
    }
    /**
     * Returns the hardfork change total difficulty (Merge HF) for hardfork provided or set
     * @param hardfork Hardfork name, optional if HF set
     * @returns Total difficulty or null if no set
     */
    hardforkTTD(hardfork) {
      hardfork = hardfork ?? this._hardfork;
      const ttd = this._getHardfork(hardfork)?.["ttd"];
      if (ttd === void 0 || ttd === null) {
        return null;
      }
      return BigInt(ttd);
    }
    /**
     * Returns the change block for the next hardfork after the hardfork provided or set
     * @param hardfork Hardfork name, optional if HF set
     * @returns Block timestamp, number or null if not available
     */
    nextHardforkBlockOrTimestamp(hardfork) {
      hardfork = hardfork ?? this._hardfork;
      const hfs = this.hardforks();
      let hfIndex = hfs.findIndex((hf) => hf.name === hardfork);
      if (hardfork === Hardfork.Paris) {
        hfIndex -= 1;
      }
      if (hfIndex < 0) {
        return null;
      }
      let currHfTimeOrBlock = hfs[hfIndex].timestamp ?? hfs[hfIndex].block;
      currHfTimeOrBlock = currHfTimeOrBlock !== null && currHfTimeOrBlock !== void 0 ? Number(currHfTimeOrBlock) : null;
      const nextHf = hfs.slice(hfIndex + 1).find((hf) => {
        let hfTimeOrBlock = hf.timestamp ?? hf.block;
        hfTimeOrBlock = hfTimeOrBlock !== null && hfTimeOrBlock !== void 0 ? Number(hfTimeOrBlock) : null;
        return hf.name !== Hardfork.Paris && hfTimeOrBlock !== null && hfTimeOrBlock !== void 0 && hfTimeOrBlock !== currHfTimeOrBlock;
      });
      if (nextHf === void 0) {
        return null;
      }
      const nextHfBlock = nextHf.timestamp ?? nextHf.block;
      if (nextHfBlock === null || nextHfBlock === void 0) {
        return null;
      }
      return BigInt(nextHfBlock);
    }
    /**
     * Internal helper function to calculate a fork hash
     * @param hardfork Hardfork name
     * @param genesisHash Genesis block hash of the chain
     * @returns Fork hash as hex string
     */
    _calcForkHash(hardfork, genesisHash) {
      let hfBytes = new Uint8Array(0);
      let prevBlockOrTime = 0;
      for (const hf of this.hardforks()) {
        const { block, timestamp, name } = hf;
        let blockOrTime = timestamp ?? block;
        blockOrTime = blockOrTime !== null ? Number(blockOrTime) : null;
        if (typeof blockOrTime === "number" && blockOrTime !== 0 && blockOrTime !== prevBlockOrTime && name !== Hardfork.Paris) {
          const hfBlockBytes = hexToBytes6(`0x${blockOrTime.toString(16).padStart(16, "0")}`);
          hfBytes = concatBytes5(hfBytes, hfBlockBytes);
          prevBlockOrTime = blockOrTime;
        }
        if (hf.name === hardfork)
          break;
      }
      const inputBytes = concatBytes5(genesisHash, hfBytes);
      const forkhash = bytesToHex5(intToBytes(crc32(inputBytes) >>> 0));
      return forkhash;
    }
    /**
     * Returns an eth/64 compliant fork hash (EIP-2124)
     * @param hardfork Hardfork name, optional if HF set
     * @param genesisHash Genesis block hash of the chain, optional if already defined and not needed to be calculated
     */
    forkHash(hardfork, genesisHash) {
      hardfork = hardfork ?? this._hardfork;
      const data = this._getHardfork(hardfork);
      if (data === null || data?.block === null && data?.timestamp === void 0 && data?.ttd === void 0) {
        const msg = "No fork hash calculation possible for future hardfork";
        throw new Error(msg);
      }
      if (data?.forkHash !== null && data?.forkHash !== void 0) {
        return data.forkHash;
      }
      if (!genesisHash)
        throw new Error("genesisHash required for forkHash calculation");
      return this._calcForkHash(hardfork, genesisHash);
    }
    /**
     *
     * @param forkHash Fork hash as a hex string
     * @returns Array with hardfork data (name, block, forkHash)
     */
    hardforkForForkHash(forkHash) {
      const resArray = this.hardforks().filter((hf) => {
        return hf.forkHash === forkHash;
      });
      return resArray.length >= 1 ? resArray[resArray.length - 1] : null;
    }
    /**
     * Sets any missing forkHashes on the passed-in {@link Common} instance
     * @param common The {@link Common} to set the forkHashes for
     * @param genesisHash The genesis block hash
     */
    setForkHashes(genesisHash) {
      for (const hf of this.hardforks()) {
        const blockOrTime = hf.timestamp ?? hf.block;
        if ((hf.forkHash === null || hf.forkHash === void 0) && (blockOrTime !== null && blockOrTime !== void 0 || typeof hf.ttd !== "undefined")) {
          hf.forkHash = this.forkHash(hf.name, genesisHash);
        }
      }
    }
    /**
     * Returns the Genesis parameters of the current chain
     * @returns Genesis dictionary
     */
    genesis() {
      return this._chainParams.genesis;
    }
    /**
     * Returns the hardforks for current chain
     * @returns {Array} Array with arrays of hardforks
     */
    hardforks() {
      const hfs = this._chainParams.hardforks;
      if (this._chainParams.customHardforks !== void 0) {
        this._chainParams.customHardforks;
      }
      return hfs;
    }
    /**
     * Returns bootstrap nodes for the current chain
     * @returns {Dictionary} Dict with bootstrap nodes
     */
    bootstrapNodes() {
      return this._chainParams.bootstrapNodes;
    }
    /**
     * Returns DNS networks for the current chain
     * @returns {String[]} Array of DNS ENR urls
     */
    dnsNetworks() {
      return this._chainParams.dnsNetworks;
    }
    /**
     * Returns the hardfork set
     * @returns Hardfork name
     */
    hardfork() {
      return this._hardfork;
    }
    /**
     * Returns the Id of current chain
     * @returns chain Id
     */
    chainId() {
      return BigInt(this._chainParams.chainId);
    }
    /**
     * Returns the name of current chain
     * @returns chain name (lower case)
     */
    chainName() {
      return this._chainParams.name;
    }
    /**
     * Returns the Id of current network
     * @returns network Id
     */
    networkId() {
      return BigInt(this._chainParams.networkId);
    }
    /**
     * Returns the additionally activated EIPs
     * (by using the `eips` constructor option)
     * @returns List of EIPs
     */
    eips() {
      return this._eips;
    }
    /**
     * Returns the consensus type of the network
     * Possible values: "pow"|"poa"|"pos"
     *
     * Note: This value can update along a Hardfork.
     */
    consensusType() {
      const hardfork = this.hardfork();
      let value;
      for (const hfChanges of this.HARDFORK_CHANGES) {
        if ("consensus" in hfChanges[1]) {
          value = hfChanges[1]["consensus"]["type"];
        }
        if (hfChanges[0] === hardfork)
          break;
      }
      return value ?? this._chainParams["consensus"]["type"];
    }
    /**
     * Returns the concrete consensus implementation
     * algorithm or protocol for the network
     * e.g. "ethash" for "pow" consensus type,
     * "clique" for "poa" consensus type or
     * "casper" for "pos" consensus type.
     *
     * Note: This value can update along a Hardfork.
     */
    consensusAlgorithm() {
      const hardfork = this.hardfork();
      let value;
      for (const hfChanges of this.HARDFORK_CHANGES) {
        if ("consensus" in hfChanges[1]) {
          value = hfChanges[1]["consensus"]["algorithm"];
        }
        if (hfChanges[0] === hardfork)
          break;
      }
      return value ?? this._chainParams["consensus"]["algorithm"];
    }
    /**
     * Returns a dictionary with consensus configuration
     * parameters based on the consensus algorithm
     *
     * Expected returns (parameters must be present in
     * the respective chain json files):
     *
     * ethash: empty object
     * clique: period, epoch
     * casper: empty object
     *
     * Note: This value can update along a Hardfork.
     */
    consensusConfig() {
      const hardfork = this.hardfork();
      let value;
      for (const hfChanges of this.HARDFORK_CHANGES) {
        if ("consensus" in hfChanges[1]) {
          const config = hfChanges[1];
          const algorithm = config["consensus"]["algorithm"];
          value = config["consensus"][algorithm];
        }
        if (hfChanges[0] === hardfork)
          break;
      }
      return value ?? this._chainParams["consensus"][this.consensusAlgorithm()] ?? {};
    }
    /**
     * Returns a deep copy of this {@link Common} instance.
     */
    copy() {
      const copy = Object.assign(Object.create(Object.getPrototypeOf(this)), this);
      copy.events = new import_events2.EventEmitter();
      return copy;
    }
    static getInitializedChains(customChains) {
      const names = {};
      for (const [name, id] of Object.entries(Chain)) {
        names[id] = name.toLowerCase();
      }
      const chains2 = { ...chains };
      if (customChains) {
        for (const chain2 of customChains) {
          const { name } = chain2;
          names[chain2.chainId.toString()] = name;
          chains2[name] = chain2;
        }
      }
      chains2.names = names;
      return chains2;
    }
  };

  // node_modules/@ethereumjs/tx/dist/esm/types.js
  var Capability;
  (function(Capability2) {
    Capability2[Capability2["EIP155ReplayProtection"] = 155] = "EIP155ReplayProtection";
    Capability2[Capability2["EIP1559FeeMarket"] = 1559] = "EIP1559FeeMarket";
    Capability2[Capability2["EIP2718TypedTransaction"] = 2718] = "EIP2718TypedTransaction";
    Capability2[Capability2["EIP2930AccessLists"] = 2930] = "EIP2930AccessLists";
    Capability2[Capability2["EIP7702EOACode"] = 7702] = "EIP7702EOACode";
  })(Capability || (Capability = {}));
  function isAccessListBytes(input) {
    if (input.length === 0) {
      return true;
    }
    const firstItem = input[0];
    if (Array.isArray(firstItem)) {
      return true;
    }
    return false;
  }
  function isAccessList(input) {
    return !isAccessListBytes(input);
  }
  var TransactionType;
  (function(TransactionType2) {
    TransactionType2[TransactionType2["Legacy"] = 0] = "Legacy";
    TransactionType2[TransactionType2["AccessListEIP2930"] = 1] = "AccessListEIP2930";
    TransactionType2[TransactionType2["FeeMarketEIP1559"] = 2] = "FeeMarketEIP1559";
    TransactionType2[TransactionType2["BlobEIP4844"] = 3] = "BlobEIP4844";
    TransactionType2[TransactionType2["EOACodeEIP7702"] = 4] = "EOACodeEIP7702";
  })(TransactionType || (TransactionType = {}));

  // node_modules/@ethereumjs/tx/dist/esm/util.js
  function checkMaxInitCodeSize(common, length) {
    const maxInitCodeSize = common.param("vm", "maxInitCodeSize");
    if (maxInitCodeSize && BigInt(length) > maxInitCodeSize) {
      throw new Error(`the initcode size of this transaction is too large: it is ${length} while the max is ${common.param("vm", "maxInitCodeSize")}`);
    }
  }
  var AccessLists = class {
    static getAccessListData(accessList) {
      let AccessListJSON;
      let bufferAccessList;
      if (isAccessList(accessList)) {
        AccessListJSON = accessList;
        const newAccessList = [];
        for (let i = 0; i < accessList.length; i++) {
          const item = accessList[i];
          const addressBytes = hexToBytes6(item.address);
          const storageItems = [];
          for (let index = 0; index < item.storageKeys.length; index++) {
            storageItems.push(hexToBytes6(item.storageKeys[index]));
          }
          newAccessList.push([addressBytes, storageItems]);
        }
        bufferAccessList = newAccessList;
      } else {
        bufferAccessList = accessList ?? [];
        const json = [];
        for (let i = 0; i < bufferAccessList.length; i++) {
          const data = bufferAccessList[i];
          const address = bytesToHex5(data[0]);
          const storageKeys = [];
          for (let item = 0; item < data[1].length; item++) {
            storageKeys.push(bytesToHex5(data[1][item]));
          }
          const jsonItem = {
            address,
            storageKeys
          };
          json.push(jsonItem);
        }
        AccessListJSON = json;
      }
      return {
        AccessListJSON,
        accessList: bufferAccessList
      };
    }
    static verifyAccessList(accessList) {
      for (let key = 0; key < accessList.length; key++) {
        const accessListItem = accessList[key];
        const address = accessListItem[0];
        const storageSlots = accessListItem[1];
        if (accessListItem[2] !== void 0) {
          throw new Error("Access list item cannot have 3 elements. It can only have an address, and an array of storage slots.");
        }
        if (address.length !== 20) {
          throw new Error("Invalid EIP-2930 transaction: address length should be 20 bytes");
        }
        for (let storageSlot = 0; storageSlot < storageSlots.length; storageSlot++) {
          if (storageSlots[storageSlot].length !== 32) {
            throw new Error("Invalid EIP-2930 transaction: storage slot length should be 32 bytes");
          }
        }
      }
    }
    static getAccessListJSON(accessList) {
      const accessListJSON = [];
      for (let index = 0; index < accessList.length; index++) {
        const item = accessList[index];
        const JSONItem = {
          address: bytesToHex5(setLengthLeft(item[0], 20)),
          storageKeys: []
        };
        const storageSlots = item[1];
        for (let slot = 0; slot < storageSlots.length; slot++) {
          const storageSlot = storageSlots[slot];
          JSONItem.storageKeys.push(bytesToHex5(setLengthLeft(storageSlot, 32)));
        }
        accessListJSON.push(JSONItem);
      }
      return accessListJSON;
    }
    static getDataFeeEIP2930(accessList, common) {
      const accessListStorageKeyCost = common.param("gasPrices", "accessListStorageKeyCost");
      const accessListAddressCost = common.param("gasPrices", "accessListAddressCost");
      let slots = 0;
      for (let index = 0; index < accessList.length; index++) {
        const item = accessList[index];
        const storageSlots = item[1];
        slots += storageSlots.length;
      }
      const addresses = accessList.length;
      return addresses * Number(accessListAddressCost) + slots * Number(accessListStorageKeyCost);
    }
  };
  function txTypeBytes(txType) {
    return hexToBytes6(`0x${txType.toString(16).padStart(2, "0")}`);
  }

  // node_modules/@ethereumjs/tx/dist/esm/baseTransaction.js
  var BaseTransaction = class {
    constructor(txData, opts) {
      this.cache = {
        hash: void 0,
        dataFee: void 0,
        senderPubKey: void 0
      };
      this.activeCapabilities = [];
      this.DEFAULT_CHAIN = Chain.Mainnet;
      const { nonce, gasLimit, to, value, data, v, r, s, type } = txData;
      this._type = Number(bytesToBigInt(toBytes4(type)));
      this.txOptions = opts;
      const toB = toBytes4(to === "" ? "0x" : to);
      const vB = toBytes4(v);
      const rB = toBytes4(r);
      const sB = toBytes4(s);
      this.nonce = bytesToBigInt(toBytes4(nonce));
      this.gasLimit = bytesToBigInt(toBytes4(gasLimit));
      this.to = toB.length > 0 ? new Address(toB) : void 0;
      this.value = bytesToBigInt(toBytes4(value));
      this.data = toBytes4(data === "" ? "0x" : data);
      this.v = vB.length > 0 ? bytesToBigInt(vB) : void 0;
      this.r = rB.length > 0 ? bytesToBigInt(rB) : void 0;
      this.s = sB.length > 0 ? bytesToBigInt(sB) : void 0;
      this._validateCannotExceedMaxInteger({ value: this.value, r: this.r, s: this.s });
      this._validateCannotExceedMaxInteger({ gasLimit: this.gasLimit }, 64);
      this._validateCannotExceedMaxInteger({ nonce: this.nonce }, 64, true);
      const createContract = this.to === void 0 || this.to === null;
      const allowUnlimitedInitCodeSize = opts.allowUnlimitedInitCodeSize ?? false;
      const common = opts.common ?? this._getCommon();
      if (createContract && common.isActivatedEIP(3860) && allowUnlimitedInitCodeSize === false) {
        checkMaxInitCodeSize(common, this.data.length);
      }
    }
    /**
     * Returns the transaction type.
     *
     * Note: legacy txs will return tx type `0`.
     */
    get type() {
      return this._type;
    }
    /**
     * Checks if a tx type defining capability is active
     * on a tx, for example the EIP-1559 fee market mechanism
     * or the EIP-2930 access list feature.
     *
     * Note that this is different from the tx type itself,
     * so EIP-2930 access lists can very well be active
     * on an EIP-1559 tx for example.
     *
     * This method can be useful for feature checks if the
     * tx type is unknown (e.g. when instantiated with
     * the tx factory).
     *
     * See `Capabilities` in the `types` module for a reference
     * on all supported capabilities.
     */
    supports(capability) {
      return this.activeCapabilities.includes(capability);
    }
    /**
     * Validates the transaction signature and minimum gas requirements.
     * @returns {string[]} an array of error strings
     */
    getValidationErrors() {
      const errors = [];
      if (this.isSigned() && !this.verifySignature()) {
        errors.push("Invalid Signature");
      }
      if (this.getBaseFee() > this.gasLimit) {
        errors.push(`gasLimit is too low. given ${this.gasLimit}, need at least ${this.getBaseFee()}`);
      }
      return errors;
    }
    /**
     * Validates the transaction signature and minimum gas requirements.
     * @returns {boolean} true if the transaction is valid, false otherwise
     */
    isValid() {
      const errors = this.getValidationErrors();
      return errors.length === 0;
    }
    /**
     * The minimum amount of gas the tx must have (DataFee + TxFee + Creation Fee)
     */
    getBaseFee() {
      const txFee = this.common.param("gasPrices", "tx");
      let fee = this.getDataFee();
      if (txFee)
        fee += txFee;
      if (this.common.gteHardfork("homestead") && this.toCreationAddress()) {
        const txCreationFee = this.common.param("gasPrices", "txCreation");
        if (txCreationFee)
          fee += txCreationFee;
      }
      return fee;
    }
    /**
     * The amount of gas paid for the data in this tx
     */
    getDataFee() {
      const txDataZero = this.common.param("gasPrices", "txDataZero");
      const txDataNonZero = this.common.param("gasPrices", "txDataNonZero");
      let cost = BIGINT_02;
      for (let i = 0; i < this.data.length; i++) {
        this.data[i] === 0 ? cost += txDataZero : cost += txDataNonZero;
      }
      if ((this.to === void 0 || this.to === null) && this.common.isActivatedEIP(3860)) {
        const dataLength = BigInt(Math.ceil(this.data.length / 32));
        const initCodeCost = this.common.param("gasPrices", "initCodeWordCost") * dataLength;
        cost += initCodeCost;
      }
      return cost;
    }
    /**
     * If the tx's `to` is to the creation address
     */
    toCreationAddress() {
      return this.to === void 0 || this.to.bytes.length === 0;
    }
    isSigned() {
      const { v, r, s } = this;
      if (v === void 0 || r === void 0 || s === void 0) {
        return false;
      } else {
        return true;
      }
    }
    /**
     * Determines if the signature is valid
     */
    verifySignature() {
      try {
        const publicKey = this.getSenderPublicKey();
        return unpadBytes(publicKey).length !== 0;
      } catch (e) {
        return false;
      }
    }
    /**
     * Returns the sender's address
     */
    getSenderAddress() {
      return new Address(publicToAddress(this.getSenderPublicKey()));
    }
    /**
     * Signs a transaction.
     *
     * Note that the signed tx is returned as a new object,
     * use as follows:
     * ```javascript
     * const signedTx = tx.sign(privateKey)
     * ```
     */
    sign(privateKey) {
      if (privateKey.length !== 32) {
        const msg = this._errorMsg("Private key must be 32 bytes in length.");
        throw new Error(msg);
      }
      let hackApplied = false;
      if (this.type === TransactionType.Legacy && this.common.gteHardfork("spuriousDragon") && !this.supports(Capability.EIP155ReplayProtection)) {
        this.activeCapabilities.push(Capability.EIP155ReplayProtection);
        hackApplied = true;
      }
      const msgHash = this.getHashedMessageToSign();
      const ecSignFunction = this.common.customCrypto?.ecsign ?? ecsign;
      const { v, r, s } = ecSignFunction(msgHash, privateKey);
      const tx = this.addSignature(v, r, s, true);
      if (hackApplied) {
        const index = this.activeCapabilities.indexOf(Capability.EIP155ReplayProtection);
        if (index > -1) {
          this.activeCapabilities.splice(index, 1);
        }
      }
      return tx;
    }
    /**
     * Returns an object with the JSON representation of the transaction
     */
    toJSON() {
      return {
        type: bigIntToHex(BigInt(this.type)),
        nonce: bigIntToHex(this.nonce),
        gasLimit: bigIntToHex(this.gasLimit),
        to: this.to !== void 0 ? this.to.toString() : void 0,
        value: bigIntToHex(this.value),
        data: bytesToHex5(this.data),
        v: this.v !== void 0 ? bigIntToHex(this.v) : void 0,
        r: this.r !== void 0 ? bigIntToHex(this.r) : void 0,
        s: this.s !== void 0 ? bigIntToHex(this.s) : void 0
      };
    }
    /**
     * Does chain ID checks on common and returns a common
     * to be used on instantiation
     * @hidden
     *
     * @param common - {@link Common} instance from tx options
     * @param chainId - Chain ID from tx options (typed txs) or signature (legacy tx)
     */
    _getCommon(common, chainId) {
      if (chainId !== void 0) {
        const chainIdBigInt = bytesToBigInt(toBytes4(chainId));
        if (common) {
          if (common.chainId() !== chainIdBigInt) {
            const msg = this._errorMsg(`The chain ID does not match the chain ID of Common. Got: ${chainIdBigInt}, expected: ${common.chainId()}`);
            throw new Error(msg);
          }
          return common.copy();
        } else {
          if (Common.isSupportedChainId(chainIdBigInt)) {
            return new Common({ chain: chainIdBigInt });
          } else {
            return Common.custom({
              name: "custom-chain",
              networkId: chainIdBigInt,
              chainId: chainIdBigInt
            }, { baseChain: this.DEFAULT_CHAIN });
          }
        }
      } else {
        return common?.copy() ?? new Common({ chain: this.DEFAULT_CHAIN });
      }
    }
    /**
     * Validates that an object with BigInt values cannot exceed the specified bit limit.
     * @param values Object containing string keys and BigInt values
     * @param bits Number of bits to check (64 or 256)
     * @param cannotEqual Pass true if the number also cannot equal one less the maximum value
     */
    _validateCannotExceedMaxInteger(values, bits = 256, cannotEqual = false) {
      for (const [key, value] of Object.entries(values)) {
        switch (bits) {
          case 64:
            if (cannotEqual) {
              if (value !== void 0 && value >= MAX_UINT64) {
                const msg = this._errorMsg(`${key} cannot equal or exceed MAX_UINT64 (2^64-1), given ${value}`);
                throw new Error(msg);
              }
            } else {
              if (value !== void 0 && value > MAX_UINT64) {
                const msg = this._errorMsg(`${key} cannot exceed MAX_UINT64 (2^64-1), given ${value}`);
                throw new Error(msg);
              }
            }
            break;
          case 256:
            if (cannotEqual) {
              if (value !== void 0 && value >= MAX_INTEGER) {
                const msg = this._errorMsg(`${key} cannot equal or exceed MAX_INTEGER (2^256-1), given ${value}`);
                throw new Error(msg);
              }
            } else {
              if (value !== void 0 && value > MAX_INTEGER) {
                const msg = this._errorMsg(`${key} cannot exceed MAX_INTEGER (2^256-1), given ${value}`);
                throw new Error(msg);
              }
            }
            break;
          default: {
            const msg = this._errorMsg("unimplemented bits value");
            throw new Error(msg);
          }
        }
      }
    }
    static _validateNotArray(values) {
      const txDataKeys = [
        "nonce",
        "gasPrice",
        "gasLimit",
        "to",
        "value",
        "data",
        "v",
        "r",
        "s",
        "type",
        "baseFee",
        "maxFeePerGas",
        "chainId"
      ];
      for (const [key, value] of Object.entries(values)) {
        if (txDataKeys.includes(key)) {
          if (Array.isArray(value)) {
            throw new Error(`${key} cannot be an array`);
          }
        }
      }
    }
    /**
     * Returns the shared error postfix part for _error() method
     * tx type implementations.
     */
    _getSharedErrorPostfix() {
      let hash3 = "";
      try {
        hash3 = this.isSigned() ? bytesToHex5(this.hash()) : "not available (unsigned)";
      } catch (e) {
        hash3 = "error";
      }
      let isSigned = "";
      try {
        isSigned = this.isSigned().toString();
      } catch (e) {
        hash3 = "error";
      }
      let hf = "";
      try {
        hf = this.common.hardfork();
      } catch (e) {
        hf = "error";
      }
      let postfix = `tx type=${this.type} hash=${hash3} nonce=${this.nonce} value=${this.value} `;
      postfix += `signed=${isSigned} hf=${hf}`;
      return postfix;
    }
  };

  // node_modules/@ethereumjs/tx/dist/esm/capabilities/eip1559.js
  function getUpfrontCost(tx, baseFee) {
    const prio = tx.maxPriorityFeePerGas;
    const maxBase = tx.maxFeePerGas - baseFee;
    const inclusionFeePerGas = prio < maxBase ? prio : maxBase;
    const gasPrice = inclusionFeePerGas + baseFee;
    return tx.gasLimit * gasPrice + tx.value;
  }
  function getEffectivePriorityFee(tx, baseFee) {
    if (baseFee === void 0 || baseFee > tx.maxFeePerGas) {
      throw new Error("Tx cannot pay baseFee");
    }
    const remainingFee = tx.maxFeePerGas - baseFee;
    return tx.maxPriorityFeePerGas < remainingFee ? tx.maxPriorityFeePerGas : remainingFee;
  }

  // node_modules/@ethereumjs/tx/dist/esm/capabilities/legacy.js
  function errorMsg(tx, msg) {
    return `${msg} (${tx.errorStr()})`;
  }
  function getDataFee(tx, extraCost) {
    if (tx.cache.dataFee && tx.cache.dataFee.hardfork === tx.common.hardfork()) {
      return tx.cache.dataFee.value;
    }
    const cost = BaseTransaction.prototype.getDataFee.bind(tx)() + (extraCost ?? 0n);
    if (Object.isFrozen(tx)) {
      tx.cache.dataFee = {
        value: cost,
        hardfork: tx.common.hardfork()
      };
    }
    return cost;
  }
  function hash2(tx) {
    if (!tx.isSigned()) {
      const msg = errorMsg(tx, "Cannot call hash method if transaction is not signed");
      throw new Error(msg);
    }
    const keccakFunction = tx.common.customCrypto.keccak256 ?? keccak256;
    if (Object.isFrozen(tx)) {
      if (!tx.cache.hash) {
        tx.cache.hash = keccakFunction(tx.serialize());
      }
      return tx.cache.hash;
    }
    return keccakFunction(tx.serialize());
  }
  function validateHighS(tx) {
    const { s } = tx;
    if (tx.common.gteHardfork("homestead") && s !== void 0 && s > SECP256K1_ORDER_DIV_2) {
      const msg = errorMsg(tx, "Invalid Signature: s-values greater than secp256k1n/2 are considered invalid");
      throw new Error(msg);
    }
  }
  function getSenderPublicKey(tx) {
    if (tx.cache.senderPubKey !== void 0) {
      return tx.cache.senderPubKey;
    }
    const msgHash = tx.getMessageToVerifySignature();
    const { v, r, s } = tx;
    validateHighS(tx);
    try {
      const ecrecoverFunction = tx.common.customCrypto.ecrecover ?? ecrecover;
      const sender = ecrecoverFunction(msgHash, v, bigIntToUnpaddedBytes(r), bigIntToUnpaddedBytes(s), tx.supports(Capability.EIP155ReplayProtection) ? tx.common.chainId() : void 0);
      if (Object.isFrozen(tx)) {
        tx.cache.senderPubKey = sender;
      }
      return sender;
    } catch (e) {
      const msg = errorMsg(tx, "Invalid Signature");
      throw new Error(msg);
    }
  }
  function getEffectivePriorityFee2(gasPrice, baseFee) {
    if (baseFee !== void 0 && baseFee > gasPrice) {
      throw new Error("Tx cannot pay baseFee");
    }
    if (baseFee === void 0) {
      return gasPrice;
    }
    return gasPrice - baseFee;
  }

  // node_modules/@ethereumjs/tx/dist/esm/capabilities/eip2718.js
  function getHashedMessageToSign(tx) {
    const keccakFunction = tx.common.customCrypto.keccak256 ?? keccak256;
    return keccakFunction(tx.getMessageToSign());
  }
  function serialize(tx, base) {
    return concatBytes5(txTypeBytes(tx.type), RLP.encode(base ?? tx.raw()));
  }
  function validateYParity(tx) {
    const { v } = tx;
    if (v !== void 0 && v !== BIGINT_02 && v !== BIGINT_1) {
      const msg = errorMsg(tx, "The y-parity of the transaction should either be 0 or 1");
      throw new Error(msg);
    }
  }

  // node_modules/@ethereumjs/tx/dist/esm/capabilities/eip2930.js
  function getDataFee2(tx) {
    return getDataFee(tx, BigInt(AccessLists.getDataFeeEIP2930(tx.accessList, tx.common)));
  }

  // node_modules/@ethereumjs/tx/dist/esm/eip1559Transaction.js
  var FeeMarketEIP1559Transaction = class _FeeMarketEIP1559Transaction extends BaseTransaction {
    /**
     * This constructor takes the values, validates them, assigns them and freezes the object.
     *
     * It is not recommended to use this constructor directly. Instead use
     * the static factory methods to assist in creating a Transaction object from
     * varying data types.
     */
    constructor(txData, opts = {}) {
      super({ ...txData, type: TransactionType.FeeMarketEIP1559 }, opts);
      const { chainId, accessList, maxFeePerGas, maxPriorityFeePerGas } = txData;
      this.common = this._getCommon(opts.common, chainId);
      this.chainId = this.common.chainId();
      if (!this.common.isActivatedEIP(1559)) {
        throw new Error("EIP-1559 not enabled on Common");
      }
      this.activeCapabilities = this.activeCapabilities.concat([1559, 2718, 2930]);
      const accessListData = AccessLists.getAccessListData(accessList ?? []);
      this.accessList = accessListData.accessList;
      this.AccessListJSON = accessListData.AccessListJSON;
      AccessLists.verifyAccessList(this.accessList);
      this.maxFeePerGas = bytesToBigInt(toBytes4(maxFeePerGas));
      this.maxPriorityFeePerGas = bytesToBigInt(toBytes4(maxPriorityFeePerGas));
      this._validateCannotExceedMaxInteger({
        maxFeePerGas: this.maxFeePerGas,
        maxPriorityFeePerGas: this.maxPriorityFeePerGas
      });
      BaseTransaction._validateNotArray(txData);
      if (this.gasLimit * this.maxFeePerGas > MAX_INTEGER) {
        const msg = this._errorMsg("gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)");
        throw new Error(msg);
      }
      if (this.maxFeePerGas < this.maxPriorityFeePerGas) {
        const msg = this._errorMsg("maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)");
        throw new Error(msg);
      }
      validateYParity(this);
      validateHighS(this);
      const freeze = opts?.freeze ?? true;
      if (freeze) {
        Object.freeze(this);
      }
    }
    /**
     * Instantiate a transaction from a data dictionary.
     *
     * Format: { chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,
     * accessList, v, r, s }
     *
     * Notes:
     * - `chainId` will be set automatically if not provided
     * - All parameters are optional and have some basic default values
     */
    static fromTxData(txData, opts = {}) {
      return new _FeeMarketEIP1559Transaction(txData, opts);
    }
    /**
     * Instantiate a transaction from the serialized tx.
     *
     * Format: `0x02 || rlp([chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,
     * accessList, signatureYParity, signatureR, signatureS])`
     */
    static fromSerializedTx(serialized, opts = {}) {
      if (equalsBytes(serialized.subarray(0, 1), txTypeBytes(TransactionType.FeeMarketEIP1559)) === false) {
        throw new Error(`Invalid serialized tx input: not an EIP-1559 transaction (wrong tx type, expected: ${TransactionType.FeeMarketEIP1559}, received: ${bytesToHex5(serialized.subarray(0, 1))}`);
      }
      const values = RLP.decode(serialized.subarray(1));
      if (!Array.isArray(values)) {
        throw new Error("Invalid serialized tx input: must be array");
      }
      return _FeeMarketEIP1559Transaction.fromValuesArray(values, opts);
    }
    /**
     * Create a transaction from a values array.
     *
     * Format: `[chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,
     * accessList, signatureYParity, signatureR, signatureS]`
     */
    static fromValuesArray(values, opts = {}) {
      if (values.length !== 9 && values.length !== 12) {
        throw new Error("Invalid EIP-1559 transaction. Only expecting 9 values (for unsigned tx) or 12 values (for signed tx).");
      }
      const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data, accessList, v, r, s] = values;
      this._validateNotArray({ chainId, v });
      validateNoLeadingZeroes({ nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, value, v, r, s });
      return new _FeeMarketEIP1559Transaction({
        chainId: bytesToBigInt(chainId),
        nonce,
        maxPriorityFeePerGas,
        maxFeePerGas,
        gasLimit,
        to,
        value,
        data,
        accessList: accessList ?? [],
        v: v !== void 0 ? bytesToBigInt(v) : void 0,
        r,
        s
      }, opts);
    }
    /**
     * The amount of gas paid for the data in this tx
     */
    getDataFee() {
      return getDataFee2(this);
    }
    /**
     * Returns the minimum of calculated priority fee (from maxFeePerGas and baseFee) and maxPriorityFeePerGas
     * @param baseFee Base fee retrieved from block
     */
    getEffectivePriorityFee(baseFee) {
      return getEffectivePriorityFee(this, baseFee);
    }
    /**
     * The up front amount that an account must have for this transaction to be valid
     * @param baseFee The base fee of the block (will be set to 0 if not provided)
     */
    getUpfrontCost(baseFee = BIGINT_02) {
      return getUpfrontCost(this, baseFee);
    }
    /**
     * Returns a Uint8Array Array of the raw Bytes of the EIP-1559 transaction, in order.
     *
     * Format: `[chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,
     * accessList, signatureYParity, signatureR, signatureS]`
     *
     * Use {@link FeeMarketEIP1559Transaction.serialize} to add a transaction to a block
     * with {@link Block.fromValuesArray}.
     *
     * For an unsigned tx this method uses the empty Bytes values for the
     * signature parameters `v`, `r` and `s` for encoding. For an EIP-155 compliant
     * representation for external signing use {@link FeeMarketEIP1559Transaction.getMessageToSign}.
     */
    raw() {
      return [
        bigIntToUnpaddedBytes(this.chainId),
        bigIntToUnpaddedBytes(this.nonce),
        bigIntToUnpaddedBytes(this.maxPriorityFeePerGas),
        bigIntToUnpaddedBytes(this.maxFeePerGas),
        bigIntToUnpaddedBytes(this.gasLimit),
        this.to !== void 0 ? this.to.bytes : new Uint8Array(0),
        bigIntToUnpaddedBytes(this.value),
        this.data,
        this.accessList,
        this.v !== void 0 ? bigIntToUnpaddedBytes(this.v) : new Uint8Array(0),
        this.r !== void 0 ? bigIntToUnpaddedBytes(this.r) : new Uint8Array(0),
        this.s !== void 0 ? bigIntToUnpaddedBytes(this.s) : new Uint8Array(0)
      ];
    }
    /**
     * Returns the serialized encoding of the EIP-1559 transaction.
     *
     * Format: `0x02 || rlp([chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data,
     * accessList, signatureYParity, signatureR, signatureS])`
     *
     * Note that in contrast to the legacy tx serialization format this is not
     * valid RLP any more due to the raw tx type preceding and concatenated to
     * the RLP encoding of the values.
     */
    serialize() {
      return serialize(this);
    }
    /**
     * Returns the raw serialized unsigned tx, which can be used
     * to sign the transaction (e.g. for sending to a hardware wallet).
     *
     * Note: in contrast to the legacy tx the raw message format is already
     * serialized and doesn't need to be RLP encoded any more.
     *
     * ```javascript
     * const serializedMessage = tx.getMessageToSign() // use this for the HW wallet input
     * ```
     */
    getMessageToSign() {
      return serialize(this, this.raw().slice(0, 9));
    }
    /**
     * Returns the hashed serialized unsigned tx, which can be used
     * to sign the transaction (e.g. for sending to a hardware wallet).
     *
     * Note: in contrast to the legacy tx the raw message format is already
     * serialized and doesn't need to be RLP encoded any more.
     */
    getHashedMessageToSign() {
      return getHashedMessageToSign(this);
    }
    /**
     * Computes a sha3-256 hash of the serialized tx.
     *
     * This method can only be used for signed txs (it throws otherwise).
     * Use {@link FeeMarketEIP1559Transaction.getMessageToSign} to get a tx hash for the purpose of signing.
     */
    hash() {
      return hash2(this);
    }
    /**
     * Computes a sha3-256 hash which can be used to verify the signature
     */
    getMessageToVerifySignature() {
      return this.getHashedMessageToSign();
    }
    /**
     * Returns the public key of the sender
     */
    getSenderPublicKey() {
      return getSenderPublicKey(this);
    }
    addSignature(v, r, s, convertV = false) {
      r = toBytes4(r);
      s = toBytes4(s);
      const opts = { ...this.txOptions, common: this.common };
      return _FeeMarketEIP1559Transaction.fromTxData({
        chainId: this.chainId,
        nonce: this.nonce,
        maxPriorityFeePerGas: this.maxPriorityFeePerGas,
        maxFeePerGas: this.maxFeePerGas,
        gasLimit: this.gasLimit,
        to: this.to,
        value: this.value,
        data: this.data,
        accessList: this.accessList,
        v: convertV ? v - BIGINT_27 : v,
        r: bytesToBigInt(r),
        s: bytesToBigInt(s)
      }, opts);
    }
    /**
     * Returns an object with the JSON representation of the transaction
     */
    toJSON() {
      const accessListJSON = AccessLists.getAccessListJSON(this.accessList);
      const baseJson = super.toJSON();
      return {
        ...baseJson,
        chainId: bigIntToHex(this.chainId),
        maxPriorityFeePerGas: bigIntToHex(this.maxPriorityFeePerGas),
        maxFeePerGas: bigIntToHex(this.maxFeePerGas),
        accessList: accessListJSON
      };
    }
    /**
     * Return a compact error string representation of the object
     */
    errorStr() {
      let errorStr = this._getSharedErrorPostfix();
      errorStr += ` maxFeePerGas=${this.maxFeePerGas} maxPriorityFeePerGas=${this.maxPriorityFeePerGas}`;
      return errorStr;
    }
    /**
     * Internal helper function to create an annotated error message
     *
     * @param msg Base error message
     * @hidden
     */
    _errorMsg(msg) {
      return errorMsg(this, msg);
    }
  };

  // node_modules/@ethereumjs/tx/dist/esm/legacyTransaction.js
  function meetsEIP155(_v, chainId) {
    const v = Number(_v);
    const chainIdDoubled = Number(chainId) * 2;
    return v === chainIdDoubled + 35 || v === chainIdDoubled + 36;
  }
  var LegacyTransaction = class _LegacyTransaction extends BaseTransaction {
    /**
     * This constructor takes the values, validates them, assigns them and freezes the object.
     *
     * It is not recommended to use this constructor directly. Instead use
     * the static factory methods to assist in creating a Transaction object from
     * varying data types.
     */
    constructor(txData, opts = {}) {
      super({ ...txData, type: TransactionType.Legacy }, opts);
      this.common = this._validateTxV(this.v, opts.common);
      this.keccakFunction = this.common.customCrypto.keccak256 ?? keccak256;
      this.gasPrice = bytesToBigInt(toBytes4(txData.gasPrice));
      if (this.gasPrice * this.gasLimit > MAX_INTEGER) {
        const msg = this._errorMsg("gas limit * gasPrice cannot exceed MAX_INTEGER (2^256-1)");
        throw new Error(msg);
      }
      this._validateCannotExceedMaxInteger({ gasPrice: this.gasPrice });
      BaseTransaction._validateNotArray(txData);
      if (this.common.gteHardfork("spuriousDragon")) {
        if (!this.isSigned()) {
          this.activeCapabilities.push(Capability.EIP155ReplayProtection);
        } else {
          if (meetsEIP155(this.v, this.common.chainId())) {
            this.activeCapabilities.push(Capability.EIP155ReplayProtection);
          }
        }
      }
      const freeze = opts?.freeze ?? true;
      if (freeze) {
        Object.freeze(this);
      }
    }
    /**
     * Instantiate a transaction from a data dictionary.
     *
     * Format: { nonce, gasPrice, gasLimit, to, value, data, v, r, s }
     *
     * Notes:
     * - All parameters are optional and have some basic default values
     */
    static fromTxData(txData, opts = {}) {
      return new _LegacyTransaction(txData, opts);
    }
    /**
     * Instantiate a transaction from the serialized tx.
     *
     * Format: `rlp([nonce, gasPrice, gasLimit, to, value, data, v, r, s])`
     */
    static fromSerializedTx(serialized, opts = {}) {
      const values = RLP.decode(serialized);
      if (!Array.isArray(values)) {
        throw new Error("Invalid serialized tx input. Must be array");
      }
      return this.fromValuesArray(values, opts);
    }
    /**
     * Create a transaction from a values array.
     *
     * Format: `[nonce, gasPrice, gasLimit, to, value, data, v, r, s]`
     */
    static fromValuesArray(values, opts = {}) {
      if (values.length !== 6 && values.length !== 9) {
        throw new Error("Invalid transaction. Only expecting 6 values (for unsigned tx) or 9 values (for signed tx).");
      }
      const [nonce, gasPrice, gasLimit, to, value, data, v, r, s] = values;
      validateNoLeadingZeroes({ nonce, gasPrice, gasLimit, value, v, r, s });
      return new _LegacyTransaction({
        nonce,
        gasPrice,
        gasLimit,
        to,
        value,
        data,
        v,
        r,
        s
      }, opts);
    }
    getEffectivePriorityFee(baseFee) {
      return getEffectivePriorityFee2(this.gasPrice, baseFee);
    }
    /**
     * Returns a Uint8Array Array of the raw Bytes of the legacy transaction, in order.
     *
     * Format: `[nonce, gasPrice, gasLimit, to, value, data, v, r, s]`
     *
     * For legacy txs this is also the correct format to add transactions
     * to a block with {@link Block.fromValuesArray} (use the `serialize()` method
     * for typed txs).
     *
     * For an unsigned tx this method returns the empty Bytes values
     * for the signature parameters `v`, `r` and `s`. For an EIP-155 compliant
     * representation have a look at {@link Transaction.getMessageToSign}.
     */
    raw() {
      return [
        bigIntToUnpaddedBytes(this.nonce),
        bigIntToUnpaddedBytes(this.gasPrice),
        bigIntToUnpaddedBytes(this.gasLimit),
        this.to !== void 0 ? this.to.bytes : new Uint8Array(0),
        bigIntToUnpaddedBytes(this.value),
        this.data,
        this.v !== void 0 ? bigIntToUnpaddedBytes(this.v) : new Uint8Array(0),
        this.r !== void 0 ? bigIntToUnpaddedBytes(this.r) : new Uint8Array(0),
        this.s !== void 0 ? bigIntToUnpaddedBytes(this.s) : new Uint8Array(0)
      ];
    }
    /**
     * Returns the serialized encoding of the legacy transaction.
     *
     * Format: `rlp([nonce, gasPrice, gasLimit, to, value, data, v, r, s])`
     *
     * For an unsigned tx this method uses the empty Uint8Array values for the
     * signature parameters `v`, `r` and `s` for encoding. For an EIP-155 compliant
     * representation for external signing use {@link Transaction.getMessageToSign}.
     */
    serialize() {
      return RLP.encode(this.raw());
    }
    /**
     * Returns the raw unsigned tx, which can be used
     * to sign the transaction (e.g. for sending to a hardware wallet).
     *
     * Note: the raw message message format for the legacy tx is not RLP encoded
     * and you might need to do yourself with:
     *
     * ```javascript
     * import { RLP } from '@ethereumjs/rlp'
     * const message = tx.getMessageToSign()
     * const serializedMessage = RLP.encode(message)) // use this for the HW wallet input
     * ```
     */
    getMessageToSign() {
      const message = [
        bigIntToUnpaddedBytes(this.nonce),
        bigIntToUnpaddedBytes(this.gasPrice),
        bigIntToUnpaddedBytes(this.gasLimit),
        this.to !== void 0 ? this.to.bytes : new Uint8Array(0),
        bigIntToUnpaddedBytes(this.value),
        this.data
      ];
      if (this.supports(Capability.EIP155ReplayProtection)) {
        message.push(bigIntToUnpaddedBytes(this.common.chainId()));
        message.push(unpadBytes(toBytes4(0)));
        message.push(unpadBytes(toBytes4(0)));
      }
      return message;
    }
    /**
     * Returns the hashed serialized unsigned tx, which can be used
     * to sign the transaction (e.g. for sending to a hardware wallet).
     */
    getHashedMessageToSign() {
      const message = this.getMessageToSign();
      return this.keccakFunction(RLP.encode(message));
    }
    /**
     * The amount of gas paid for the data in this tx
     */
    getDataFee() {
      return getDataFee(this);
    }
    /**
     * The up front amount that an account must have for this transaction to be valid
     */
    getUpfrontCost() {
      return this.gasLimit * this.gasPrice + this.value;
    }
    /**
     * Computes a sha3-256 hash of the serialized tx.
     *
     * This method can only be used for signed txs (it throws otherwise).
     * Use {@link Transaction.getMessageToSign} to get a tx hash for the purpose of signing.
     */
    hash() {
      return hash2(this);
    }
    /**
     * Computes a sha3-256 hash which can be used to verify the signature
     */
    getMessageToVerifySignature() {
      if (!this.isSigned()) {
        const msg = this._errorMsg("This transaction is not signed");
        throw new Error(msg);
      }
      return this.getHashedMessageToSign();
    }
    /**
     * Returns the public key of the sender
     */
    getSenderPublicKey() {
      return getSenderPublicKey(this);
    }
    addSignature(v, r, s, convertV = false) {
      r = toBytes4(r);
      s = toBytes4(s);
      if (convertV && this.supports(Capability.EIP155ReplayProtection)) {
        v += this.common.chainId() * BIGINT_2 + BIGINT_8;
      }
      const opts = { ...this.txOptions, common: this.common };
      return _LegacyTransaction.fromTxData({
        nonce: this.nonce,
        gasPrice: this.gasPrice,
        gasLimit: this.gasLimit,
        to: this.to,
        value: this.value,
        data: this.data,
        v,
        r: bytesToBigInt(r),
        s: bytesToBigInt(s)
      }, opts);
    }
    /**
     * Returns an object with the JSON representation of the transaction.
     */
    toJSON() {
      const baseJson = super.toJSON();
      return {
        ...baseJson,
        gasPrice: bigIntToHex(this.gasPrice)
      };
    }
    /**
     * Validates tx's `v` value
     */
    _validateTxV(_v, common) {
      let chainIdBigInt;
      const v = _v !== void 0 ? Number(_v) : void 0;
      if (v !== void 0) {
        if (v < 37 && v !== 27 && v !== 28) {
          throw new Error(`Legacy txs need either v = 27/28 or v >= 37 (EIP-155 replay protection), got v = ${v}`);
        }
      }
      if (v !== void 0 && v !== 0 && (!common || common.gteHardfork("spuriousDragon")) && v !== 27 && v !== 28) {
        if (common) {
          if (!meetsEIP155(BigInt(v), common.chainId())) {
            throw new Error(`Incompatible EIP155-based V ${v} and chain id ${common.chainId()}. See the Common parameter of the Transaction constructor to set the chain id.`);
          }
        } else {
          let numSub;
          if ((v - 35) % 2 === 0) {
            numSub = 35;
          } else {
            numSub = 36;
          }
          chainIdBigInt = BigInt(v - numSub) / BIGINT_2;
        }
      }
      return this._getCommon(common, chainIdBigInt);
    }
    /**
     * Return a compact error string representation of the object
     */
    errorStr() {
      let errorStr = this._getSharedErrorPostfix();
      errorStr += ` gasPrice=${this.gasPrice}`;
      return errorStr;
    }
    /**
     * Internal helper function to create an annotated error message
     *
     * @param msg Base error message
     * @hidden
     */
    _errorMsg(msg) {
      return errorMsg(this, msg);
    }
  };

  // src/wallet.js
  function stripHexPrefix3(str) {
    return typeof str === "string" && str.startsWith("0x") ? str.slice(2) : str;
  }
  function addHexPrefix2(str) {
    return typeof str === "string" && !str.startsWith("0x") ? "0x" + str : str;
  }
  function generateWallet() {
    const privateKey = getRandomBytesSync(32);
    return privateKeyToWallet(privateKey);
  }
  function privateKeyToWallet(privateKey) {
    const privKeyBytes = typeof privateKey === "string" ? hexToBytes2(stripHexPrefix3(privateKey)) : privateKey;
    const publicKey = secp256k1.getPublicKey(privKeyBytes, false).slice(1);
    const addressBytes = keccak256(publicKey).slice(-20);
    const address = toChecksumAddress(addHexPrefix2(bytesToHex(addressBytes)));
    return {
      address,
      privateKey: addHexPrefix2(bytesToHex(privKeyBytes)),
      publicKey: addHexPrefix2(bytesToHex(publicKey))
    };
  }
  function createMnemonic(wordCount = 12) {
    const strength = { 12: 128, 15: 160, 18: 192, 21: 224, 24: 256 }[wordCount] || 128;
    return generateMnemonic(wordlist, strength);
  }
  function validateMnemonicPhrase(mnemonic) {
    return validateMnemonic(mnemonic, wordlist);
  }
  function mnemonicToWallet(mnemonic, passphrase = "", path = "m/44'/60'/0'/0/0") {
    const seed = mnemonicToSeedSync(mnemonic, passphrase);
    const hdKey = HDKey.fromMasterSeed(seed);
    const derived = hdKey.derive(path);
    if (!derived.privateKey) throw new Error("Failed to derive private key");
    const wallet = privateKeyToWallet(derived.privateKey);
    return {
      ...wallet,
      mnemonic,
      path
    };
  }
  function deriveAccounts(mnemonic, count = 10, passphrase = "", basePath = "m/44'/60'/0'/0") {
    const seed = mnemonicToSeedSync(mnemonic, passphrase);
    const hdKey = HDKey.fromMasterSeed(seed);
    const accounts = [];
    for (let i = 0; i < count; i++) {
      const path = `${basePath}/${i}`;
      const derived = hdKey.derive(path);
      if (!derived.privateKey) continue;
      const wallet = privateKeyToWallet(derived.privateKey);
      accounts.push({ ...wallet, path, index: i });
    }
    return accounts;
  }
  function signMessage(message, privateKey) {
    const privKeyBytes = typeof privateKey === "string" ? hexToBytes2(stripHexPrefix3(privateKey)) : privateKey;
    const messageBytes = typeof message === "string" ? utf8ToBytes(message) : message;
    const prefix = utf8ToBytes(`Ethereum Signed Message:
${messageBytes.length}`);
    const prefixedMessage = concatBytes(prefix, messageBytes);
    const messageHash = keccak256(prefixedMessage);
    const signature = secp256k1.sign(messageHash, privKeyBytes);
    const r = signature.r.toString(16).padStart(64, "0");
    const s = signature.s.toString(16).padStart(64, "0");
    const v = signature.recovery + 27;
    return {
      message: typeof message === "string" ? message : bytesToHex(message),
      messageHash: addHexPrefix2(bytesToHex(messageHash)),
      signature: addHexPrefix2(r + s + v.toString(16)),
      r: addHexPrefix2(r),
      s: addHexPrefix2(s),
      v
    };
  }
  function verifyMessage(message, signature, expectedAddress) {
    const sigBytes = hexToBytes2(stripHexPrefix3(signature));
    const r = sigBytes.slice(0, 32);
    const s = sigBytes.slice(32, 64);
    const v = sigBytes[64];
    const messageBytes = typeof message === "string" ? utf8ToBytes(message) : message;
    const prefix = utf8ToBytes(`Ethereum Signed Message:
${messageBytes.length}`);
    const prefixedMessage = concatBytes(prefix, messageBytes);
    const messageHash = keccak256(prefixedMessage);
    const sig = secp256k1.Signature.fromCompact(concatBytes(r, s)).addRecoveryBit(v - 27);
    const publicKey = sig.recoverPublicKey(messageHash).toRawBytes(false).slice(1);
    const addressBytes = keccak256(publicKey).slice(-20);
    const recoveredAddress = toChecksumAddress(addHexPrefix2(bytesToHex(addressBytes)));
    return {
      message: typeof message === "string" ? message : bytesToHex5(message),
      expectedAddress,
      recoveredAddress,
      isValid: recoveredAddress.toLowerCase() === expectedAddress.toLowerCase()
    };
  }
  function signTransaction(txParams, privateKey, chainId = 1) {
    const privKeyBytes = typeof privateKey === "string" ? hexToBytes2(stripHexPrefix3(privateKey)) : privateKey;
    const common = Common.custom({ chainId: BigInt(chainId) });
    let tx;
    if (txParams.maxFeePerGas) {
      tx = FeeMarketEIP1559Transaction.fromTxData({
        to: txParams.to,
        value: BigInt(txParams.value || 0),
        nonce: BigInt(txParams.nonce || 0),
        gasLimit: BigInt(txParams.gas || 21e3),
        maxFeePerGas: BigInt(txParams.maxFeePerGas),
        maxPriorityFeePerGas: BigInt(txParams.maxPriorityFeePerGas || 0),
        data: txParams.data || "0x",
        chainId: BigInt(chainId)
      }, { common });
    } else {
      tx = LegacyTransaction.fromTxData({
        to: txParams.to,
        value: BigInt(txParams.value || 0),
        nonce: BigInt(txParams.nonce || 0),
        gasLimit: BigInt(txParams.gas || 21e3),
        gasPrice: BigInt(txParams.gasPrice),
        data: txParams.data || "0x"
      }, { common });
    }
    const signedTx = tx.sign(privKeyBytes);
    const serialized = signedTx.serialize();
    return {
      rawTransaction: addHexPrefix2(bytesToHex(serialized)),
      hash: addHexPrefix2(bytesToHex(signedTx.hash())),
      r: addHexPrefix2(signedTx.r.toString(16).padStart(64, "0")),
      s: addHexPrefix2(signedTx.s.toString(16).padStart(64, "0")),
      v: Number(signedTx.v)
    };
  }
  async function encryptKeystore(privateKey, password) {
    const privKeyBytes = typeof privateKey === "string" ? hexToBytes2(stripHexPrefix3(privateKey)) : privateKey;
    const wallet = privateKeyToWallet(privKeyBytes);
    const salt = getRandomBytesSync(32);
    const iv = getRandomBytesSync(16);
    const uuid = getRandomBytesSync(16);
    const derivedKey = await scrypt2(
      utf8ToBytes(password),
      salt,
      { N: 262144, r: 8, p: 1, dkLen: 32 }
    );
    const encryptionKey = derivedKey.slice(0, 16);
    const cryptoKey = await crypto.subtle.importKey(
      "raw",
      encryptionKey,
      { name: "AES-CTR" },
      false,
      ["encrypt"]
    );
    const ciphertext = new Uint8Array(await crypto.subtle.encrypt(
      { name: "AES-CTR", counter: iv, length: 64 },
      cryptoKey,
      privKeyBytes
    ));
    const macData = concatBytes(derivedKey.slice(16), ciphertext);
    const mac = keccak256(macData);
    const id = bytesToHex(uuid);
    return {
      version: 3,
      id: `${id.slice(0, 8)}-${id.slice(8, 12)}-${id.slice(12, 16)}-${id.slice(16, 20)}-${id.slice(20)}`,
      address: wallet.address.slice(2).toLowerCase(),
      crypto: {
        ciphertext: bytesToHex(ciphertext),
        cipherparams: { iv: bytesToHex(iv) },
        cipher: "aes-128-ctr",
        kdf: "scrypt",
        kdfparams: {
          dklen: 32,
          salt: bytesToHex(salt),
          n: 262144,
          r: 8,
          p: 1
        },
        mac: bytesToHex(mac)
      }
    };
  }
  async function decryptKeystore(keystore, password) {
    const ks = typeof keystore === "string" ? JSON.parse(keystore) : keystore;
    const salt = hexToBytes2(ks.crypto.kdfparams.salt);
    const iv = hexToBytes2(ks.crypto.cipherparams.iv);
    const ciphertext = hexToBytes2(ks.crypto.ciphertext);
    let derivedKey;
    if (ks.crypto.kdf === "scrypt") {
      const { n, r, p } = ks.crypto.kdfparams;
      derivedKey = await scrypt2(utf8ToBytes(password), salt, { N: n, r, p, dkLen: 32 });
    } else {
      throw new Error("Unsupported KDF: " + ks.crypto.kdf);
    }
    const macData = concatBytes(derivedKey.slice(16), ciphertext);
    const mac = bytesToHex(keccak256(macData));
    if (mac !== ks.crypto.mac) {
      throw new Error("Invalid password (MAC mismatch)");
    }
    const encryptionKey = derivedKey.slice(0, 16);
    const cryptoKey = await crypto.subtle.importKey(
      "raw",
      encryptionKey,
      { name: "AES-CTR" },
      false,
      ["decrypt"]
    );
    const decrypted = new Uint8Array(await crypto.subtle.decrypt(
      { name: "AES-CTR", counter: iv, length: 64 },
      cryptoKey,
      ciphertext
    ));
    return privateKeyToWallet(decrypted);
  }
  function signTypedData(typedData, privateKey) {
    const privKeyBytes = typeof privateKey === "string" ? hexToBytes2(stripHexPrefix3(privateKey)) : privateKey;
    const hash3 = hashTypedData(typedData);
    const signature = secp256k1.sign(hash3, privKeyBytes);
    const r = signature.r.toString(16).padStart(64, "0");
    const s = signature.s.toString(16).padStart(64, "0");
    const v = signature.recovery + 27;
    return {
      messageHash: addHexPrefix2(bytesToHex(hash3)),
      signature: addHexPrefix2(r + s + v.toString(16)),
      r: addHexPrefix2(r),
      s: addHexPrefix2(s),
      v
    };
  }
  function hashTypedData(typedData) {
    const { domain, types, message, primaryType } = typedData;
    const domainType = [];
    if (domain.name) domainType.push({ name: "name", type: "string" });
    if (domain.version) domainType.push({ name: "version", type: "string" });
    if (domain.chainId !== void 0) domainType.push({ name: "chainId", type: "uint256" });
    if (domain.verifyingContract) domainType.push({ name: "verifyingContract", type: "address" });
    if (domain.salt) domainType.push({ name: "salt", type: "bytes32" });
    const allTypes = { EIP712Domain: domainType, ...types };
    function encodeType(name) {
      const deps = /* @__PURE__ */ new Set();
      function findDeps(t) {
        if (deps.has(t) || !allTypes[t]) return;
        deps.add(t);
        allTypes[t].forEach((f) => {
          const baseType = f.type.replace(/\[\d*\]$/, "");
          if (allTypes[baseType]) findDeps(baseType);
        });
      }
      findDeps(name);
      deps.delete(name);
      const sorted = [name, ...[...deps].sort()];
      return sorted.map((t) => `${t}(${allTypes[t].map((f) => `${f.type} ${f.name}`).join(",")})`).join("");
    }
    function typeHash(name) {
      return keccak256(utf8ToBytes(encodeType(name)));
    }
    function encodeValue(type, value) {
      if (type === "string") return keccak256(utf8ToBytes(value));
      if (type === "bytes") return keccak256(hexToBytes2(stripHexPrefix3(value)));
      if (type === "bool") return new Uint8Array(32).fill(0).map((_, i) => i === 31 ? value ? 1 : 0 : 0);
      if (type === "address") {
        const addr = hexToBytes2(stripHexPrefix3(value).padStart(40, "0"));
        const padded = new Uint8Array(32);
        padded.set(addr, 12);
        return padded;
      }
      if (type.startsWith("uint") || type.startsWith("int")) {
        const n = BigInt(value);
        const hex = n.toString(16).padStart(64, "0");
        return hexToBytes2(hex);
      }
      if (type.startsWith("bytes")) {
        const padded = new Uint8Array(32);
        const data = hexToBytes2(stripHexPrefix3(value));
        padded.set(data.slice(0, 32));
        return padded;
      }
      if (allTypes[type]) return encodeData(type, value);
      return new Uint8Array(32);
    }
    function encodeData(type, data) {
      const values = [typeHash(type)];
      for (const field of allTypes[type]) {
        values.push(encodeValue(field.type, data[field.name]));
      }
      return keccak256(concatBytes(...values));
    }
    const domainSeparator = encodeData("EIP712Domain", domain);
    const structHash = encodeData(primaryType, message);
    return keccak256(concatBytes(
      new Uint8Array([25, 1]),
      domainSeparator,
      structHash
    ));
  }
  function verifyTypedData(typedData, signature, expectedAddress) {
    const hash3 = hashTypedData(typedData);
    const sigBytes = hexToBytes2(stripHexPrefix3(signature));
    const r = sigBytes.slice(0, 32);
    const s = sigBytes.slice(32, 64);
    const v = sigBytes[64];
    const sig = secp256k1.Signature.fromCompact(concatBytes(r, s)).addRecoveryBit(v - 27);
    const publicKey = sig.recoverPublicKey(hash3).toRawBytes(false).slice(1);
    const addressBytes = keccak256(publicKey).slice(-20);
    const recoveredAddress = toChecksumAddress(addHexPrefix2(bytesToHex(addressBytes)));
    return {
      expectedAddress,
      recoveredAddress,
      isValid: recoveredAddress.toLowerCase() === expectedAddress.toLowerCase()
    };
  }
  function checkVanityMatch(address, options) {
    const addr = address.slice(2);
    const check = options.caseSensitive ? addr : addr.toLowerCase();
    if (options.prefix) {
      const p = options.caseSensitive ? options.prefix : options.prefix.toLowerCase();
      if (!check.startsWith(p)) return false;
    }
    if (options.suffix) {
      const s = options.caseSensitive ? options.suffix : options.suffix.toLowerCase();
      if (!check.endsWith(s)) return false;
    }
    if (options.contains) {
      const c = options.caseSensitive ? options.contains : options.contains.toLowerCase();
      if (!check.includes(c)) return false;
    }
    if (options.letters && !/^[a-f]+$/i.test(addr)) return false;
    if (options.numbers && !/^[0-9]+$/.test(addr)) return false;
    if (options.regex) {
      try {
        if (!new RegExp(options.regex, options.caseSensitive ? "" : "i").test(check)) return false;
      } catch {
        return false;
      }
    }
    if (options.mirror) {
      const half = Math.floor(check.length / 2);
      if (check.slice(0, half) !== check.slice(-half).split("").reverse().join("")) return false;
    }
    if (options.doubles) {
      let count = 0;
      for (let i = 0; i < check.length - 1; i += 2) {
        if (check[i] === check[i + 1]) count++;
        else break;
      }
      if (count < 2) return false;
    }
    if (options.zeros && (check.match(/0/g) || []).length < 8) return false;
    if (options.leading && options.leadingCount > 0) {
      const expected = (options.caseSensitive ? options.leading : options.leading.toLowerCase()).repeat(options.leadingCount);
      if (!check.startsWith(expected)) return false;
    }
    return true;
  }
  function calculateContractAddress(deployerAddress, nonce = 0) {
    const addrBytes = hexToBytes2(stripHexPrefix3(deployerAddress));
    const nonceBytes = nonce === 0 ? new Uint8Array([128]) : hexToBytes2(nonce.toString(16).padStart(2, "0"));
    const rlpEncoded = RLP.encode([addrBytes, nonce === 0 ? new Uint8Array() : nonceBytes]);
    const hash3 = keccak256(rlpEncoded);
    return toChecksumAddress(addHexPrefix2(bytesToHex(hash3.slice(-20))));
  }
  function validateAddress(address) {
    if (!address || !address.startsWith("0x") || address.length !== 42) return false;
    return /^0x[0-9a-fA-F]{40}$/.test(address);
  }
  function validatePrivateKey(key) {
    const k = stripHexPrefix3(key);
    if (k.length !== 64) return false;
    return /^[0-9a-fA-F]{64}$/.test(k);
  }
  function validateKeyAddressPair(privateKey, address) {
    if (!validatePrivateKey(privateKey)) return false;
    const wallet = privateKeyToWallet(privateKey);
    return wallet.address.toLowerCase() === address.toLowerCase();
  }
  return __toCommonJS(wallet_exports);
})();
/*! Bundled license information:

@noble/hashes/esm/utils.js:
@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
@noble/curves/esm/abstract/modular.js:
@noble/curves/esm/abstract/curve.js:
@noble/curves/esm/abstract/weierstrass.js:
@noble/curves/esm/_shortw_utils.js:
@noble/curves/esm/secp256k1.js:
@noble/curves/esm/utils.js:
@noble/curves/esm/abstract/modular.js:
@noble/curves/esm/abstract/curve.js:
@noble/curves/esm/abstract/weierstrass.js:
@noble/curves/esm/_shortw_utils.js:
@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/base/lib/esm/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/bip39/esm/index.js:
  (*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) *)

@scure/bip32/lib/esm/index.js:
  (*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) *)
*/

</script>
<script>
const W = window.EthWallet;

// ============ SECURITY VERIFICATION ============
// Known test vector: this private key MUST derive to this address
const TEST_VECTOR = {
    privateKey: '0x4c0883a69102937d6231471b5dbb6204fe512961708279f3d5b4e5c3e2c0e9d5',
    expectedAddress: '0xAa616Ad3E5C2B52e0770a329E98e1432FcEdBdDc'
};

async function runSecurityChecks() {
    const checks = {
        offline: false,
        crypto: false,
        vectors: false,
        entropy: false
    };
    
    // 1. Check offline status
    checks.offline = !navigator.onLine;
    updateCheck('check-offline', checks.offline, checks.offline ? 'Offline ✓' : 'ONLINE - Disconnect recommended');
    
    // 2. Check crypto API availability
    try {
        checks.crypto = !!(window.crypto && window.crypto.getRandomValues);
        updateCheck('check-crypto', checks.crypto, checks.crypto ? 'Crypto API ✓' : 'No CSPRNG!');
    } catch (e) {
        updateCheck('check-crypto', false, 'Crypto Error');
    }
    
    // 3. Verify test vectors
    try {
        const wallet = W.privateKeyToWallet(TEST_VECTOR.privateKey);
        checks.vectors = wallet.address.toLowerCase() === TEST_VECTOR.expectedAddress.toLowerCase();
        updateCheck('check-vectors', checks.vectors, checks.vectors ? 'Test Vectors ✓' : 'VECTOR MISMATCH!');
    } catch (e) {
        updateCheck('check-vectors', false, 'Vector Error: ' + e.message);
    }
    
    // 4. Entropy quality test (basic)
    try {
        const bytes1 = new Uint8Array(32);
        const bytes2 = new Uint8Array(32);
        crypto.getRandomValues(bytes1);
        crypto.getRandomValues(bytes2);
        // Verify they're different (extremely unlikely to be same)
        const same = bytes1.every((b, i) => b === bytes2[i]);
        // Check for minimum variation (at least 8 different values)
        const unique = new Set(bytes1).size;
        checks.entropy = !same && unique >= 8;
        updateCheck('check-entropy', checks.entropy, checks.entropy ? 'Entropy ✓' : 'Poor Entropy!');
    } catch (e) {
        updateCheck('check-entropy', false, 'Entropy Error');
    }
    
    // Calculate file hash (for verification)
    calculateFileHash();
}

function updateCheck(id, pass, text) {
    const el = document.getElementById(id);
    if (el) {
        el.classList.remove('pending', 'pass', 'fail');
        el.classList.add(pass ? 'pass' : 'fail');
        el.textContent = text;
    }
}

async function calculateFileHash() {
    try {
        // Get the document HTML
        const html = document.documentElement.outerHTML;
        const encoder = new TextEncoder();
        const data = encoder.encode(html);
        const hashBuffer = await crypto.subtle.digest('SHA-256', data);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        document.getElementById('file-hash').textContent = hashHex.slice(0, 16) + '...' + hashHex.slice(-16);
        document.getElementById('file-hash').title = 'Full SHA-256: ' + hashHex;
    } catch (e) {
        document.getElementById('file-hash').textContent = 'Could not calculate';
    }
}

// Run security checks on load
setTimeout(runSecurityChecks, 100);

// Listen for online/offline changes
window.addEventListener('online', () => updateCheck('check-offline', false, 'ONLINE - Disconnect recommended'));
window.addEventListener('offline', () => updateCheck('check-offline', true, 'Offline ✓'));
// ============ END SECURITY VERIFICATION ============

// Tab navigation
document.querySelectorAll('.tab').forEach(tab => {
    tab.addEventListener('click', () => {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
        tab.classList.add('active');
        document.getElementById('panel-' + tab.dataset.tab).classList.add('active');
    });
});

function field(title, value) {
    return '<div class="result-title">' + title + '</div><div class="result-value">' + value + '</div>';
}

function showResult(id, html) {
    const el = document.getElementById(id);
    el.innerHTML = html;
    el.classList.remove('hidden');
}

function copyText(text) {
    navigator.clipboard.writeText(text).then(() => alert('Copied!')).catch(() => {
        const ta = document.createElement('textarea');
        ta.value = text;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        document.body.removeChild(ta);
        alert('Copied!');
    });
}

// Generate Wallet with double-derivation verification
function generateWallet() {
    try {
        const wallet = W.generateWallet();
        const verify = document.getElementById('gen-verify').checked;
        
        if (verify) {
            // Double-derivation: derive address from private key again and compare
            const wallet2 = W.privateKeyToWallet(wallet.privateKey);
            if (wallet.address !== wallet2.address) {
                throw new Error('CRITICAL: Double-derivation verification failed! Do not use this wallet.');
            }
        }
        
        // Blur sensitive data by default
        const html = field('Address', wallet.address) + 
            '<div class="result-title">PRIVATE KEY</div>' +
            '<div class="result-value blurred" onclick="this.classList.toggle(\'revealed\')" title="Click to reveal">' + wallet.privateKey + '</div>' +
            '<div class="key-warning">⚠ Private key is blurred for security. Click to reveal. Never share this key.</div>' +
            field('Public Key', wallet.publicKey) +
            (verify ? '<div class="success" style="margin-top:0.5rem;">✓ Double-derivation verified</div>' : '');
        showResult('generate-result', html);
    } catch (e) { showResult('generate-result', '<div class="error">Error: ' + e.message + '</div>'); }
}

// Import Wallet
function importWallet() {
    try {
        const key = document.getElementById('import-key').value.trim();
        if (!W.validatePrivateKey(key)) throw new Error('Invalid private key');
        const wallet = W.privateKeyToWallet(key);
        const html = field('Address', wallet.address) + 
            '<div class="result-title">PRIVATE KEY</div>' +
            '<div class="result-value blurred" onclick="this.classList.toggle(\'revealed\')" title="Click to reveal">' + wallet.privateKey + '</div>' +
            '<div class="key-warning">⚠ Private key is blurred for security. Click to reveal.</div>' +
            field('Public Key', wallet.publicKey);
        showResult('import-result', html);
        // Clear input for security
        document.getElementById('import-key').value = '';
    } catch (e) { showResult('import-result', '<div class="error">Error: ' + e.message + '</div>'); }
}

// Generate Mnemonic
function generateMnemonic() {
    try {
        const count = parseInt(document.getElementById('mnemonic-words').value);
        const result = W.createMnemonic(count);
        const html = '<div class="result-title">MNEMONIC</div>' +
            '<div class="result-value blurred" onclick="this.classList.toggle(\'revealed\')" title="Click to reveal">' + result.mnemonic + '</div>' +
            '<div class="key-warning">⚠ Mnemonic is blurred for security. This is the master backup - store securely!</div>' +
            field('Address', result.address) + 
            '<div class="result-title">PRIVATE KEY</div>' +
            '<div class="result-value blurred" onclick="this.classList.toggle(\'revealed\')" title="Click to reveal">' + result.privateKey + '</div>' +
            field('Path', result.path);
        showResult('mnemonic-generate-result', html);
    } catch (e) { showResult('mnemonic-generate-result', '<div class="error">Error: ' + e.message + '</div>'); }
}

// Recover Mnemonic
function recoverMnemonic() {
    try {
        const mnemonic = document.getElementById('mnemonic-phrase').value.trim();
        const passphrase = document.getElementById('mnemonic-passphrase').value;
        const path = document.getElementById('mnemonic-path').value.trim();
        const count = parseInt(document.getElementById('mnemonic-count').value) || 5;
        const accounts = W.deriveAccounts(mnemonic, path, count, passphrase);
        let html = '';
        accounts.forEach((a, i) => {
            html += '<div style="margin-bottom:1rem;padding-bottom:1rem;border-bottom:1px solid var(--border);">';
            html += field('Account ' + i, '');
            html += field('Path', a.path);
            html += field('Address', a.address);
            html += '<div class="result-title">PRIVATE KEY</div>';
            html += '<div class="result-value blurred" onclick="this.classList.toggle(\'revealed\')" title="Click to reveal">' + a.privateKey + '</div>';
            html += '</div>';
        });
        showResult('mnemonic-recover-result', html);
    } catch (e) { showResult('mnemonic-recover-result', '<div class="error">Error: ' + e.message + '</div>'); }
}

// Vanity
let vanityRunning = false;
let vanityResults = [];

function isValidHex(s) { return /^[0-9a-fA-F]*$/.test(s); }

function checkVanityMatch(address, opts) {
    let addr = address.slice(2);
    const addrCheck = opts.caseSensitive ? addr : addr.toLowerCase();
    
    if (opts.prefix) {
        const p = opts.caseSensitive ? opts.prefix : opts.prefix.toLowerCase();
        if (!addrCheck.startsWith(p)) return false;
    }
    if (opts.suffix) {
        const s = opts.caseSensitive ? opts.suffix : opts.suffix.toLowerCase();
        if (!addrCheck.endsWith(s)) return false;
    }
    if (opts.contains) {
        const c = opts.caseSensitive ? opts.contains : opts.contains.toLowerCase();
        if (!addrCheck.includes(c)) return false;
    }
    if (opts.letters && !/^[a-f]+$/i.test(addr)) return false;
    if (opts.numbers && !/^[0-9]+$/.test(addr)) return false;
    if (opts.mirror) {
        const half = Math.floor(addr.length / 2);
        if (addrCheck.slice(0, half) !== addrCheck.slice(-half).split('').reverse().join('')) return false;
    }
    if (opts.leading && opts.leadingCount > 0) {
        const expected = (opts.caseSensitive ? opts.leading : opts.leading.toLowerCase()).repeat(opts.leadingCount);
        if (!addrCheck.startsWith(expected)) return false;
    }
    if (opts.doubles) {
        let count = 0;
        for (let i = 0; i < addrCheck.length - 1; i += 2) {
            if (addrCheck[i] === addrCheck[i + 1]) count++; else break;
        }
        if (count < 2) return false;
    }
    if (opts.zeros && (addrCheck.match(/0/g) || []).length < 8) return false;
    if (opts.regex) {
        try { if (!new RegExp(opts.regex, opts.caseSensitive ? '' : 'i').test(addrCheck)) return false; }
        catch { return false; }
    }
    return true;
}

function estimateDifficulty(opts) {
    let chars = 0;
    if (opts.prefix) chars += opts.prefix.length;
    if (opts.suffix) chars += opts.suffix.length;
    if (opts.contains) chars += opts.contains.length;
    if (opts.leading && opts.leadingCount) chars = Math.max(chars, opts.leadingCount);
    if (opts.doubles) chars = Math.max(chars, 4);
    if (opts.zeros) chars = Math.max(chars, 2);
    if (opts.letters) chars = Math.max(chars, 8);
    if (opts.numbers) chars = Math.max(chars, 8);
    if (opts.mirror) chars = Math.max(chars, 10);
    if (chars === 0) return null;
    return Math.pow(opts.caseSensitive ? 22 : 16, chars);
}

function updateDifficultyEstimate() {
    const opts = {
        prefix: document.getElementById('vanity-prefix').value.trim(),
        suffix: document.getElementById('vanity-suffix').value.trim(),
        contains: document.getElementById('vanity-contains').value.trim(),
        caseSensitive: document.getElementById('vanity-case').checked,
        letters: document.getElementById('vanity-letters').checked,
        numbers: document.getElementById('vanity-numbers').checked,
        mirror: document.getElementById('vanity-mirror').checked,
        doubles: document.getElementById('vanity-doubles').checked,
        zeros: document.getElementById('vanity-zeros').checked,
        leading: document.getElementById('vanity-leading').value.trim(),
        leadingCount: parseInt(document.getElementById('vanity-leading-count').value) || 4
    };
    const diff = estimateDifficulty(opts);
    const el = document.getElementById('vanity-difficulty');
    if (!diff) { el.value = 'Enter criteria above'; return; }
    if (diff < 1000) el.value = '~' + diff.toFixed(0) + ' attempts (easy)';
    else if (diff < 1000000) el.value = '~' + (diff/1000).toFixed(1) + 'K attempts';
    else if (diff < 1000000000) el.value = '~' + (diff/1000000).toFixed(1) + 'M attempts';
    else el.value = '~' + (diff/1000000000).toFixed(1) + 'B attempts (hard!)';
}

['vanity-prefix','vanity-suffix','vanity-contains','vanity-case','vanity-letters','vanity-numbers','vanity-mirror','vanity-doubles','vanity-zeros','vanity-leading','vanity-leading-count'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.addEventListener(el.type === 'checkbox' ? 'change' : 'input', updateDifficultyEstimate);
});

function exportVanityResults() {
    if (vanityResults.length === 0) return;
    const data = JSON.stringify(vanityResults, null, 2);
    const blob = new Blob([data], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'vanity-addresses-' + Date.now() + '.json'; a.click();
    URL.revokeObjectURL(url);
}

function startVanity() {
    const opts = {
        prefix: document.getElementById('vanity-prefix').value.trim(),
        suffix: document.getElementById('vanity-suffix').value.trim(),
        contains: document.getElementById('vanity-contains').value.trim(),
        regex: document.getElementById('vanity-regex').value.trim(),
        caseSensitive: document.getElementById('vanity-case').checked,
        letters: document.getElementById('vanity-letters').checked,
        numbers: document.getElementById('vanity-numbers').checked,
        mirror: document.getElementById('vanity-mirror').checked,
        doubles: document.getElementById('vanity-doubles').checked,
        zeros: document.getElementById('vanity-zeros').checked,
        contract: document.getElementById('vanity-contract').checked,
        leading: document.getElementById('vanity-leading').value.trim(),
        leadingCount: parseInt(document.getElementById('vanity-leading-count').value) || 4
    };
    const targetCount = parseInt(document.getElementById('vanity-count').value) || 1;

    if (!opts.prefix && !opts.suffix && !opts.contains && !opts.regex && !opts.letters && 
        !opts.numbers && !opts.mirror && !opts.doubles && !opts.zeros && !opts.leading) {
        showResult('vanity-result', '<div class="error">Specify at least one criteria</div>'); return;
    }
    if (opts.prefix && !isValidHex(opts.prefix)) { showResult('vanity-result', '<div class="error">Invalid hex prefix</div>'); return; }
    if (opts.suffix && !isValidHex(opts.suffix)) { showResult('vanity-result', '<div class="error">Invalid hex suffix</div>'); return; }

    vanityRunning = true;
    vanityResults = [];
    let attempts = 0;
    const startTime = performance.now();
    document.getElementById('vanity-export-btn').disabled = true;
    showResult('vanity-result', 'Searching...');
    
    function search() {
        if (!vanityRunning) return;
        for (let i = 0; i < 100; i++) {
            attempts++;
            const wallet = W.generateWallet();
            const checkAddr = opts.contract ? W.calculateContractAddress(wallet.address, 0) : wallet.address;
            
            if (checkVanityMatch(checkAddr, opts)) {
                const elapsed = ((performance.now() - startTime) / 1000).toFixed(2);
                const result = opts.contract 
                    ? { contractAddress: checkAddr, deployerAddress: wallet.address, deployerPrivateKey: wallet.privateKey, attempts, time: elapsed + 's' }
                    : { address: wallet.address, privateKey: wallet.privateKey, attempts, time: elapsed + 's' };
                vanityResults.push(result);
                
                let html = '';
                vanityResults.forEach((r, idx) => {
                    html += '<div style="margin-bottom:1rem;padding-bottom:0.5rem;border-bottom:1px solid var(--border);">';
                    html += '<strong>#' + (idx + 1) + '</strong><br>';
                    if (r.contractAddress) {
                        html += field('Contract', r.contractAddress) + field('Deployer', r.deployerAddress);
                        html += '<div class="result-title">Key</div><div class="result-value blurred" onclick="this.classList.toggle(\'revealed\')">' + r.deployerPrivateKey + '</div>';
                    } else {
                        html += field('Address', r.address);
                        html += '<div class="result-title">Key</div><div class="result-value blurred" onclick="this.classList.toggle(\'revealed\')">' + r.privateKey + '</div>';
                    }
                    html += '<small>Found in ' + r.time + ' (' + r.attempts + ' attempts)</small></div>';
                });
                showResult('vanity-result', html);
                
                if (vanityResults.length >= targetCount) {
                    vanityRunning = false;
                    document.getElementById('vanity-export-btn').disabled = false;
                    return;
                }
            }
        }
        const elapsed = ((performance.now() - startTime) / 1000).toFixed(1);
        showResult('vanity-result', 'Searching... ' + attempts.toLocaleString() + ' attempts (' + elapsed + 's) - Found: ' + vanityResults.length + '/' + targetCount);
        setTimeout(search, 0);
    }
    search();
}

function stopVanity() {
    vanityRunning = false;
    showResult('vanity-result', 'Stopped');
}

// Contract Address
function calculateContract() {
    try {
        const deployer = document.getElementById('contract-deployer').value.trim();
        const nonce = parseInt(document.getElementById('contract-nonce').value) || 0;
        if (!W.validateAddress(deployer)) throw new Error('Invalid deployer address');
        const addr = W.calculateContractAddress(deployer, nonce);
        showResult('contract-result', field('Contract Address', addr));
    } catch (e) { showResult('contract-result', '<div class="error">Error: ' + e.message + '</div>'); }
}

// Sign Message
function signMessage() {
    try {
        const msg = document.getElementById('sign-message').value;
        const key = document.getElementById('sign-key').value.trim();
        const usePrefix = document.getElementById('sign-eth-prefix').checked;
        if (!msg) throw new Error('Enter a message');
        if (!W.validatePrivateKey(key)) throw new Error('Invalid private key');
        const result = W.signMessage(msg, key, usePrefix);
        showResult('sign-result', field('Signature', result.signature) + field('r', result.r) + field('s', result.s) + field('v', result.v) + field('Signer', result.address));
    } catch (e) { showResult('sign-result', '<div class="error">Error: ' + e.message + '</div>'); }
}

// Verify Signature
function verifySignature() {
    try {
        const msg = document.getElementById('verify-message').value;
        const sig = document.getElementById('verify-signature').value.trim();
        const expected = document.getElementById('verify-address').value.trim();
        const usePrefix = document.getElementById('verify-eth-prefix').checked;
        if (!msg || !sig) throw new Error('Enter message and signature');
        const recovered = W.verifyMessage(msg, sig, usePrefix);
        let html = field('Recovered Address', recovered);
        if (expected) {
            const match = recovered.toLowerCase() === expected.toLowerCase();
            html += '<div class="result-title">Match</div><div class="result-value ' + (match ? 'success' : 'error') + '">' + (match ? 'YES - Valid signature' : 'NO - Signature does not match') + '</div>';
        }
        showResult('verify-result', html);
    } catch (e) { showResult('verify-result', '<div class="error">Error: ' + e.message + '</div>'); }
}

// Verify Pair
function verifyPair() {
    try {
        const addr = document.getElementById('pair-address').value.trim();
        const key = document.getElementById('pair-key').value.trim();
        if (!W.validateAddress(addr)) throw new Error('Invalid address');
        if (!W.validatePrivateKey(key)) throw new Error('Invalid private key');
        const wallet = W.privateKeyToWallet(key);
        const match = wallet.address.toLowerCase() === addr.toLowerCase();
        showResult('pair-result', '<div class="result-title">Match</div><div class="result-value ' + (match ? 'success' : 'error') + '">' + (match ? 'YES' : 'NO') + '</div>' + field('Derived Address', wallet.address));
    } catch (e) { showResult('pair-result', '<div class="error">Error: ' + e.message + '</div>'); }
}

// Validate Address
function validateAddress() {
    try {
        const addr = document.getElementById('validate-address').value.trim();
        const valid = W.validateAddress(addr);
        const checksumValid = W.validateChecksumAddress(addr);
        let html = '<div class="result-title">Valid Format</div><div class="result-value ' + (valid ? 'success' : 'error') + '">' + (valid ? 'YES' : 'NO') + '</div>';
        if (valid) {
            html += '<div class="result-title">Valid Checksum</div><div class="result-value ' + (checksumValid ? 'success' : '') + '">' + (checksumValid ? 'YES' : 'No (lowercase or invalid checksum)') + '</div>';
            html += field('Checksummed', W.toChecksumAddress(addr));
        }
        showResult('validate-address-result', html);
    } catch (e) { showResult('validate-address-result', '<div class="error">Error: ' + e.message + '</div>'); }
}

// Validate Key
function validateKey() {
    try {
        const key = document.getElementById('validate-key').value.trim();
        const valid = W.validatePrivateKey(key);
        let html = '<div class="result-title">Valid</div><div class="result-value ' + (valid ? 'success' : 'error') + '">' + (valid ? 'YES' : 'NO') + '</div>';
        if (valid) {
            const wallet = W.privateKeyToWallet(key);
            html += field('Derived Address', wallet.address);
        }
        showResult('validate-key-result', html);
    } catch (e) { showResult('validate-key-result', '<div class="error">Error: ' + e.message + '</div>'); }
}

// Checksum
function checksumAddress() {
    try {
        const addr = document.getElementById('checksum-address').value.trim();
        if (!W.validateAddress(addr)) throw new Error('Invalid address');
        showResult('checksum-result', field('Checksummed Address', W.toChecksumAddress(addr)));
    } catch (e) { showResult('checksum-result', '<div class="error">Error: ' + e.message + '</div>'); }
}

// Keystore Encrypt
async function encryptKeystore() {
    try {
        const key = document.getElementById('keystore-encrypt-key').value.trim();
        const pw = document.getElementById('keystore-encrypt-password').value;
        const confirm = document.getElementById('keystore-encrypt-confirm').value;
        if (!W.validatePrivateKey(key)) throw new Error('Invalid private key');
        if (pw.length < 8) throw new Error('Password must be at least 8 characters');
        if (pw !== confirm) throw new Error('Passwords do not match');
        showResult('keystore-encrypt-result', 'Encrypting...');
        const ks = await W.encryptKeystore(key, pw);
        const json = JSON.stringify(ks, null, 2);
        showResult('keystore-encrypt-result', field('Address', '0x' + ks.address) + '<div class="result-title">Keystore JSON</div><div class="result-value" style="white-space:pre-wrap;font-size:0.7rem;">' + json + '</div><button class="btn-small btn-secondary" onclick="copyText(document.getElementById(\'ks-json\').textContent)">Copy JSON</button><pre id="ks-json" style="display:none">' + json + '</pre>');
    } catch (e) { showResult('keystore-encrypt-result', '<div class="error">Error: ' + e.message + '</div>'); }
}

// Keystore Decrypt
async function decryptKeystore() {
    try {
        const json = document.getElementById('keystore-decrypt-json').value.trim();
        const pw = document.getElementById('keystore-decrypt-password').value;
        if (!json || !pw) throw new Error('Enter keystore JSON and password');
        showResult('keystore-decrypt-result', 'Decrypting...');
        const wallet = await W.decryptKeystore(json, pw);
        showResult('keystore-decrypt-result', field('Address', wallet.address) + field('Private Key', wallet.privateKey));
    } catch (e) { showResult('keystore-decrypt-result', '<div class="error">Error: ' + e.message + '</div>'); }
}

// Sign Transaction
function signTransaction() {
    try {
        const to = document.getElementById('tx-to').value.trim();
        const value = document.getElementById('tx-value').value.trim() || '0';
        const nonce = parseInt(document.getElementById('tx-nonce').value) || 0;
        const gas = parseInt(document.getElementById('tx-gas').value) || 21000;
        const chainId = parseInt(document.getElementById('tx-chainid').value) || 1;
        const gasPrice = document.getElementById('tx-gasprice').value.trim();
        const maxFee = document.getElementById('tx-maxfee').value.trim();
        const priorityFee = document.getElementById('tx-priorityfee').value.trim();
        const data = document.getElementById('tx-data').value.trim() || '0x';
        const key = document.getElementById('tx-key').value.trim();
        if (!W.validateAddress(to)) throw new Error('Invalid To address');
        if (!W.validatePrivateKey(key)) throw new Error('Invalid private key');
        if (!gasPrice && !maxFee) throw new Error('Specify gas price or max fee');
        const txParams = { to, value, nonce, gas, data };
        if (maxFee) { txParams.maxFeePerGas = maxFee; txParams.maxPriorityFeePerGas = priorityFee || '0'; }
        else { txParams.gasPrice = gasPrice; }
        const result = W.signTransaction(txParams, key, chainId);
        showResult('tx-result', field('Transaction Hash', result.hash) + field('Raw Transaction', result.rawTransaction) + field('r', result.r) + field('s', result.s) + field('v', result.v.toString()));
    } catch (e) { showResult('tx-result', '<div class="error">Error: ' + e.message + '</div>'); }
}

// Sign Typed Data
function signTypedData() {
    try {
        const data = document.getElementById('typed-data').value.trim();
        const key = document.getElementById('typed-key').value.trim();
        if (!data) throw new Error('Enter typed data JSON');
        if (!W.validatePrivateKey(key)) throw new Error('Invalid private key');
        const parsed = JSON.parse(data);
        const result = W.signTypedData(parsed, key);
        showResult('typed-sign-result', field('Signature', result.signature) + field('r', result.r) + field('s', result.s) + field('v', result.v) + field('Signer', result.address));
    } catch (e) { showResult('typed-sign-result', '<div class="error">Error: ' + e.message + '</div>'); }
}

// Verify Typed Data
function verifyTypedData() {
    try {
        const data = document.getElementById('typed-verify-data').value.trim();
        const sig = document.getElementById('typed-verify-sig').value.trim();
        const expected = document.getElementById('typed-verify-address').value.trim();
        if (!data || !sig) throw new Error('Enter typed data and signature');
        const parsed = JSON.parse(data);
        const recovered = W.verifyTypedData(parsed, sig);
        let html = field('Recovered Address', recovered);
        if (expected) {
            const match = recovered.toLowerCase() === expected.toLowerCase();
            html += '<div class="result-title">Match</div><div class="result-value ' + (match ? 'success' : 'error') + '">' + (match ? 'YES - Valid signature' : 'NO - Signature does not match') + '</div>';
        }
        showResult('typed-verify-result', html);
    } catch (e) { showResult('typed-verify-result', '<div class="error">Error: ' + e.message + '</div>'); }
}
</script>
</body>
</html>



